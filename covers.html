
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controllers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_bastion_controller.go (100.0%)</option>
				
				<option value="file1">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_controller.go (3.9%)</option>
				
				<option value="file2">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_internetservice_controller.go (100.0%)</option>
				
				<option value="file3">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_loadbalancer_controller.go (100.0%)</option>
				
				<option value="file4">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_natservice_controller.go (100.0%)</option>
				
				<option value="file5">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_net_controller.go (100.0%)</option>
				
				<option value="file6">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_publicip_controller.go (100.0%)</option>
				
				<option value="file7">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_routetable_controller.go (98.1%)</option>
				
				<option value="file8">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_securitygroup_controller.go (99.6%)</option>
				
				<option value="file9">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/osccluster_subnet_controller.go (99.1%)</option>
				
				<option value="file10">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/oscmachine_controller.go (0.0%)</option>
				
				<option value="file11">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/oscmachine_image_controller.go (100.0%)</option>
				
				<option value="file12">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/oscmachine_keypair_controller.go (100.0%)</option>
				
				<option value="file13">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/oscmachine_vm_controller.go (94.8%)</option>
				
				<option value="file14">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/oscmachine_volume_controller.go (74.4%)</option>
				
				<option value="file15">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/oscmachinetemplate_capacity_controller.go (0.0%)</option>
				
				<option value="file16">github.com/outscale-dev/cluster-api-provider-outscale.git/controllers/oscmachinetemplate_controller.go (48.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        "fmt"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/compute"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        osc "github.com/outscale/osc-sdk-go/v2"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getBastionResourceId return vmId from the resourceMap is based on resourceName (tag name + cluster uid).
func getBastionResourceId(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        bastionRef := clusterScope.GetBastionRef()
        if vmId, ok := bastionRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return vmId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkBastionSecurityGroupOscAssociateResourceName check that SecurityGroup tag name in both resource configuration are the same.
func checkBastionSecurityGroupOscAssociateResourceName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        var bastionSecurityGroupNameList []string
        var checkOscAssociate bool
        bastionSpec := clusterScope.GetBastion()
        bastionSpec.SetDefaultValue()
        bastionSecurityGroups := clusterScope.GetBastionSecurityGroups()
        for _, bastionSecurityGroup := range *bastionSecurityGroups </span><span class="cov8" title="1">{
                bastionSecurityGroupName := bastionSecurityGroup.Name + "-" + clusterScope.GetUID()
                bastionSecurityGroupNameList = append(bastionSecurityGroupNameList, bastionSecurityGroupName)
        }</span>
        <span class="cov8" title="1">securityGroupsSpec := clusterScope.GetSecurityGroups()
        for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupName := securityGroupSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, securityGroupName)
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Check match securityGroup with vm")
        for _, validateBastionSecurityGroupName := range bastionSecurityGroupNameList </span><span class="cov8" title="1">{
                checkOscAssociate = Contains(resourceNameList, validateBastionSecurityGroupName)
                if !checkOscAssociate </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s securityGroup does not exist in bastion", validateBastionSecurityGroupName)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// checkBastionSubnetOscAssociateResourceName check the subnet tag name in both resource configuration are the same.
func checkBastionSubnetOscAssociateResourceName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        bastionSpec := clusterScope.GetBastion()
        bastionSpec.SetDefaultValue()
        bastionSubnetName := bastionSpec.SubnetName + "-" + clusterScope.GetUID()
        subnetsSpec := clusterScope.GetSubnet()
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, subnetName)
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Check match subnet with bastion")
        checkOscAssociate := Contains(resourceNameList, bastionSubnetName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s subnet does not exist in bastion", bastionSubnetName)
        }</span>
}

// checkBastionPublicIpOscAssociateResourceName check that PublicIp tag name in both resource configuration are the same.
func checkBastionPublicIpOscAssociateResourceName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        bastionSpec := clusterScope.GetBastion()
        bastionSpec.SetDefaultValue()
        bastionPublicIpName := bastionSpec.PublicIpName + "-" + clusterScope.GetUID()
        publicIpsSpec := clusterScope.GetPublicIp()
        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpName := publicIpSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, publicIpName)
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Check match publicip with bastion")
        checkOscAssociate := Contains(resourceNameList, bastionPublicIpName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s publicIp does not exist in bastion", bastionPublicIpName)
        }</span>
}

// checkBastionFormatParameters check Bastion parameters format.
func checkBastionFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        bastionSpec := clusterScope.GetBastion()
        bastionSpec.SetDefaultValue()
        bastionName := bastionSpec.Name + "-" + clusterScope.GetUID()
        bastionTagName, err := tag.ValidateTagNameValue(bastionName)
        if err != nil </span><span class="cov8" title="1">{
                return bastionTagName, err
        }</span>

        <span class="cov8" title="1">imageName := bastionSpec.ImageName
        clusterScope.V(2).Info("Check Bastion parameters")
        if imageName != "" </span><span class="cov8" title="1">{
                _, err := infrastructurev1beta1.ValidateImageName(imageName)
                if err != nil </span><span class="cov8" title="1">{
                        return bastionTagName, err
                }</span>
        } else<span class="cov8" title="1"> {
                _, err := infrastructurev1beta1.ValidateImageId(bastionSpec.ImageId)
                if err != nil </span><span class="cov8" title="1">{
                        return bastionTagName, err
                }</span>
        }

        <span class="cov8" title="1">bastionKeypairName := bastionSpec.KeypairName
        _, err = infrastructurev1beta1.ValidateKeypairName(bastionKeypairName)
        if err != nil </span><span class="cov8" title="1">{
                return bastionTagName, err
        }</span>

        <span class="cov8" title="1">vmType := bastionSpec.VmType
        _, err = infrastructurev1beta1.ValidateVmType(vmType)
        if err != nil </span><span class="cov8" title="1">{
                return bastionTagName, err
        }</span>

        <span class="cov8" title="1">bastionDeviceName := bastionSpec.DeviceName
        _, err = infrastructurev1beta1.ValidateDeviceName(bastionDeviceName)
        if err != nil </span><span class="cov8" title="1">{
                return bastionTagName, err
        }</span>

        <span class="cov8" title="1">bastionSubregionName := bastionSpec.SubregionName
        _, err = infrastructurev1beta1.ValidateSubregionName(bastionSubregionName)
        if err != nil </span><span class="cov8" title="1">{
                return bastionTagName, err
        }</span>

        <span class="cov8" title="1">bastionSubnetName := bastionSpec.SubnetName
        clusterScope.V(4).Info("Get bastionSubnetName", "bastionSubnetName", bastionSubnetName)

        ipSubnetRange := clusterScope.GetIpSubnetRange(bastionSubnetName)
        clusterScope.V(4).Info("Get valid subnet", "ipSubnetRange", ipSubnetRange)
        bastionPrivateIps := clusterScope.GetBastionPrivateIps()
        networkSpec := clusterScope.GetNetwork()
        networkSpec.SetSubnetDefaultValue()
        for _, bastionPrivateIp := range *bastionPrivateIps </span><span class="cov8" title="1">{
                privateIp := bastionPrivateIp.PrivateIp
                clusterScope.V(4).Info("Get valid IP", "privateIp", privateIp)

                _, err := compute.ValidateIpAddrInCidr(privateIp, ipSubnetRange)
                if err != nil </span><span class="cov8" title="1">{
                        return bastionTagName, err
                }</span>
        }

        <span class="cov8" title="1">if bastionSpec.RootDisk.RootDiskIops != 0 </span><span class="cov8" title="1">{
                rootDiskIops := bastionSpec.RootDisk.RootDiskIops
                clusterScope.V(4).Info("Check rootDiskIops", "rootDiskIops", rootDiskIops)
                _, err := infrastructurev1beta1.ValidateIops(rootDiskIops)
                if err != nil </span><span class="cov8" title="1">{
                        return bastionTagName, err
                }</span>
        }

        <span class="cov8" title="1">rootDiskSize := bastionSpec.RootDisk.RootDiskSize
        clusterScope.V(4).Info("Check rootDiskSize", "rootDiskSize", rootDiskSize)
        _, err = infrastructurev1beta1.ValidateSize(rootDiskSize)
        if err != nil </span><span class="cov8" title="1">{
                return bastionTagName, err
        }</span>

        <span class="cov8" title="1">rootDiskType := bastionSpec.RootDisk.RootDiskType
        clusterScope.V(4).Info("Check rootDiskType", "rootDiskType", rootDiskType)
        _, err = infrastructurev1beta1.ValidateVolumeType(rootDiskType)
        if err != nil </span><span class="cov8" title="1">{
                return bastionTagName, err
        }</span>
        <span class="cov8" title="1">return "", nil</span>
}

// reconcileBastion reconcile the bastion of cluster.
func reconcileBastion(ctx context.Context, clusterScope *scope.ClusterScope, vmSvc compute.OscVmInterface, publicIpSvc security.OscPublicIpInterface, securityGroupSvc security.OscSecurityGroupInterface, imageSvc compute.OscImageInterface, tagSvc tag.OscTagInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        bastionSpec := clusterScope.GetBastion()
        bastionRef := clusterScope.GetBastionRef()
        bastionName := bastionSpec.Name + "-" + clusterScope.GetUID()

        subnetName := bastionSpec.SubnetName + "-" + clusterScope.GetUID()
        subnetId, err := getSubnetResourceId(subnetName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">imageId := bastionSpec.ImageId
        imageName := bastionSpec.ImageName
        if imageName != "" </span><span class="cov8" title="1">{
                if imageId, err = imageSvc.GetImageId(imageName); err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        }

        <span class="cov8" title="1">var publicIpId string
        var bastionPublicIpName string
        var linkPublicIpRef *infrastructurev1beta1.OscResourceReference
        if bastionSpec.PublicIpName != "" </span><span class="cov8" title="1">{
                bastionPublicIpName := bastionSpec.PublicIpName + "-" + clusterScope.GetUID()
                publicIpId, err = getPublicIpResourceId(bastionPublicIpName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">linkPublicIpRef = clusterScope.GetLinkPublicIpRef()
                if len(linkPublicIpRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                        linkPublicIpRef.ResourceMap = make(map[string]string)
                }</span>
        }
        <span class="cov8" title="1">var privateIps []string
        bastionPrivateIps := clusterScope.GetBastionPrivateIps()
        if len(*bastionPrivateIps) &gt; 0 </span><span class="cov8" title="1">{
                for _, bastionPrivateIp := range *bastionPrivateIps </span><span class="cov8" title="1">{
                        privateIp := bastionPrivateIp.PrivateIp
                        privateIps = append(privateIps, privateIp)
                }</span>
        }

        <span class="cov8" title="1">var securityGroupIds []string
        bastionSecurityGroups := clusterScope.GetBastionSecurityGroups()
        for _, bastionSecurityGroup := range *bastionSecurityGroups </span><span class="cov8" title="1">{
                clusterScope.V(4).Info("Get bastionSecurityGroup", "bastionSecurityGroup", bastionSecurityGroup)
                securityGroupName := bastionSecurityGroup.Name + "-" + clusterScope.GetUID()
                securityGroupId, err := getSecurityGroupResourceId(securityGroupName, clusterScope)
                clusterScope.V(4).Info("Get securityGroupId", "securityGroupId", securityGroupId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">securityGroupIds = append(securityGroupIds, securityGroupId)</span>
        }
        <span class="cov8" title="1">var bastion *osc.Vm
        var vmID string
        if len(bastionRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                bastionRef.ResourceMap = make(map[string]string)
        }</span>
        <span class="cov8" title="1">clusterScope.V(4).Info("Get ResourceId", "resourceId", bastionSpec.ResourceId)
        tagKey := "Name"
        tagValue := bastionName
        tag, err := tagSvc.ReadTag(tagKey, tagValue)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not get tag for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">if bastionSpec.ResourceId != "" </span><span class="cov8" title="1">{
                bastionRef.ResourceMap[bastionName] = bastionSpec.ResourceId
                vmId := bastionSpec.ResourceId
                clusterScope.V(4).Info("Get vmId", "bastion", bastionRef.ResourceMap)
                bastion, err = vmSvc.GetVm(vmId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">clusterScope.V(2).Info("Get VmState")
                vmState, err := vmSvc.GetVmState(vmId)
                if err != nil </span><span class="cov8" title="1">{
                        clusterScope.SetVmState(infrastructurev1beta1.VmState("unknown"))
                        return reconcile.Result{}, fmt.Errorf("%w Can not get bastion %s state for OscCluster %s/%s", err, vmId, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">clusterScope.SetVmState(infrastructurev1beta1.VmState(vmState))
                clusterScope.V(4).Info("Get bastion state", "vmState", vmState)</span>
        }
        <span class="cov8" title="1">if (bastion == nil &amp;&amp; tag == nil) || (bastionSpec.ResourceId == "" &amp;&amp; tag == nil) </span><span class="cov8" title="1">{
                clusterScope.V(4).Info("Create the desired bastion", "bastionName", bastionName)
                keypairName := bastionSpec.KeypairName
                clusterScope.V(4).Info("Get keypairName", "keypairName", keypairName)
                vmType := bastionSpec.VmType
                clusterScope.V(4).Info("Get vmType", "vmType", vmType)

                vm, err := vmSvc.CreateVmUserData("", bastionSpec, subnetId, securityGroupIds, privateIps, bastionName, imageId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create bastion for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">vmID = vm.GetVmId()
                err = vmSvc.CheckVmState(5, 120, "running", vmID)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get vm %s running for OscCluster %s/%s", err, vmID, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">clusterScope.V(4).Info("Bastion is running", "vmID", vmID)
                clusterScope.SetVmState(infrastructurev1beta1.VmState("pending"))
                if bastionSpec.PublicIpName != "" </span><span class="cov8" title="1">{
                        linkPublicIpId, err := publicIpSvc.LinkPublicIp(publicIpId, vmID)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not link publicIp %s with %s for OscCluster %s/%s", err, publicIpId, vmID, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">err = vmSvc.CheckVmState(5, 120, "running", vmID)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not get vm %s running for OscCluster %s/%s", err, vmID, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">clusterScope.V(4).Info("Get bastionPublicIpName", "bastionPublicIpName", bastionPublicIpName)
                        linkPublicIpRef.ResourceMap[bastionPublicIpName] = linkPublicIpId</span>

                }
                <span class="cov8" title="1">bastionRef.ResourceMap[bastionName] = vmID
                bastionSpec.ResourceId = vmID</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteBastion reconcile the destruction of the machine bastion.
func reconcileDeleteBastion(ctx context.Context, clusterScope *scope.ClusterScope, vmSvc compute.OscVmInterface, publicIpSvc security.OscPublicIpInterface, securityGroupSvc security.OscSecurityGroupInterface) (reconcile.Result, error) <span class="cov8" title="1">{

        bastionSpec := clusterScope.GetBastion()
        bastionSpec.SetDefaultValue()
        vmId := bastionSpec.ResourceId
        clusterScope.V(4).Info("Get VmID", "vmId", vmId)
        bastionName := bastionSpec.Name
        if bastionSpec.ResourceId == "" </span><span class="cov8" title="1">{
                clusterScope.V(2).Info("The desired bastion is currently destroyed", "bastionName", bastionName)
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">bastion, err := vmSvc.GetVm(vmId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">var securityGroupIds []string
        bastionSecurityGroups := clusterScope.GetBastionSecurityGroups()
        for _, bastionSecurityGroup := range *bastionSecurityGroups </span><span class="cov8" title="1">{
                securityGroupName := bastionSecurityGroup.Name + "-" + clusterScope.GetUID()
                securityGroupId, err := getSecurityGroupResourceId(securityGroupName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">securityGroupIds = append(securityGroupIds, securityGroupId)</span>
        }
        <span class="cov8" title="1">if bastion == nil </span><span class="cov8" title="1">{
                clusterScope.V(2).Info("The desired bastion does not exist anymore", "bastionName", bastionName)
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">if bastionSpec.PublicIpName != "" </span><span class="cov8" title="1">{
                linkPublicIpRef := clusterScope.GetLinkPublicIpRef()
                publicIpName := bastionSpec.PublicIpName + "-" + clusterScope.GetUID()
                err = publicIpSvc.UnlinkPublicIp(linkPublicIpRef.ResourceMap[publicIpName])
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not unlink publicIp for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
        }
        <span class="cov8" title="1">err = vmSvc.DeleteVm(vmId)
        bastionSpec.ResourceId = ""
        clusterScope.V(2).Info("Delete the desired bastion", "bastionName", bastionName)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not delete vm for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/compute"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/net"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/service"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/client-go/tools/record"
        "strings"
        "time"

        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/util/reconciler"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/conditions"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// OscClusterReconciler reconciles a OscCluster object
type OscClusterReconciler struct {
        client.Client
        Recorder         record.EventRecorder
        ReconcileTimeout time.Duration
}

//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=oscclusters,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=oscclusters/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=oscclusters/finalizers,verbs=update
//+kubebuilder:rbac:groups=cluster.x-k8s.io,resources=clusters,verbs=get;list;watch
//+kubebuilder:rbac:groups=cluster.x-k8s.io,resources=clusters/status,verbs=get;list;watch
//+kubebuilder:rbac:groups="",resources=secrets,verbs=get;list;watch
//+kubebuilder:rbac:groups="",resources=events,verbs=create;get;list;patch;update;watch

// getNetSvc retrieve netSvc
func (r *OscClusterReconciler) getNetSvc(ctx context.Context, scope scope.ClusterScope) net.OscNetInterface <span class="cov0" title="0">{
        return net.NewService(ctx, &amp;scope)
}</span>

// getSubnetSvc retrieve subnetSvc
func (r *OscClusterReconciler) getSubnetSvc(ctx context.Context, scope scope.ClusterScope) net.OscSubnetInterface <span class="cov0" title="0">{
        return net.NewService(ctx, &amp;scope)
}</span>

// getInternetServiceSvc retrieve internetServiceSvc
func (r *OscClusterReconciler) getInternetServiceSvc(ctx context.Context, scope scope.ClusterScope) net.OscInternetServiceInterface <span class="cov0" title="0">{
        return net.NewService(ctx, &amp;scope)
}</span>

// getRouteTableSvc retrieve routeTableSvc
func (r *OscClusterReconciler) getRouteTableSvc(ctx context.Context, scope scope.ClusterScope) security.OscRouteTableInterface <span class="cov0" title="0">{
        return security.NewService(ctx, &amp;scope)
}</span>

// getSecurityGroupSvc retrieve securityGroupSvc
func (r *OscClusterReconciler) getSecurityGroupSvc(ctx context.Context, scope scope.ClusterScope) security.OscSecurityGroupInterface <span class="cov0" title="0">{
        return security.NewService(ctx, &amp;scope)
}</span>

// getNatServiceSvc retrieve natServiceSvc
func (r *OscClusterReconciler) getNatServiceSvc(ctx context.Context, scope scope.ClusterScope) net.OscNatServiceInterface <span class="cov0" title="0">{
        return net.NewService(ctx, &amp;scope)
}</span>

// getPublicIpSvc retrieve publicIpSvc
func (r *OscClusterReconciler) getPublicIpSvc(ctx context.Context, scope scope.ClusterScope) security.OscPublicIpInterface <span class="cov0" title="0">{
        return security.NewService(ctx, &amp;scope)
}</span>

// getLoadBalancerSvc retrieve loadBalancerSvc
func (r *OscClusterReconciler) getLoadBalancerSvc(ctx context.Context, scope scope.ClusterScope) service.OscLoadBalancerInterface <span class="cov0" title="0">{
        return service.NewService(ctx, &amp;scope)
}</span>

// getVmSvc retrieve vmSvc
func (r *OscClusterReconciler) getVmSvc(ctx context.Context, scope scope.ClusterScope) compute.OscVmInterface <span class="cov0" title="0">{
        return compute.NewService(ctx, &amp;scope)
}</span>

// getImageSvc retrieve imageSvc
func (r *OscClusterReconciler) getImageSvc(ctx context.Context, scope scope.ClusterScope) compute.OscImageInterface <span class="cov0" title="0">{
        return compute.NewService(ctx, &amp;scope)
}</span>

// getTagSvc retrieve tagSvc
func (r *OscClusterReconciler) getTagSvc(ctx context.Context, scope scope.ClusterScope) tag.OscTagInterface <span class="cov0" title="0">{
        return tag.NewService(ctx, &amp;scope)
}</span>

func (r *OscClusterReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov0" title="0">{
        _ = log.FromContext(ctx)
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(r.ReconcileTimeout))
        defer cancel()
        log := ctrl.LoggerFrom(ctx)
        oscCluster := &amp;infrastructurev1beta1.OscCluster{}

        if err := r.Get(ctx, req.NamespacedName, oscCluster); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.V(2).Info("object was not found")
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }
        <span class="cov0" title="0">cluster, err := util.GetOwnerCluster(ctx, r.Client, oscCluster.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                log.V(2).Info("Cluster Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>

        // Return early if the object or Cluster is paused.
        <span class="cov0" title="0">if annotations.IsPaused(cluster, oscCluster) </span><span class="cov0" title="0">{
                log.V(4).Info("oscCluster or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>

        // Create the cluster scope.
        <span class="cov0" title="0">clusterScope, err := scope.NewClusterScope(scope.ClusterScopeParams{
                Client:     r.Client,
                Logger:     log,
                Cluster:    cluster,
                OscCluster: oscCluster,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to create scope: %+v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := clusterScope.Close(); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()
        <span class="cov0" title="0">osccluster := clusterScope.OscCluster
        if !osccluster.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return r.reconcileDelete(ctx, clusterScope)
        }</span>
        <span class="cov0" title="0">loadBalancerSpec := clusterScope.GetLoadBalancer()
        loadBalancerSpec.SetDefaultValue()
        log.V(2).Info("Create loadBalancer", "loadBalancerName", loadBalancerSpec.LoadBalancerName)
        return r.reconcile(ctx, clusterScope)</span>
}

// alertDuplicate alert if item is present more than once in array
func alertDuplicate(nameArray []string) error <span class="cov8" title="1">{
        checkMap := make(map[string]bool, 0)
        for _, name := range nameArray </span><span class="cov8" title="1">{
                if checkMap[name] == true </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s already exist", name)
                }</span> else<span class="cov8" title="1"> {
                        checkMap[name] = true
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// contains check if item is present in slice
func Contains(slice []string, item string) bool <span class="cov8" title="1">{
        for _, val := range slice </span><span class="cov8" title="1">{
                if val == item </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// reconcile reconcile the creation of the cluster
func (r *OscClusterReconciler) reconcile(ctx context.Context, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov0" title="0">{
        clusterScope.V(2).Info("Reconcile OscCluster")
        osccluster := clusterScope.OscCluster
        controllerutil.AddFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
        if err := clusterScope.PatchObject(); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov0" title="0">clusterScope.EnsureExplicitUID()
        // Check that every element of the cluster spec has the good format (CIDR, Tag, ...)
        netName, err := checkNetFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create net %s for OscCluster %s/%s", err, netName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov0" title="0">subnetName, err := checkSubnetFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create subnet %s for OscCluster %s/%s", err, subnetName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov0" title="0">internetServiceName, err := checkInternetServiceFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create internetService %s for OscCluster %s/%s", err, internetServiceName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov0" title="0">publicIpName, err := checkPublicIpFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create internetService %s for OscCluster %s/%s", err, publicIpName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov0" title="0">natName, err := checkNatFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create natService %s for OscCluster %s/%s", err, natName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov0" title="0">routeTableName, err := checkRouteTableFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create routeTable %s for OscCluster %s/%s", err, routeTableName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov0" title="0">securityGroupName, err := checkSecurityGroupFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create securityGroup %s for OscCluster %s/%s", err, securityGroupName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov0" title="0">routeName, err := checkRouteFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create route %s for OscCluster %s/%s", err, routeName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov0" title="0">securityGroupRuleName, err := checkSecurityGroupRuleFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create security group rule %s for OscCluster %s/%s", err, securityGroupRuleName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov0" title="0">reconcileLoadBalancerName, err := checkLoadBalancerFormatParameters(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create loadBalancer %s for OscCluster %s/%s", err, reconcileLoadBalancerName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        // Check that every element of the cluster spec has a unique tag name
        <span class="cov0" title="0">duplicateResourceRouteTableErr := checkRouteTableOscDuplicateName(clusterScope)
        if duplicateResourceRouteTableErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourceRouteTableErr
        }</span>

        <span class="cov0" title="0">duplicateResourceSecurityGroupErr := checkSecurityGroupOscDuplicateName(clusterScope)
        if duplicateResourceSecurityGroupErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourceSecurityGroupErr
        }</span>

        <span class="cov0" title="0">duplicateResourceRouteErr := checkRouteOscDuplicateName(clusterScope)
        if duplicateResourceRouteErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourceRouteErr
        }</span>

        <span class="cov0" title="0">duplicateResourceSecurityGroupRuleErr := checkSecurityGroupRuleOscDuplicateName(clusterScope)
        if duplicateResourceSecurityGroupRuleErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourceSecurityGroupRuleErr
        }</span>

        <span class="cov0" title="0">duplicateResourcePublicIpErr := checkPublicIpOscDuplicateName(clusterScope)
        if duplicateResourcePublicIpErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourcePublicIpErr
        }</span>

        <span class="cov0" title="0">duplicateResourceSubnetErr := checkSubnetOscDuplicateName(clusterScope)
        if duplicateResourceSubnetErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourceSubnetErr
        }</span>

        // Check that every element of the cluster spec which has other element depencies has the same dependencies tag name

        <span class="cov0" title="0">checkOscAssociatePublicIpErr := checkPublicIpOscAssociateResourceName(clusterScope)
        if checkOscAssociatePublicIpErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociatePublicIpErr
        }</span>

        <span class="cov0" title="0">checkOscAssociateRouteTableSubnetErr := checkRouteTableSubnetOscAssociateResourceName(clusterScope)
        if checkOscAssociateRouteTableSubnetErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociateRouteTableSubnetErr
        }</span>

        <span class="cov0" title="0">checkOscAssociateNatSubnetErr := checkNatSubnetOscAssociateResourceName(clusterScope)
        if checkOscAssociateNatSubnetErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociateNatSubnetErr
        }</span>

        <span class="cov0" title="0">checkOscAssociateLoadBalancerSubnetErr := checkLoadBalancerSubnetOscAssociateResourceName(clusterScope)
        if checkOscAssociateLoadBalancerSubnetErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociateLoadBalancerSubnetErr
        }</span>

        <span class="cov0" title="0">checkOscAssociateLoadBalancerSecurityGroupErr := checkLoadBalancerSecurityGroupOscAssociateResourceName(clusterScope)
        if checkOscAssociateLoadBalancerSecurityGroupErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociateLoadBalancerSecurityGroupErr
        }</span>
        <span class="cov0" title="0">if clusterScope.OscCluster.Spec.Network.Bastion.Enable </span><span class="cov0" title="0">{
                checkOscAssociateBastionSecurityGroupErr := checkBastionSecurityGroupOscAssociateResourceName(clusterScope)
                if checkOscAssociateBastionSecurityGroupErr != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, checkOscAssociateBastionSecurityGroupErr
                }</span>
                <span class="cov0" title="0">checkOscAssociateBastionSubnetErr := checkBastionSubnetOscAssociateResourceName(clusterScope)
                if checkOscAssociateBastionSubnetErr != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, checkOscAssociateBastionSubnetErr
                }</span>
                <span class="cov0" title="0">bastionName, err := checkBastionFormatParameters(clusterScope)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create bastion %s for OscCluster %s/%s", err, bastionName, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
        }
        <span class="cov0" title="0">clusterScope.V(2).Info("Set OscCluster status to not ready")
        clusterScope.SetNotReady()
        // Reconcile each element of the cluster
        netSvc := r.getNetSvc(ctx, *clusterScope)
        tagSvc := r.getTagSvc(ctx, *clusterScope)
        reconcileNet, err := reconcileNet(ctx, clusterScope, netSvc, tagSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile net")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.NetReadyCondition, infrastructurev1beta1.NetReconciliationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileNet, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.NetReadyCondition)

        subnetSvc := r.getSubnetSvc(ctx, *clusterScope)
        reconcileSubnets, err := reconcileSubnet(ctx, clusterScope, subnetSvc, tagSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile subnet")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.SubnetsReadyCondition, infrastructurev1beta1.SubnetsReconciliationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileSubnets, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.SubnetsReadyCondition)

        internetServiceSvc := r.getInternetServiceSvc(ctx, *clusterScope)
        reconcileInternetService, err := reconcileInternetService(ctx, clusterScope, internetServiceSvc, tagSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile internetService")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.InternetServicesReadyCondition, infrastructurev1beta1.InternetServicesFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileInternetService, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.InternetServicesReadyCondition)

        publicIpSvc := r.getPublicIpSvc(ctx, *clusterScope)
        reconcilePublicIp, err := reconcilePublicIp(ctx, clusterScope, publicIpSvc, tagSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile publicIp")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.PublicIpsReadyCondition, infrastructurev1beta1.PublicIpsFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcilePublicIp, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.PublicIpsReadyCondition)

        securityGroupSvc := r.getSecurityGroupSvc(ctx, *clusterScope)
        reconcileSecurityGroups, err := reconcileSecurityGroup(ctx, clusterScope, securityGroupSvc, tagSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile securityGroup")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.SecurityGroupReadyCondition, infrastructurev1beta1.SecurityGroupReconciliationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileSecurityGroups, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.SecurityGroupReadyCondition)

        routeTableSvc := r.getRouteTableSvc(ctx, *clusterScope)
        reconcileRouteTables, err := reconcileRouteTable(ctx, clusterScope, routeTableSvc, tagSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile routeTable")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.RouteTablesReadyCondition, infrastructurev1beta1.RouteTableReconciliationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileRouteTables, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.RouteTablesReadyCondition)

        natServiceSvc := r.getNatServiceSvc(ctx, *clusterScope)
        reconcileNatService, err := reconcileNatService(ctx, clusterScope, natServiceSvc, tagSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile natservice")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.NatServicesReadyCondition, infrastructurev1beta1.NatServicesReconciliationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileNatService, nil
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.NatServicesReadyCondition)

        reconcileNatRouteTable, err := reconcileRouteTable(ctx, clusterScope, routeTableSvc, tagSvc)
        if err != nil </span><span class="cov0" title="0">{
                clusterScope.Error(err, "failed to reconcile NatRouteTable")
                conditions.MarkFalse(osccluster, infrastructurev1beta1.RouteTablesReadyCondition, infrastructurev1beta1.RouteTableReconciliationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileNatRouteTable, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(osccluster, infrastructurev1beta1.RouteTablesReadyCondition)

        loadBalancerSvc := r.getLoadBalancerSvc(ctx, *clusterScope)
        _, err = reconcileLoadBalancer(ctx, clusterScope, loadBalancerSvc, securityGroupSvc)
        if clusterScope.OscCluster.Spec.Network.Bastion.Enable </span><span class="cov0" title="0">{
                vmSvc := r.getVmSvc(ctx, *clusterScope)
                imageSvc := r.getImageSvc(ctx, *clusterScope)
                reconcileBastion, err := reconcileBastion(ctx, clusterScope, vmSvc, publicIpSvc, securityGroupSvc, imageSvc, tagSvc)
                if err != nil </span><span class="cov0" title="0">{
                        clusterScope.Error(err, "failed to reconcile bastion")
                        conditions.MarkFalse(osccluster, infrastructurev1beta1.VmReadyCondition, infrastructurev1beta1.VmNotReadyReason, clusterv1.ConditionSeverityWarning, err.Error())
                        return reconcileBastion, err
                }</span>
        }
        <span class="cov0" title="0">clusterScope.V(2).Info("Set OscCluster status to ready")
        clusterScope.SetReady()
        return reconcile.Result{}, nil</span>
}

// reconcileDelete reconcile the deletion of the cluster
func (r *OscClusterReconciler) reconcileDelete(ctx context.Context, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov0" title="0">{
        clusterScope.V(2).Info("Reconcile OscCluster")
        osccluster := clusterScope.OscCluster

        // reconcile deletion of each element of the cluster

        machines, _, err := clusterScope.ListMachines(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("failed to list machines for OscCluster %s/%s: %+v", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov0" title="0">if len(machines) &gt; 0 </span><span class="cov0" title="0">{
                names := make([]string, len(machines))
                for i, m := range machines </span><span class="cov0" title="0">{
                        names[i] = fmt.Sprintf("machine/%s", m.Name)
                }</span>
                <span class="cov0" title="0">nameMachineList := strings.Join(names, ", ")
                clusterScope.V(2).Info("Machine are still running, postpone oscCluster deletion", "nameMachineList", nameMachineList)
                return reconcile.Result{RequeueAfter: 10 * time.Second}, nil</span>
        }

        <span class="cov0" title="0">publicIpSvc := r.getPublicIpSvc(ctx, *clusterScope)

        securityGroupSvc := r.getSecurityGroupSvc(ctx, *clusterScope)

        if clusterScope.OscCluster.Spec.Network.Bastion.Enable </span><span class="cov0" title="0">{
                vmSvc := r.getVmSvc(ctx, *clusterScope)
                reconcileDeleteBastion, err := reconcileDeleteBastion(ctx, clusterScope, vmSvc, publicIpSvc, securityGroupSvc)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcileDeleteBastion, err
                }</span>
        }
        <span class="cov0" title="0">loadBalancerSvc := r.getLoadBalancerSvc(ctx, *clusterScope)
        reconcileDeleteLoadBalancer, err := reconcileDeleteLoadBalancer(ctx, clusterScope, loadBalancerSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteLoadBalancer, err
        }</span>

        <span class="cov0" title="0">natServiceSvc := r.getNatServiceSvc(ctx, *clusterScope)
        reconcileDeleteNatService, err := reconcileDeleteNatService(ctx, clusterScope, natServiceSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteNatService, err
        }</span>

        <span class="cov0" title="0">reconcileDeletePublicIp, err := reconcileDeletePublicIp(ctx, clusterScope, publicIpSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeletePublicIp, err
        }</span>
        <span class="cov0" title="0">routeTableSvc := r.getRouteTableSvc(ctx, *clusterScope)
        reconcileDeleteRouteTable, err := reconcileDeleteRouteTable(ctx, clusterScope, routeTableSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteRouteTable, err
        }</span>

        <span class="cov0" title="0">reconcileDeleteSecurityGroup, err := reconcileDeleteSecurityGroup(ctx, clusterScope, securityGroupSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteSecurityGroup, err
        }</span>

        <span class="cov0" title="0">internetServiceSvc := r.getInternetServiceSvc(ctx, *clusterScope)
        reconcileDeleteInternetService, err := reconcileDeleteInternetService(ctx, clusterScope, internetServiceSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteInternetService, err
        }</span>

        <span class="cov0" title="0">subnetSvc := r.getSubnetSvc(ctx, *clusterScope)
        reconcileDeleteSubnet, err := reconcileDeleteSubnet(ctx, clusterScope, subnetSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteSubnet, err
        }</span>

        <span class="cov0" title="0">netSvc := r.getNetSvc(ctx, *clusterScope)
        reconcileDeleteNet, err := reconcileDeleteNet(ctx, clusterScope, netSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteNet, err
        }</span>
        <span class="cov0" title="0">controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
        return reconcile.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *OscClusterReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;infrastructurev1beta1.OscCluster{}).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/net"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        osc "github.com/outscale/osc-sdk-go/v2"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getInternetServiceResourceId return the InternetServiceId from the resourceMap base on resourceName (tag name + cluster object uid)
func getInternetServiceResourceId(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        internetServiceRef := clusterScope.GetInternetServiceRef()
        if internetServiceId, ok := internetServiceRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return internetServiceId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkInternetServiceFormatParameters check InternetService parameters format
func checkInternetServiceFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        internetServiceSpec := clusterScope.GetInternetService()
        internetServiceSpec.SetDefaultValue()
        internetServiceName := internetServiceSpec.Name + "-" + clusterScope.GetUID()
        clusterScope.V(2).Info("Check Internet Service parameters")
        internetServiceTagName, err := tag.ValidateTagNameValue(internetServiceName)
        if err != nil </span><span class="cov8" title="1">{
                return internetServiceTagName, err
        }</span>
        <span class="cov8" title="1">return "", nil</span>
}

// ReconcileInternetService reconcile the InternetService of the cluster.
func reconcileInternetService(ctx context.Context, clusterScope *scope.ClusterScope, internetServiceSvc net.OscInternetServiceInterface, tagSvc tag.OscTagInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        internetServiceSpec := clusterScope.GetInternetService()
        internetServiceRef := clusterScope.GetInternetServiceRef()
        internetServiceName := internetServiceSpec.Name + "-" + clusterScope.GetUID()
        var internetService *osc.InternetService
        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        netId, err := getNetResourceId(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if len(internetServiceRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                internetServiceRef.ResourceMap = make(map[string]string)
        }</span>
        <span class="cov8" title="1">tagKey := "Name"
        tagValue := internetServiceName
        tag, err := tagSvc.ReadTag(tagKey, tagValue)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not get tag for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">if internetServiceSpec.ResourceId != "" </span><span class="cov8" title="1">{
                internetServiceRef.ResourceMap[internetServiceName] = internetServiceSpec.ResourceId
                internetServiceId := internetServiceSpec.ResourceId
                clusterScope.V(2).Info("Check if the desired internetservice exist", "internetserviceName", internetServiceName)
                clusterScope.V(4).Info("Get internetServiceId", "internetservice", internetServiceRef.ResourceMap)
                internetService, err = internetServiceSvc.GetInternetService(internetServiceId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        }
        <span class="cov8" title="1">if (internetService == nil &amp;&amp; tag == nil) || (internetServiceSpec.ResourceId == "" &amp;&amp; tag == nil) </span><span class="cov8" title="1">{
                clusterScope.V(2).Info("Create the desired internetservice", "internetServiceName", internetServiceName)
                internetService, err := internetServiceSvc.CreateInternetService(internetServiceName)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create internetservice for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">clusterScope.V(2).Info("Link the desired internetservice with a net", "internetServiceName", internetServiceName)
                err = internetServiceSvc.LinkInternetService(*internetService.InternetServiceId, netId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not link internetService with net for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">internetServiceRef.ResourceMap[internetServiceName] = internetService.GetInternetServiceId()
                internetServiceSpec.ResourceId = internetService.GetInternetServiceId()</span>

        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteInternetService reconcile the destruction of the InternetService of the cluster.
func reconcileDeleteInternetService(ctx context.Context, clusterScope *scope.ClusterScope, internetServiceSvc net.OscInternetServiceInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster
        internetServiceSpec := clusterScope.GetInternetService()
        internetServiceSpec.SetDefaultValue()

        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()

        netId, err := getNetResourceId(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">internetServiceId := internetServiceSpec.ResourceId
        internetServiceName := internetServiceSpec.Name
        internetService, err := internetServiceSvc.GetInternetService(internetServiceId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if internetService == nil </span><span class="cov8" title="1">{
                clusterScope.V(2).Info("The desired internetservice does not exist anymore", "internetServiceName", internetServiceName)
                controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Unlink the desired internetservice", "internetServiceName", internetServiceName)
        err = internetServiceSvc.UnlinkInternetService(internetServiceId, netId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not unlink internetService and net for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Delete the desired internetservice", "internetServiceName", internetServiceName)
        err = internetServiceSvc.DeleteInternetService(internetServiceId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not delete internetService for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        osc "github.com/outscale/osc-sdk-go/v2"

        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/service"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// checkLoadBalancerSubneOscAssociateResourceName check that LoadBalancer Subnet dependancies tag name in both resource configuration are the same.
func checkLoadBalancerSubnetOscAssociateResourceName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        loadBalancerSpec := clusterScope.GetLoadBalancer()
        loadBalancerSubnetName := loadBalancerSpec.SubnetName + "-" + clusterScope.GetUID()
        subnetsSpec := clusterScope.GetSubnet()
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, subnetName)
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Check match subnet with loadBalancer")
        checkOscAssociate := Contains(resourceNameList, loadBalancerSubnetName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s subnet does not exist in loadBalancer", loadBalancerSubnetName)
        }</span>
}

// checkLoadBalancerFormatParameters check LoadBalancer parameters format (Tag format, cidr format, ..)
func checkLoadBalancerFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        loadBalancerSpec := clusterScope.GetLoadBalancer()
        loadBalancerSpec.SetDefaultValue()
        loadBalancerName := loadBalancerSpec.LoadBalancerName
        clusterScope.V(2).Info("Check LoadBalancer name parameters")
        _, err := infrastructurev1beta1.ValidateLoadBalancerName(loadBalancerName)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%s is an invalid loadBalancer name: %w", loadBalancerName, err)
        }</span>

        <span class="cov8" title="1">loadBalancerType := loadBalancerSpec.LoadBalancerType
        _, err = infrastructurev1beta1.ValidateLoadBalancerType(loadBalancerType)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%s is an invalid loadBalancer type: %w", loadBalancerType, err)
        }</span>

        <span class="cov8" title="1">loadBalancerBackendPort := loadBalancerSpec.Listener.BackendPort
        _, err = infrastructurev1beta1.ValidatePort(loadBalancerBackendPort)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%d is an %w for loadBalancer backend", loadBalancerBackendPort, err)
        }</span>

        <span class="cov8" title="1">loadBalancerBackendProtocol := loadBalancerSpec.Listener.BackendProtocol
        _, err = infrastructurev1beta1.ValidateProtocol(loadBalancerBackendProtocol)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%s is an %w for loadBalancer backend", loadBalancerBackendProtocol, err)
        }</span>

        <span class="cov8" title="1">loadBalancerPort := loadBalancerSpec.Listener.LoadBalancerPort
        _, err = infrastructurev1beta1.ValidatePort(loadBalancerPort)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%d is an %w for loadBalancer", loadBalancerPort, err)
        }</span>

        <span class="cov8" title="1">loadBalancerProtocol := loadBalancerSpec.Listener.LoadBalancerProtocol
        _, err = infrastructurev1beta1.ValidateProtocol(loadBalancerProtocol)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%s is an %w for loadBalancer", loadBalancerProtocol, err)
        }</span>

        <span class="cov8" title="1">loadBalancerCheckInterval := loadBalancerSpec.HealthCheck.CheckInterval
        _, err = infrastructurev1beta1.ValidateInterval(loadBalancerCheckInterval)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%d is an %w for loadBalancer", loadBalancerCheckInterval, err)
        }</span>

        <span class="cov8" title="1">loadBalancerHealthyThreshold := loadBalancerSpec.HealthCheck.HealthyThreshold
        _, err = infrastructurev1beta1.ValidateThreshold(loadBalancerHealthyThreshold)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%d is an %w for loadBalancer", loadBalancerHealthyThreshold, err)
        }</span>

        <span class="cov8" title="1">loadBalancerHealthCheckPort := loadBalancerSpec.HealthCheck.Port
        _, err = infrastructurev1beta1.ValidatePort(loadBalancerHealthCheckPort)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%d is an %w for loadBalancer", loadBalancerHealthCheckPort, err)
        }</span>

        <span class="cov8" title="1">loadBalancerHealthCheckProtocol := loadBalancerSpec.HealthCheck.Protocol
        _, err = infrastructurev1beta1.ValidateProtocol(loadBalancerHealthCheckProtocol)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%s is an %w for loadBalancer", loadBalancerHealthCheckProtocol, err)
        }</span>

        <span class="cov8" title="1">loadBalancerTimeout := loadBalancerSpec.HealthCheck.Timeout
        _, err = infrastructurev1beta1.ValidateTimeout(loadBalancerTimeout)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%d is an %w for loadBalancer", loadBalancerTimeout, err)
        }</span>

        <span class="cov8" title="1">loadBalancerUnhealthyThreshold := loadBalancerSpec.HealthCheck.UnhealthyThreshold
        _, err = infrastructurev1beta1.ValidateThreshold(loadBalancerUnhealthyThreshold)
        if err != nil </span><span class="cov8" title="1">{
                return loadBalancerName, fmt.Errorf("%d is an %w for loadBalancer", loadBalancerUnhealthyThreshold, err)
        }</span>

        <span class="cov8" title="1">return "", nil</span>
}

// checkLoadBalancerSecurityOscAssociateResourceName check that LoadBalancer SecurityGroup dependancies tag name in both resource configuration are the same.
func checkLoadBalancerSecurityGroupOscAssociateResourceName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        loadBalancerSpec := clusterScope.GetLoadBalancer()
        loadBalancerSecurityGroupName := loadBalancerSpec.SecurityGroupName + "-" + clusterScope.GetUID()
        securityGroupsSpec := clusterScope.GetSecurityGroups()
        for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupName := securityGroupSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, securityGroupName)
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Check match securityGroup with loadBalancer")
        checkOscAssociate := Contains(resourceNameList, loadBalancerSecurityGroupName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s securityGroup does not exist in loadBalancer", loadBalancerSecurityGroupName)
        }</span>
}

// reconcileLoadBalancer reconciles the loadBalancer of the cluster.
func reconcileLoadBalancer(ctx context.Context, clusterScope *scope.ClusterScope, loadBalancerSvc service.OscLoadBalancerInterface, securityGroupSvc security.OscSecurityGroupInterface) (reconcile.Result, error) <span class="cov8" title="1">{

        loadBalancerSpec := clusterScope.GetLoadBalancer()
        loadBalancerName := loadBalancerSpec.LoadBalancerName
        clusterScope.V(2).Info("Check if the desired loadbalancer exist", "loadBalancerName", loadBalancerName)
        loadbalancer, err := loadBalancerSvc.GetLoadBalancer(loadBalancerSpec)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">subnetName := loadBalancerSpec.SubnetName + "-" + clusterScope.GetUID()
        subnetId, err := getSubnetResourceId(subnetName, clusterScope)
        clusterScope.V(4).Info("Get loadBalancer subnetId", "subnet", subnetId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">securityGroupName := loadBalancerSpec.SecurityGroupName + "-" + clusterScope.GetUID()
        securityGroupId, err := getSecurityGroupResourceId(securityGroupName, clusterScope)
        clusterScope.V(4).Info("Get loadBalancer subnetId", "sg", securityGroupId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">name := loadBalancerName + "-" + clusterScope.GetUID()
        nameTag := osc.ResourceTag{
                Key:   "Name",
                Value: name,
        }
        if loadbalancer != nil </span><span class="cov8" title="1">{
                loadBalancerTag, err := loadBalancerSvc.GetLoadBalancerTag(loadBalancerSpec)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">if loadBalancerTag == nil &amp;&amp; *loadbalancer.LoadBalancerName == loadBalancerName </span><span class="cov8" title="1">{
                        clusterScope.V(4).Info("LoadBalancer already exists", "loadBalancer", loadBalancerName)
                        return reconcile.Result{}, fmt.Errorf("A LoadBalancer %s already exists", loadBalancerName)
                }</span>
                <span class="cov8" title="1">if loadBalancerTag != nil &amp;&amp; *loadBalancerTag.Key == nameTag.Key &amp;&amp; *loadBalancerTag.Value != nameTag.Value </span><span class="cov8" title="1">{
                        clusterScope.V(4).Info("LoadBalancer already exists by other cluster", "loadBalancer", loadBalancerName)

                        return reconcile.Result{}, fmt.Errorf("A LoadBalancer %s already exists that is used by another cluster other than %s", loadBalancerName, clusterScope.GetUID())
                }</span>
        }

        <span class="cov8" title="1">if loadbalancer == nil </span><span class="cov8" title="1">{
                clusterScope.V(2).Info("Create the desired loadBalancer", "loadBalancerName", loadBalancerName)
                _, err := loadBalancerSvc.CreateLoadBalancer(loadBalancerSpec, subnetId, securityGroupId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create loadBalancer for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">clusterScope.V(2).Info("Delete default outbound rule for loadBalancer", "loadBalancerName", loadBalancerName)
                err = securityGroupSvc.DeleteSecurityGroupRule(securityGroupId, "Outbound", "-1", "0.0.0.0/0", "", 0, 0)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w can not empty Outbound sg rules for loadBalancer for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">clusterScope.V(2).Info("Configure the desired loadBalancer", "loadBalancerName", loadBalancerName)
                loadbalancer, err = loadBalancerSvc.ConfigureHealthCheck(loadBalancerSpec)
                clusterScope.V(4).Info("Get loadbalancer", "loadbalancer", loadbalancer)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not configure healthcheck for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">err = loadBalancerSvc.CreateLoadBalancerTag(loadBalancerSpec, nameTag)
                clusterScope.V(2).Info("Create the desired loadBalancer tag name", "loadBalancerName", loadBalancerName)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not tag loadBalancer for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
        }
        <span class="cov8" title="1">controlPlaneEndpoint := *loadbalancer.DnsName
        clusterScope.V(4).Info("Set controlPlaneEndpoint", "endpoint", controlPlaneEndpoint)

        controlPlanePort := loadBalancerSpec.Listener.LoadBalancerPort

        clusterScope.SetControlPlaneEndpoint(clusterv1.APIEndpoint{
                Host: controlPlaneEndpoint,
                Port: controlPlanePort,
        })
        return reconcile.Result{}, nil</span>

}

// reconcileDeleteLoadBalancer reconcile the destruction of the LoadBalancer of the cluster.

func reconcileDeleteLoadBalancer(ctx context.Context, clusterScope *scope.ClusterScope, loadBalancerSvc service.OscLoadBalancerInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster
        loadBalancerSpec := clusterScope.GetLoadBalancer()
        loadBalancerSpec.SetDefaultValue()
        loadBalancerName := loadBalancerSpec.LoadBalancerName

        loadbalancer, err := loadBalancerSvc.GetLoadBalancer(loadBalancerSpec)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if loadbalancer == nil </span><span class="cov8" title="1">{
                clusterScope.V(4).Info("The desired loadBalancer does not exist anymore", "loadBalancerName", loadBalancerName)
                controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">name := loadBalancerName + "-" + clusterScope.GetUID()
        nameTag := osc.ResourceTag{
                Key:   "Name",
                Value: name,
        }
        clusterScope.V(4).Info("Delete the desired loadBalancer", "loadBalancerName", loadBalancerName)
        loadBalancerTag, err := loadBalancerSvc.GetLoadBalancerTag(loadBalancerSpec)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if loadBalancerTag != nil &amp;&amp; *loadBalancerTag.Key == nameTag.Key &amp;&amp; *loadBalancerTag.Value != nameTag.Value </span><span class="cov8" title="1">{
                clusterScope.V(4).Info("Can not delete LoadBalancer that already exists by other cluster", "loadBalancer", loadBalancerName)
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">err = loadBalancerSvc.CheckLoadBalancerDeregisterVm(20, 120, loadBalancerSpec)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w VmBackend is not deregister in loadBalancer %s for OscCluster %s/%s", err, loadBalancerSpec.LoadBalancerName, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov8" title="1">loadBalancerTagKey := osc.ResourceLoadBalancerTag{
                Key: &amp;nameTag.Key,
        }
        err = loadBalancerSvc.DeleteLoadBalancerTag(loadBalancerSpec, loadBalancerTagKey)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not delete loadBalancer Tag for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>

        <span class="cov8" title="1">err = loadBalancerSvc.DeleteLoadBalancer(loadBalancerSpec)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not delete loadBalancer for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/net"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        osc "github.com/outscale/osc-sdk-go/v2"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// GetNatResourceId return the NatId from the resourceMap base on NatName (tag name + cluster object uid)
func getNatResourceId(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        natServiceRef := clusterScope.GetNatServiceRef()
        if natServiceId, ok := natServiceRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return natServiceId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

func checkNatFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        natServiceSpec := clusterScope.GetNatService()
        natServiceSpec.SetDefaultValue()
        natName := natServiceSpec.Name + "-" + clusterScope.GetUID()
        natSubnetName := natServiceSpec.SubnetName + "-" + clusterScope.GetUID()
        natPublicIpName := natServiceSpec.PublicIpName + "-" + clusterScope.GetUID()
        natTagName, err := tag.ValidateTagNameValue(natName)
        if err != nil </span><span class="cov8" title="1">{
                return natTagName, err
        }</span>
        <span class="cov8" title="1">natSubnetTagName, err := tag.ValidateTagNameValue(natSubnetName)
        if err != nil </span><span class="cov8" title="1">{
                return natSubnetTagName, err
        }</span>
        <span class="cov8" title="1">natPublicIpTagName, err := tag.ValidateTagNameValue(natPublicIpName)
        if err != nil </span><span class="cov8" title="1">{
                return natPublicIpTagName, err
        }</span>
        <span class="cov8" title="1">return "", nil</span>
}

// checkNatSubnetOscAssociateResourceName check that Nat Subnet dependancies tag name in both resource configuration are the same.
func checkNatSubnetOscAssociateResourceName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        natServiceSpec := clusterScope.GetNatService()
        natServiceSpec.SetDefaultValue()
        natSubnetName := natServiceSpec.SubnetName + "-" + clusterScope.GetUID()
        subnetsSpec := clusterScope.GetSubnet()
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, subnetName)
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Check match subnet with nat service")
        checkOscAssociate := Contains(resourceNameList, natSubnetName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s subnet does not exist in natService", natSubnetName)
        }</span>
}

// reconcileNatService reconcile the NatService of the cluster.
func reconcileNatService(ctx context.Context, clusterScope *scope.ClusterScope, natServiceSvc net.OscNatServiceInterface, tagSvc tag.OscTagInterface) (reconcile.Result, error) <span class="cov8" title="1">{

        natServiceSpec := clusterScope.GetNatService()

        natServiceRef := clusterScope.GetNatServiceRef()
        natServiceName := natServiceSpec.Name + "-" + clusterScope.GetUID()
        var natService *osc.NatService
        publicIpName := natServiceSpec.PublicIpName + "-" + clusterScope.GetUID()
        publicIpId, err := getPublicIpResourceId(publicIpName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">subnetName := natServiceSpec.SubnetName + "-" + clusterScope.GetUID()

        subnetId, err := getSubnetResourceId(subnetName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if len(natServiceRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                natServiceRef.ResourceMap = make(map[string]string)
        }</span>
        <span class="cov8" title="1">tagKey := "Name"
        tagValue := natServiceName
        tag, err := tagSvc.ReadTag(tagKey, tagValue)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not get tag for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">if natServiceSpec.ResourceId != "" </span><span class="cov8" title="1">{
                natServiceRef.ResourceMap[natServiceName] = natServiceSpec.ResourceId
                natServiceId := natServiceSpec.ResourceId
                clusterScope.V(4).Info("Get natService Id", "natService", natServiceId)
                clusterScope.V(2).Info("Check if the desired natService exist")
                natService, err = natServiceSvc.GetNatService(natServiceId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        }
        <span class="cov8" title="1">if (natService == nil &amp;&amp; tag == nil) || (natServiceSpec.ResourceId == "" &amp;&amp; tag == nil) </span><span class="cov8" title="1">{
                clusterScope.V(4).Info("Create the desired natService", "natServiceName", natServiceName)
                networkSpec := clusterScope.GetNetwork()
                clusterName := networkSpec.ClusterName + "-" + clusterScope.GetUID()
                clusterScope.V(2).Info("Create the desired natService", "natServiceName", natServiceName)
                natService, err := natServiceSvc.CreateNatService(publicIpId, subnetId, natServiceName, clusterName)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create natService for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">natServiceRef.ResourceMap[natServiceName] = natService.GetNatServiceId()
                natServiceSpec.ResourceId = natService.GetNatServiceId()</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteNatService reconcile the destruction of the NatService of the cluster.
func reconcileDeleteNatService(ctx context.Context, clusterScope *scope.ClusterScope, natServiceSvc net.OscNatServiceInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster
        natServiceSpec := clusterScope.GetNatService()
        natServiceSpec.SetDefaultValue()
        natServiceName := natServiceSpec.Name + "-" + clusterScope.GetUID()

        natServiceId := natServiceSpec.ResourceId
        natService, err := natServiceSvc.GetNatService(natServiceId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if natService == nil </span><span class="cov8" title="1">{
                clusterScope.V(2).Info("The desired natService does not exist anymore", "natServiceName", natServiceName)
                controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Delete the desired natService", "natServiceName", natServiceName)
        err = natServiceSvc.DeleteNatService(natServiceId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not delete natService for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, err</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/net"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        osc "github.com/outscale/osc-sdk-go/v2"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getNetResourceId return the netId from the resourceMap base on resourceName (tag name + cluster object uid)
func getNetResourceId(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        netRef := clusterScope.GetNetRef()
        if netId, ok := netRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return netId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkNetFormatParameters check net parameters format (Tag format, cidr format, ..)
func checkNetFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        netTagName, err := tag.ValidateTagNameValue(netName)
        if err != nil </span><span class="cov8" title="1">{
                return netTagName, err
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Check Net IpRange parameters")
        netIpRange := netSpec.IpRange
        _, err = infrastructurev1beta1.ValidateCidr(netIpRange)
        if err != nil </span><span class="cov8" title="1">{
                return netTagName, err
        }</span>
        <span class="cov8" title="1">return "", nil</span>
}

// reconcileNet reconcile the Net of the cluster.
func reconcileNet(ctx context.Context, clusterScope *scope.ClusterScope, netSvc net.OscNetInterface, tagSvc tag.OscTagInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netRef := clusterScope.GetNetRef()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        clusterName := netSpec.ClusterName + "-" + clusterScope.GetUID()

        var net *osc.Net
        var err error
        if len(netRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                netRef.ResourceMap = make(map[string]string)
        }</span>
        <span class="cov8" title="1">tagKey := "Name"
        tagValue := netName
        tag, err := tagSvc.ReadTag(tagKey, tagValue)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not get tag for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">if netSpec.ResourceId != "" </span><span class="cov8" title="1">{
                netRef.ResourceMap[netName] = netSpec.ResourceId
                netId := netSpec.ResourceId
                clusterScope.V(2).Info("Check if the desired net exist", "netName", netName)
                clusterScope.V(4).Info("Get netId", "net", netRef.ResourceMap)
                net, err = netSvc.GetNet(netId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        }
        <span class="cov8" title="1">if (net == nil &amp;&amp; tag == nil) || (netSpec.ResourceId == "" &amp;&amp; tag == nil) </span><span class="cov8" title="1">{
                clusterScope.V(2).Info("Create the desired net", "netName", netName)
                net, err := netSvc.CreateNet(netSpec, clusterName, netName)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create net for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">clusterScope.V(4).Info("Get net", "net", net)
                netRef.ResourceMap[netName] = net.GetNetId()
                netSpec.ResourceId = *net.NetId
                netRef.ResourceMap[netName] = net.GetNetId()
                netSpec.ResourceId = net.GetNetId()</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteNet reconcile the destruction of the Net of the cluster.
func reconcileDeleteNet(ctx context.Context, clusterScope *scope.ClusterScope, netSvc net.OscNetInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster

        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netId := netSpec.ResourceId
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        net, err := netSvc.GetNet(netId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if net == nil </span><span class="cov8" title="1">{
                clusterScope.V(4).Info("The desired net does not exist anymore", "netName", netName)
                controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Delete the desired net", "netName", netName)
        err = netSvc.DeleteNet(netId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not delete net for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getPublicIpResourceId return the resourceId from the resourceMap base on PublicIpName (tag name + cluster object uid)
func getPublicIpResourceId(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        publicIpRef := clusterScope.GetPublicIpRef()
        if publicIpId, ok := publicIpRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return publicIpId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

func getLinkPublicIpResourceId(resourceName string, machineScope *scope.MachineScope) (string, error) <span class="cov8" title="1">{
        linkPublicIpRef := machineScope.GetLinkPublicIpRef()
        if linkPublicIpId, ok := linkPublicIpRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return linkPublicIpId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkPublicIpFormatParameters check PublicIp parameters format (Tag format, cidr format, ..)
func checkPublicIpFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        var publicIpsSpec []*infrastructurev1beta1.OscPublicIp
        networkSpec := clusterScope.GetNetwork()
        if networkSpec.PublicIps == nil </span><span class="cov8" title="1">{
                networkSpec.SetPublicIpDefaultValue()
                publicIpsSpec = networkSpec.PublicIps
        }</span> else<span class="cov8" title="1"> {
                publicIpsSpec = clusterScope.GetPublicIp()
        }</span>
        <span class="cov8" title="1">for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpName := publicIpSpec.Name + "-" + clusterScope.GetUID()
                clusterScope.V(2).Info("Check Public Ip parameters")
                publicIpTagName, err := tag.ValidateTagNameValue(publicIpName)
                if err != nil </span><span class="cov8" title="1">{
                        return publicIpTagName, err
                }</span>
        }
        <span class="cov8" title="1">return "", nil</span>
}

// checkPublicIpOscAssociateResourceName check that PublicIp dependancies tag name in both resource configuration are the same.
func checkPublicIpOscAssociateResourceName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        natServiceSpec := clusterScope.GetNatService()
        natServiceSpec.SetDefaultValue()
        natPublicIpName := natServiceSpec.PublicIpName + "-" + clusterScope.GetUID()
        var publicIpsSpec []*infrastructurev1beta1.OscPublicIp
        networkSpec := clusterScope.GetNetwork()
        publicIpsSpec = networkSpec.PublicIps
        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpName := publicIpSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, publicIpName)
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Check match public ip with nat service")

        checkOscAssociate := Contains(resourceNameList, natPublicIpName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("publicIp %s does not exist in natService ", natPublicIpName)
        }</span>
}

// checkPublicIpOscDuplicateName check that there are not the same name for PublicIp resource.
func checkPublicIpOscDuplicateName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        publicIpsSpec := clusterScope.GetPublicIp()
        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                resourceNameList = append(resourceNameList, publicIpSpec.Name)
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Check unique name publicIp")
        duplicateResourceErr := alertDuplicate(resourceNameList)
        if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                return duplicateResourceErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// reconcilePublicIp reconcile the PublicIp of the cluster.
func reconcilePublicIp(ctx context.Context, clusterScope *scope.ClusterScope, publicIpSvc security.OscPublicIpInterface, tagSvc tag.OscTagInterface) (reconcile.Result, error) <span class="cov8" title="1">{

        var publicIpsSpec []*infrastructurev1beta1.OscPublicIp
        publicIpsSpec = clusterScope.GetPublicIp()
        var publicIpId string
        publicIpRef := clusterScope.GetPublicIpRef()
        var publicIpIds []string

        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpId = publicIpSpec.ResourceId
                publicIpIds = append(publicIpIds, publicIpId)
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Check if the desired publicip exist")
        validPublicIpIds, err := publicIpSvc.ValidatePublicIpIds(publicIpIds)
        clusterScope.V(4).Info("Check public Ip Ids")
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">clusterScope.V(4).Info("Number of publicIp", "publicIpLength", len(publicIpsSpec))
        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpName := publicIpSpec.Name + "-" + clusterScope.GetUID()
                tagKey := "Name"
                tagValue := publicIpName
                tag, err := tagSvc.ReadTag(tagKey, tagValue)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get tag for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">if len(publicIpRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                        publicIpRef.ResourceMap = make(map[string]string)
                }</span>
                <span class="cov8" title="1">if publicIpSpec.ResourceId != "" </span><span class="cov8" title="1">{
                        publicIpRef.ResourceMap[publicIpName] = publicIpSpec.ResourceId
                }</span>
                <span class="cov8" title="1">_, resourceMapExist := publicIpRef.ResourceMap[publicIpName]
                if resourceMapExist </span><span class="cov8" title="1">{
                        publicIpSpec.ResourceId = publicIpRef.ResourceMap[publicIpName]
                }</span>

                <span class="cov8" title="1">publicIpId := publicIpRef.ResourceMap[publicIpName]
                if !Contains(validPublicIpIds, publicIpId) &amp;&amp; tag == nil </span><span class="cov8" title="1">{
                        publicIp, err := publicIpSvc.CreatePublicIp(publicIpName)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not create publicIp for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">clusterScope.V(4).Info("Get publicIp", "publicip", publicIp)
                        publicIpRef.ResourceMap[publicIpName] = publicIp.GetPublicIpId()
                        publicIpSpec.ResourceId = publicIp.GetPublicIpId()</span>
                }
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeletePublicIp reconcile the destruction of the PublicIp of the cluster.
func reconcileDeletePublicIp(ctx context.Context, clusterScope *scope.ClusterScope, publicIpSvc security.OscPublicIpInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster
        var publicIpsSpec []*infrastructurev1beta1.OscPublicIp
        networkSpec := clusterScope.GetNetwork()
        if networkSpec.PublicIps == nil </span><span class="cov8" title="1">{
                networkSpec.SetPublicIpDefaultValue()
                publicIpsSpec = networkSpec.PublicIps
        }</span> else<span class="cov8" title="1"> {
                publicIpsSpec = clusterScope.GetPublicIp()
        }</span>
        <span class="cov8" title="1">var publicIpIds []string
        var publicIpId string
        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpId = publicIpSpec.ResourceId
                publicIpIds = append(publicIpIds, publicIpId)
        }</span>
        <span class="cov8" title="1">validPublicIpIds, err := publicIpSvc.ValidatePublicIpIds(publicIpIds)
        clusterScope.V(4).Info("Check validPublicIpIds", "validPublicIpIds", validPublicIpIds)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">clusterScope.V(4).Info("Check publicIp Ids", "publicip", publicIpIds)
        clusterScope.V(4).Info("Number of publicIp", "publicIpLength", len(publicIpsSpec))
        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpId := publicIpSpec.ResourceId
                clusterScope.V(4).Info("Check publicIp Id", "publicipid", publicIpId)
                publicIpName := publicIpSpec.Name + "-" + clusterScope.GetUID()
                if !Contains(validPublicIpIds, publicIpId) </span><span class="cov8" title="1">{
                        controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov8" title="1">err = publicIpSvc.CheckPublicIpUnlink(5, 120, publicIpId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete publicIp %s for Osccluster %s/%s", err, publicIpId, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">clusterScope.V(2).Info("Delete the desired publicip", "publicIpName", publicIpName)
                err = publicIpSvc.DeletePublicIp(publicIpId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete publicIp for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>

        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getRouteTableResourceId return the RouteTableId from the resourceMap base on RouteTableName (tag name + cluster object uid)
func getRouteTableResourceId(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        routeTableRef := clusterScope.GetRouteTablesRef()
        if routeTableId, ok := routeTableRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return routeTableId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// getRouteResourceId return the resourceId from the resourceMap base on routeName (tag name + cluster object uid)
func getRouteResourceId(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        routeRef := clusterScope.GetRouteRef()
        if routeId, ok := routeRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return routeId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkRouteFormatParameters check Route parameters format (Tag format, cidr format, ..)
func checkRouteTableFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        var routeTablesSpec []*infrastructurev1beta1.OscRouteTable
        networkSpec := clusterScope.GetNetwork()
        if networkSpec.RouteTables == nil </span><span class="cov8" title="1">{
                networkSpec.SetRouteTableDefaultValue()
                routeTablesSpec = networkSpec.RouteTables
        }</span> else<span class="cov8" title="1"> {
                routeTablesSpec = clusterScope.GetRouteTables()
        }</span>
        <span class="cov8" title="1">for _, routeTableSpec := range routeTablesSpec </span><span class="cov8" title="1">{
                routeTableName := routeTableSpec.Name + "-" + clusterScope.GetUID()
                clusterScope.V(2).Info("Check Route table parameters")
                routeTableTagName, err := tag.ValidateTagNameValue(routeTableName)
                if err != nil </span><span class="cov8" title="1">{
                        return routeTableTagName, err
                }</span>
        }
        <span class="cov8" title="1">return "", nil</span>
}

// checkRouteFormatParameters check Route parameters format (Tag format, cidr format, ..)
func checkRouteFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        var routeTablesSpec []*infrastructurev1beta1.OscRouteTable
        routeTablesSpec = clusterScope.GetRouteTables()
        for _, routeTableSpec := range routeTablesSpec </span><span class="cov8" title="1">{
                routesSpec := clusterScope.GetRoute(routeTableSpec.Name)
                for _, routeSpec := range *routesSpec </span><span class="cov8" title="1">{
                        routeName := routeSpec.Name + "-" + clusterScope.GetUID()
                        routeTagName, err := tag.ValidateTagNameValue(routeName)
                        if err != nil </span><span class="cov8" title="1">{
                                return routeTagName, err
                        }</span>
                        <span class="cov8" title="1">clusterScope.V(2).Info("Check route destination IpRange parameters")
                        destinationIpRange := routeSpec.Destination
                        _, err = infrastructurev1beta1.ValidateCidr(destinationIpRange)
                        if err != nil </span><span class="cov8" title="1">{
                                return routeTagName, err
                        }</span>
                }
        }
        <span class="cov8" title="1">return "", nil</span>
}

// checkRouteTableSubnetOscAssociateResourceName check that RouteTable Subnet dependancies tag name in both resource configuration are the same.
func checkRouteTableSubnetOscAssociateResourceName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        routeTablesSpec := clusterScope.GetRouteTables()
        resourceNameList = resourceNameList[:0]
        subnetsSpec := clusterScope.GetSubnet()
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, subnetName)
        }</span>
        <span class="cov8" title="1">for _, routeTableSpec := range routeTablesSpec </span><span class="cov8" title="1">{
                routeTableSubnetsSpec := routeTableSpec.Subnets
                for _, routeTableSubnet := range routeTableSubnetsSpec </span><span class="cov8" title="1">{
                        routeTableSubnetName := routeTableSubnet + "-" + clusterScope.GetUID()
                        clusterScope.V(2).Info("Check the desired subnet", "routeTableSubnet", routeTableSubnet)
                        checkOscAssociate := Contains(resourceNameList, routeTableSubnetName)
                        if checkOscAssociate </span><span class="cov8" title="1">{
                                return nil
                        }</span> else<span class="cov8" title="1"> {
                                return fmt.Errorf("%s subnet does not exist in routeTable", routeTableSubnetName)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// checkRouteTableOscDuplicateName check that there are not the same name for RouteTable.
func checkRouteTableOscDuplicateName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        routeTablesSpec := clusterScope.GetRouteTables()
        for _, routeTableSpec := range routeTablesSpec </span><span class="cov8" title="1">{
                resourceNameList = append(resourceNameList, routeTableSpec.Name)
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Check unique routetable")
        duplicateResourceErr := alertDuplicate(resourceNameList)
        if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                return duplicateResourceErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// checkRouteOscDuplicateName check that there are not the same name for route.
func checkRouteOscDuplicateName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        routeTablesSpec := clusterScope.GetRouteTables()
        for _, routeTableSpec := range routeTablesSpec </span><span class="cov8" title="1">{
                routesSpec := clusterScope.GetRoute(routeTableSpec.Name)
                for _, routeSpec := range *routesSpec </span><span class="cov8" title="1">{
                        resourceNameList = append(resourceNameList, routeSpec.Name)
                }</span>
                <span class="cov8" title="1">clusterScope.V(2).Info("Check unique route")
                duplicateResourceErr := alertDuplicate(resourceNameList)
                if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                        return duplicateResourceErr
                }</span> else<span class="cov8" title="1"> {
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// reconcileRoute reconcile the RouteTable and the Route of the cluster.
func reconcileRoute(ctx context.Context, clusterScope *scope.ClusterScope, routeSpec infrastructurev1beta1.OscRoute, routeTableName string, routeTableSvc security.OscRouteTableInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        routeRef := clusterScope.GetRouteRef()
        routeTablesRef := clusterScope.GetRouteTablesRef()
        resourceName := routeSpec.TargetName + "-" + clusterScope.GetUID()
        resourceType := routeSpec.TargetType
        routeName := routeSpec.Name + "-" + clusterScope.GetUID()
        if len(routeRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                routeRef.ResourceMap = make(map[string]string)
        }</span>
        <span class="cov8" title="1">var resourceId string
        var err error
        if resourceType == "gateway" </span><span class="cov8" title="1">{
                resourceId, err = getInternetServiceResourceId(resourceName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        } else<span class="cov8" title="1"> {
                resourceId, err = getNatResourceId(resourceName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        }
        <span class="cov8" title="1">destinationIpRange := routeSpec.Destination
        associateRouteTableId := routeTablesRef.ResourceMap[routeTableName]
        clusterScope.V(2).Info("Check if the desired route exist", "routename", routeName)
        routeTableFromRoute, err := routeTableSvc.GetRouteTableFromRoute(associateRouteTableId, resourceId, resourceType)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if routeTableFromRoute == nil </span><span class="cov8" title="1">{
                clusterScope.V(4).Info("Create Route", "Route", resourceId)
                clusterScope.V(2).Info("Create the desired route", "routeName", routeName)
                routeTableFromRoute, err = routeTableSvc.CreateRoute(destinationIpRange, routeTablesRef.ResourceMap[routeTableName], resourceId, resourceType)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create route for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
        }

        <span class="cov8" title="1">routeRef.ResourceMap[routeName] = routeTableFromRoute.GetRouteTableId()
        return reconcile.Result{}, nil</span>

}

// reconcileRoute reconcile the RouteTable and the Route of the cluster.
func reconcileDeleteRoute(ctx context.Context, clusterScope *scope.ClusterScope, routeSpec infrastructurev1beta1.OscRoute, routeTableName string, routeTableSvc security.OscRouteTableInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster

        routeTablesRef := clusterScope.GetRouteTablesRef()

        resourceName := routeSpec.TargetName + "-" + clusterScope.GetUID()
        resourceType := routeSpec.TargetType
        routeName := routeSpec.Name + "-" + clusterScope.GetUID()
        var resourceId string
        var err error
        if resourceType == "gateway" </span><span class="cov8" title="1">{
                resourceId, err = getInternetServiceResourceId(resourceName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        } else<span class="cov8" title="1"> {
                resourceId, err = getNatResourceId(resourceName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        }
        <span class="cov8" title="1">routeTableId, err := getRouteResourceId(routeName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">destinationIpRange := routeSpec.Destination
        associateRouteTableId := routeTablesRef.ResourceMap[routeTableName]

        clusterScope.V(2).Info("Check if the desired route still exist", "routeName", routeName)
        routeTableFromRoute, err := routeTableSvc.GetRouteTableFromRoute(associateRouteTableId, resourceId, resourceType)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if routeTableFromRoute == nil </span><span class="cov8" title="1">{
                clusterScope.V(2).Info("The desired route does not exist anymore", "routeName", routeName)
                controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">clusterScope.V(4).Info("Delete destinationIpRange", "routeTable", destinationIpRange)
        clusterScope.V(4).Info("Delete the desired route", "routeName", routeName)
        err = routeTableSvc.DeleteRoute(destinationIpRange, routeTableId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not delete route for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>

}

// reconcileRouteTable reconcile the RouteTable and the Route of the cluster.
func reconcileRouteTable(ctx context.Context, clusterScope *scope.ClusterScope, routeTableSvc security.OscRouteTableInterface, tagSvc tag.OscTagInterface) (reconcile.Result, error) <span class="cov8" title="1">{

        routeTablesSpec := clusterScope.GetRouteTables()
        routeTablesRef := clusterScope.GetRouteTablesRef()
        linkRouteTablesRef := clusterScope.GetLinkRouteTablesRef()

        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        netId, err := getNetResourceId(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">networkSpec := clusterScope.GetNetwork()
        clusterName := networkSpec.ClusterName + "-" + clusterScope.GetUID()

        clusterScope.V(4).Info("Get list of all desired routetable in net", "netId", netId)
        routeTableIds, err := routeTableSvc.GetRouteTableIdsFromNetIds(netId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">clusterScope.V(4).Info("Number of routeTable", "routeTableLength", routeTablesSpec)
        for _, routeTableSpec := range routeTablesSpec </span><span class="cov8" title="1">{
                routeTableName := routeTableSpec.Name + "-" + clusterScope.GetUID()
                clusterScope.V(2).Info("Check if the desired routeTable exist in net", "routeTableName", routeTableName)
                clusterScope.V(4).Info("Get routeTable Id", "routeTable", routeTablesRef.ResourceMap)

                tagKey := "Name"
                tagValue := routeTableName
                tag, err := tagSvc.ReadTag(tagKey, tagValue)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get tag for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">if len(routeTablesRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                        routeTablesRef.ResourceMap = make(map[string]string)
                }</span>
                <span class="cov8" title="1">if len(linkRouteTablesRef) == 0 </span><span class="cov8" title="1">{
                        linkRouteTablesRef = make(map[string][]string)
                }</span>
                <span class="cov8" title="1">if routeTableSpec.ResourceId != "" </span><span class="cov8" title="1">{
                        routeTablesRef.ResourceMap[routeTableName] = routeTableSpec.ResourceId
                }</span>
                <span class="cov8" title="1">_, resourceMapExist := routeTablesRef.ResourceMap[routeTableName]
                if resourceMapExist </span><span class="cov8" title="1">{
                        routeTableSpec.ResourceId = routeTablesRef.ResourceMap[routeTableName]
                }</span>

                <span class="cov8" title="1">routeTableId := routeTablesRef.ResourceMap[routeTableName]
                var natRouteTable bool = false

                if !Contains(routeTableIds, routeTableId) &amp;&amp; tag == nil </span><span class="cov8" title="1">{
                        clusterScope.V(2).Info("Check Nat RouteTable")
                        routesSpec := clusterScope.GetRoute(routeTableSpec.Name)
                        clusterScope.V(4).Info("Number of route", "routeLength", len(*routesSpec))
                        for _, routeSpec := range *routesSpec </span><span class="cov8" title="1">{
                                resourceType := routeSpec.TargetType
                                clusterScope.V(4).Info("Get resourceType", "ResourceType", resourceType)
                                if resourceType == "nat" </span><span class="cov0" title="0">{
                                        natServiceRef := clusterScope.GetNatServiceRef()
                                        clusterScope.V(4).Info("Get Nat", "Nat", natServiceRef.ResourceMap)
                                        if len(natServiceRef.ResourceMap) == 0 </span><span class="cov0" title="0">{
                                                natRouteTable = true
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if natRouteTable </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">clusterScope.V(4).Info("Create the desired routetable", "routeTableName", routeTableName)
                        routeTable, err := routeTableSvc.CreateRouteTable(netId, clusterName, routeTableName)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not create routetable for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>

                        <span class="cov8" title="1">routeTableId := routeTable.GetRouteTableId()
                        clusterScope.V(4).Info("Get routeTable", "routeTable", routeTable)
                        routeTablesRef.ResourceMap[routeTableName] = routeTableId
                        routeTableSpec.ResourceId = routeTableId
                        subnetsSpec := routeTableSpec.Subnets
                        linkRouteTableIdArray := make([]string, 0)
                        for _, subnet := range subnetsSpec </span><span class="cov8" title="1">{
                                subnetName := subnet + "-" + clusterScope.GetUID()
                                subnetId, err := getSubnetResourceId(subnetName, clusterScope)
                                if err != nil </span><span class="cov8" title="1">{
                                        return reconcile.Result{}, err
                                }</span>
                                <span class="cov8" title="1">clusterScope.V(2).Info("Link the desired routetable with subnet", "routeTableName", routeTableName)

                                linkRouteTableId, err := routeTableSvc.LinkRouteTable(routeTableId, subnetId)
                                if err != nil </span><span class="cov8" title="1">{
                                        return reconcile.Result{}, fmt.Errorf("%w Can not link routetable with net for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                                }</span>
                                <span class="cov8" title="1">linkRouteTableIdArray = append(linkRouteTableIdArray, linkRouteTableId)</span>
                        }

                        <span class="cov8" title="1">linkRouteTablesRef[routeTableName] = linkRouteTableIdArray
                        clusterScope.SetLinkRouteTablesRef(linkRouteTablesRef)
                        for _, routeSpec := range *routesSpec </span><span class="cov8" title="1">{
                                clusterScope.V(2).Info("Create route for the desired routetable", "routeTableName", routeTableName)
                                _, err = reconcileRoute(ctx, clusterScope, routeSpec, routeTableName, routeTableSvc)
                                if err != nil </span><span class="cov8" title="1">{
                                        return reconcile.Result{}, err
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteRouteTable reconcile the destruction of the RouteTable of the cluster.
func reconcileDeleteRouteTable(ctx context.Context, clusterScope *scope.ClusterScope, routeTableSvc security.OscRouteTableInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        var routeTablesSpec []*infrastructurev1beta1.OscRouteTable
        networkSpec := clusterScope.GetNetwork()

        if networkSpec.RouteTables == nil </span><span class="cov8" title="1">{
                networkSpec.SetRouteTableDefaultValue()
                routeTablesSpec = networkSpec.RouteTables
        }</span> else<span class="cov8" title="1"> {
                routeTablesSpec = clusterScope.GetRouteTables()
        }</span>
        <span class="cov8" title="1">routeTablesRef := clusterScope.GetRouteTablesRef()
        linkRouteTablesRef := clusterScope.GetLinkRouteTablesRef()

        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        netId, err := getNetResourceId(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">routeTableIds, err := routeTableSvc.GetRouteTableIdsFromNetIds(netId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">osccluster := clusterScope.OscCluster
        clusterScope.V(4).Info("Number of routeTable", "routeTable", len(routeTablesSpec))
        for _, routeTableSpec := range routeTablesSpec </span><span class="cov8" title="1">{
                routeTableName := routeTableSpec.Name + "-" + clusterScope.GetUID()
                routeTableId := routeTablesRef.ResourceMap[routeTableName]
                clusterScope.V(2).Info("Get routetable", "routeTable", routeTableName)
                if !Contains(routeTableIds, routeTableId) </span><span class="cov8" title="1">{
                        clusterScope.V(2).Info("The desired routeTable does no exist anymore", "routeTableName", routeTableName)
                        controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov8" title="1">routesSpec := clusterScope.GetRoute(routeTableSpec.Name)
                clusterScope.V(4).Info("Number of route", "routeLength", len(*routesSpec))
                for _, routeSpec := range *routesSpec </span><span class="cov8" title="1">{
                        _, err = reconcileDeleteRoute(ctx, clusterScope, routeSpec, routeTableName, routeTableSvc)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, err
                        }</span>
                }
                <span class="cov8" title="1">clusterScope.V(4).Info("Get link", "link", len(linkRouteTablesRef))

                for _, linkRouteTableId := range linkRouteTablesRef[routeTableName] </span><span class="cov8" title="1">{
                        clusterScope.V(2).Info("Unlink the desired routeTable", "routeTableName", routeTableName)
                        err = routeTableSvc.UnlinkRouteTable(linkRouteTableId)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not unlink routeTable for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                }

                <span class="cov8" title="1">clusterScope.V(2).Info("Delete the desired routeTable", "routeTableName", routeTableName)
                err = routeTableSvc.DeleteRouteTable(routeTablesRef.ResourceMap[routeTableName])
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete routeTable for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/Jeffail/gabs"
        "github.com/benbjohnson/clock"
        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        osc "github.com/outscale/osc-sdk-go/v2"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getSecurityGroupResourceId return the SecurityGroupId from the resourceMap base on SecurityGroupName (tag name + cluster object uid)
func getSecurityGroupResourceId(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        securityGroupRef := clusterScope.GetSecurityGroupsRef()
        if securityGroupId, ok := securityGroupRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return securityGroupId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// getSecurityGroupRulesResourceId return the SecurityGroupId from the resourceMap base on SecurityGroupRuleName (tag name + cluster object uid)
func getSecurityGroupRulesResourceId(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        securityGroupRuleRef := clusterScope.GetSecurityGroupRuleRef()
        if securityGroupRuleId, ok := securityGroupRuleRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return securityGroupRuleId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkSecurityGroupOscDuplicateName check that there are not the same name for securityGroup
func checkSecurityGroupOscDuplicateName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        securityGroupsSpec := clusterScope.GetSecurityGroups()
        for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                resourceNameList = append(resourceNameList, securityGroupSpec.Name)
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Check unique security group rule")
        duplicateResourceErr := alertDuplicate(resourceNameList)
        if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                return duplicateResourceErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// checkSecurityGroupRuleOscDuplicateName check that there are not the same name for securityGroupRule
func checkSecurityGroupRuleOscDuplicateName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        securityGroupsSpec := clusterScope.GetSecurityGroups()
        for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupRulesSpec := clusterScope.GetSecurityGroupRule(securityGroupSpec.Name)
                for _, securityGroupRuleSpec := range *securityGroupRulesSpec </span><span class="cov8" title="1">{
                        resourceNameList = append(resourceNameList, securityGroupRuleSpec.Name)
                }</span>
                <span class="cov8" title="1">clusterScope.V(2).Info("Check unique security group rule")
                duplicateResourceErr := alertDuplicate(resourceNameList)
                if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                        return duplicateResourceErr
                }</span> else<span class="cov8" title="1"> {
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// checkSecurityGroupFormatParameters check securityGroup parameters format (Tag format, cidr format, ..)
func checkSecurityGroupFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        var securityGroupsSpec []*infrastructurev1beta1.OscSecurityGroup
        networkSpec := clusterScope.GetNetwork()
        if networkSpec.SecurityGroups == nil </span><span class="cov8" title="1">{
                networkSpec.SetSecurityGroupDefaultValue()
                securityGroupsSpec = networkSpec.SecurityGroups
        }</span> else<span class="cov8" title="1"> {
                securityGroupsSpec = clusterScope.GetSecurityGroups()
        }</span>
        <span class="cov8" title="1">for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupName := securityGroupSpec.Name + "-" + clusterScope.GetUID()
                clusterScope.V(2).Info("Check security group parameters")
                securityGroupTagName, err := tag.ValidateTagNameValue(securityGroupName)
                if err != nil </span><span class="cov8" title="1">{
                        return securityGroupTagName, err
                }</span>
                <span class="cov8" title="1">securityGroupDescription := securityGroupSpec.Description
                _, err = infrastructurev1beta1.ValidateDescription(securityGroupDescription)
                if err != nil </span><span class="cov8" title="1">{
                        return securityGroupTagName, err
                }</span>
        }
        <span class="cov8" title="1">return "", nil</span>
}

// checkFormatParameters check every securityGroupRule parameters format (Tag format, cidr format, ..)
func checkSecurityGroupRuleFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        var securityGroupsSpec []*infrastructurev1beta1.OscSecurityGroup
        networkSpec := clusterScope.GetNetwork()
        if networkSpec.SecurityGroups == nil </span><span class="cov8" title="1">{
                networkSpec.SetSecurityGroupDefaultValue()
                securityGroupsSpec = networkSpec.SecurityGroups
        }</span> else<span class="cov8" title="1"> {
                securityGroupsSpec = clusterScope.GetSecurityGroups()
        }</span>
        <span class="cov8" title="1">for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupRulesSpec := clusterScope.GetSecurityGroupRule(securityGroupSpec.Name)
                for _, securityGroupRuleSpec := range *securityGroupRulesSpec </span><span class="cov8" title="1">{
                        securityGroupRuleName := securityGroupRuleSpec.Name + "-" + clusterScope.GetUID()
                        clusterScope.V(2).Info("Check security Group rule parameters")
                        securityGroupRuleTagName, err := tag.ValidateTagNameValue(securityGroupRuleName)
                        if err != nil </span><span class="cov8" title="1">{
                                return securityGroupRuleTagName, err
                        }</span>
                        <span class="cov8" title="1">securityGroupRuleFlow := securityGroupRuleSpec.Flow
                        _, err = infrastructurev1beta1.ValidateFlow(securityGroupRuleFlow)
                        if err != nil </span><span class="cov8" title="1">{
                                return securityGroupRuleTagName, err
                        }</span>
                        <span class="cov8" title="1">securityGroupRuleIpProtocol := securityGroupRuleSpec.IpProtocol
                        _, err = infrastructurev1beta1.ValidateIpProtocol(securityGroupRuleIpProtocol)
                        if err != nil </span><span class="cov8" title="1">{
                                return securityGroupRuleTagName, err
                        }</span>
                        <span class="cov8" title="1">securityGroupRuleIpRange := securityGroupRuleSpec.IpRange
                        _, err = infrastructurev1beta1.ValidateCidr(securityGroupRuleIpRange)
                        if err != nil </span><span class="cov8" title="1">{
                                return securityGroupRuleTagName, err
                        }</span>
                        <span class="cov8" title="1">securityGroupRuleFromPortRange := securityGroupRuleSpec.FromPortRange
                        _, err = infrastructurev1beta1.ValidatePort(securityGroupRuleFromPortRange)
                        if err != nil </span><span class="cov8" title="1">{
                                return securityGroupRuleTagName, err
                        }</span>
                        <span class="cov8" title="1">securityGroupRuleToPortRange := securityGroupRuleSpec.ToPortRange
                        _, err = infrastructurev1beta1.ValidatePort(securityGroupRuleToPortRange)
                        if err != nil </span><span class="cov8" title="1">{
                                return securityGroupRuleTagName, err
                        }</span>

                }
        }
        <span class="cov8" title="1">return "", nil</span>
}

// reconcileSecurityGroupRule reconcile the securityGroupRule of the cluster.
func reconcileSecurityGroupRule(ctx context.Context, clusterScope *scope.ClusterScope, securityGroupRuleSpec infrastructurev1beta1.OscSecurityGroupRule, securityGroupName string, securityGroupSvc security.OscSecurityGroupInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        //osccluster := clusterScope.OscCluster

        securityGroupsRef := clusterScope.GetSecurityGroupsRef()
        securityGroupRuleRef := clusterScope.GetSecurityGroupRuleRef()

        securityGroupRuleName := securityGroupRuleSpec.Name + "-" + clusterScope.GetUID()
        if len(securityGroupRuleRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                securityGroupRuleRef.ResourceMap = make(map[string]string)
        }</span>
        <span class="cov8" title="1">Flow := securityGroupRuleSpec.Flow
        IpProtocol := securityGroupRuleSpec.IpProtocol
        IpRange := securityGroupRuleSpec.IpRange
        FromPortRange := securityGroupRuleSpec.FromPortRange
        ToPortRange := securityGroupRuleSpec.ToPortRange
        associateSecurityGroupId := securityGroupsRef.ResourceMap[securityGroupName]
        clusterScope.V(4).Info("Get associateSecurityGroupId", "securityGroup", associateSecurityGroupId)
        clusterScope.V(4).Info("Check if the desired securityGroupRule exist", "securityGroupRuleName", securityGroupRuleName)
        securityGroupFromSecurityGroupRule, err := securityGroupSvc.GetSecurityGroupFromSecurityGroupRule(associateSecurityGroupId, Flow, IpProtocol, IpRange, "", FromPortRange, ToPortRange)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if securityGroupFromSecurityGroupRule == nil </span><span class="cov8" title="1">{
                clusterScope.V(4).Info("Create the desired securityGroupRule", "securityGroupRuleName", securityGroupRuleName)
                securityGroupFromSecurityGroupRule, err = securityGroupSvc.CreateSecurityGroupRule(associateSecurityGroupId, Flow, IpProtocol, IpRange, "", FromPortRange, ToPortRange)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create securityGroupRule for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>

        }
        <span class="cov8" title="1">securityGroupRuleRef.ResourceMap[securityGroupRuleName] = securityGroupFromSecurityGroupRule.GetSecurityGroupId()
        return reconcile.Result{}, nil</span>
}

// deleteSecurityGroup reconcile the deletion of securityGroup of the cluster.
func deleteSecurityGroup(ctx context.Context, clusterScope *scope.ClusterScope, securityGroupId string, securityGroupSvc security.OscSecurityGroupInterface, clock_time clock.Clock) (reconcile.Result, error) <span class="cov8" title="1">{

        currentTimeout := clock_time.Now().Add(time.Second * 600)
        var loadbalancer_delete = false
        for !loadbalancer_delete </span><span class="cov8" title="1">{
                err, httpRes := securityGroupSvc.DeleteSecurityGroup(securityGroupId)
                if err != nil </span><span class="cov8" title="1">{
                        time.Sleep(20 * time.Second)
                        buffer := new(strings.Builder)
                        _, err := io.Copy(buffer, httpRes.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return reconcile.Result{}, nil
                        }</span>
                        <span class="cov8" title="1">httpResBody := buffer.String()
                        clusterScope.V(4).Info("Find body", "httpResBody", httpResBody)
                        httpResBodyData := []byte(httpResBody)
                        httpResBodyParsed, err := gabs.ParseJSON(httpResBodyData)

                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not delete securityGroup for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">httpResCode := strings.Replace(strings.Replace(fmt.Sprintf("%v", httpResBodyParsed.Path("Errors.Code").Data()), "[", "", 1), "]", "", 1)
                        httpResType := strings.Replace(strings.Replace(fmt.Sprintf("%v", httpResBodyParsed.Path("Errors.Type").Data()), "[", "", 1), "]", "", 1)
                        var unexpectedErr bool = true

                        if httpResCode == "9085" &amp;&amp; httpResType == "ResourceConflict" </span><span class="cov8" title="1">{
                                clusterScope.V(2).Info("LoadBalancer is not deleting yet")
                                unexpectedErr = false
                        }</span>
                        <span class="cov8" title="1">if unexpectedErr </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf(" Can not delete securityGroup because of the uncatch error for Osccluster %s/%s", clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">clusterScope.V(2).Info("Wait until loadBalancer is deleting")</span>
                } else<span class="cov8" title="1"> {
                        loadbalancer_delete = true
                }</span>

                <span class="cov8" title="1">if clock_time.Now().After(currentTimeout) </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete securityGroup because to waiting loadbalancer to be delete timeout  for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>

        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileSecurityGroup reconcile the securityGroup of the cluster.
func reconcileSecurityGroup(ctx context.Context, clusterScope *scope.ClusterScope, securityGroupSvc security.OscSecurityGroupInterface, tagSvc tag.OscTagInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        securityGroupsSpec := clusterScope.GetSecurityGroups()

        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        netId, err := getNetResourceId(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">networkSpec := clusterScope.GetNetwork()
        clusterName := networkSpec.ClusterName + "-" + clusterScope.GetUID()

        clusterScope.V(4).Info("Get list of all desired securitygroup in net", "netId", netId)
        securityGroupIds, err := securityGroupSvc.GetSecurityGroupIdsFromNetIds(netId)
        clusterScope.V(4).Info("Get securityGroup Id", "securityGroup", securityGroupIds)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">securityGroupsRef := clusterScope.GetSecurityGroupsRef()
        clusterScope.V(4).Info("Number of securityGroup", "securityGroupLength", len(securityGroupsSpec))
        for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupName := securityGroupSpec.Name + "-" + clusterScope.GetUID()
                clusterScope.V(2).Info("Check if the desired securityGroup exist in net", "securityGroupName", securityGroupName)
                securityGroupDescription := securityGroupSpec.Description

                tagKey := "Name"
                tagValue := securityGroupName
                tag, err := tagSvc.ReadTag(tagKey, tagValue)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get tag for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">securityGroupTag := securityGroupSpec.Tag
                if len(securityGroupsRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                        securityGroupsRef.ResourceMap = make(map[string]string)
                }</span>

                <span class="cov8" title="1">if securityGroupSpec.ResourceId != "" </span><span class="cov8" title="1">{
                        securityGroupsRef.ResourceMap[securityGroupName] = securityGroupSpec.ResourceId
                }</span>
                <span class="cov8" title="1">_, resourceMapExist := securityGroupsRef.ResourceMap[securityGroupName]
                if resourceMapExist </span><span class="cov8" title="1">{
                        securityGroupSpec.ResourceId = securityGroupsRef.ResourceMap[securityGroupName]
                }</span>
                <span class="cov8" title="1">var securityGroup *osc.SecurityGroup
                securityGroupId := securityGroupsRef.ResourceMap[securityGroupName]

                if !Contains(securityGroupIds, securityGroupId) &amp;&amp; tag == nil </span><span class="cov8" title="1">{
                        clusterScope.V(2).Info("Create the desired securitygroup", "securityGroupName", securityGroupName)
                        if securityGroupTag == "OscK8sMainSG" </span><span class="cov8" title="1">{
                                securityGroup, err = securityGroupSvc.CreateSecurityGroup(netId, clusterName, securityGroupName, securityGroupDescription, "OscK8sMainSG")
                        }</span> else<span class="cov8" title="1"> {
                                securityGroup, err = securityGroupSvc.CreateSecurityGroup(netId, clusterName, securityGroupName, securityGroupDescription, "")
                        }</span>
                        <span class="cov8" title="1">clusterScope.V(4).Info("Get securityGroup", "securityGroup", securityGroup)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not create securityGroup for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">securityGroupsRef.ResourceMap[securityGroupName] = *securityGroup.SecurityGroupId
                        securityGroupSpec.ResourceId = *securityGroup.SecurityGroupId

                        clusterScope.V(2).Info("Check securityGroupRule")
                        securityGroupRulesSpec := clusterScope.GetSecurityGroupRule(securityGroupSpec.Name)
                        clusterScope.V(4).Info("Number of securityGroupRule", "securityGroupRuleLength", len(*securityGroupRulesSpec))
                        for _, securityGroupRuleSpec := range *securityGroupRulesSpec </span><span class="cov8" title="1">{
                                clusterScope.V(4).Info("Create securityGroupRule for the desired securityGroup", "securityGroupName", securityGroupName)
                                _, err = reconcileSecurityGroupRule(ctx, clusterScope, securityGroupRuleSpec, securityGroupName, securityGroupSvc)
                                if err != nil </span><span class="cov8" title="1">{
                                        return reconcile.Result{}, err
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// ReconcileRoute reconcile the RouteTable and the Route of the cluster.
func reconcileDeleteSecurityGroupRule(ctx context.Context, clusterScope *scope.ClusterScope, securityGroupRuleSpec infrastructurev1beta1.OscSecurityGroupRule, securityGroupName string, securityGroupSvc security.OscSecurityGroupInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster
        securityGroupsRef := clusterScope.GetSecurityGroupsRef()

        securityGroupRuleName := securityGroupRuleSpec.Name + "-" + clusterScope.GetUID()

        Flow := securityGroupRuleSpec.Flow
        IpProtocol := securityGroupRuleSpec.IpProtocol
        IpRange := securityGroupRuleSpec.IpRange
        FromPortRange := securityGroupRuleSpec.FromPortRange
        ToPortRange := securityGroupRuleSpec.ToPortRange
        associateSecurityGroupId := securityGroupsRef.ResourceMap[securityGroupName]
        clusterScope.V(4).Info("Check if the desired securityGroupRule exist", "securityGroupRuleName", securityGroupRuleName)
        securityGroupFromSecurityGroupRule, err := securityGroupSvc.GetSecurityGroupFromSecurityGroupRule(associateSecurityGroupId, Flow, IpProtocol, IpRange, "", FromPortRange, ToPortRange)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">if securityGroupFromSecurityGroupRule == nil </span><span class="cov8" title="1">{
                clusterScope.V(2).Info("The desired securityGroupRule does not exist anymore", "securityGroupRuleName", securityGroupRuleName)
                controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Delete the desired securityGroupRule", "securityGroupRuleName", securityGroupRuleName)
        err = securityGroupSvc.DeleteSecurityGroupRule(associateSecurityGroupId, Flow, IpProtocol, IpRange, "", FromPortRange, ToPortRange)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%s Can not delete securityGroupRule for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteSecurityGroup reconcile the deletetion of securityGroup of the cluster.
func reconcileDeleteSecurityGroup(ctx context.Context, clusterScope *scope.ClusterScope, securityGroupSvc security.OscSecurityGroupInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster

        var securityGroupsSpec []*infrastructurev1beta1.OscSecurityGroup
        networkSpec := clusterScope.GetNetwork()
        if networkSpec.SecurityGroups == nil </span><span class="cov8" title="1">{
                networkSpec.SetSecurityGroupDefaultValue()
                securityGroupsSpec = networkSpec.SecurityGroups
        }</span> else<span class="cov8" title="1"> {
                securityGroupsSpec = clusterScope.GetSecurityGroups()
        }</span>
        <span class="cov8" title="1">securityGroupsRef := clusterScope.GetSecurityGroupsRef()

        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        netId, err := getNetResourceId(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">securityGroupIds, err := securityGroupSvc.GetSecurityGroupIdsFromNetIds(netId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">clock_time := clock.New()
        clusterScope.V(4).Info("Number of securitGroup", "securityGroupLength", len(securityGroupsSpec))
        for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupName := securityGroupSpec.Name + "-" + clusterScope.GetUID()
                securityGroupId := securityGroupsRef.ResourceMap[securityGroupName]
                if !Contains(securityGroupIds, securityGroupId) </span><span class="cov8" title="1">{
                        clusterScope.V(2).Info("The desired securityGroup does not exist anymore", "securityGroupName", securityGroupName)
                        controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov8" title="1">securityGroupRulesSpec := clusterScope.GetSecurityGroupRule(securityGroupSpec.Name)
                clusterScope.V(4).Info("Number of securityGroupRule", "securityGroupLength", len(*securityGroupRulesSpec))
                for _, securityGroupRuleSpec := range *securityGroupRulesSpec </span><span class="cov8" title="1">{
                        _, err = reconcileDeleteSecurityGroupRule(ctx, clusterScope, securityGroupRuleSpec, securityGroupName, securityGroupSvc)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, err
                        }</span>
                }
                <span class="cov8" title="1">clusterScope.V(2).Info("Delete the desired securityGroup", "securityGroupName", securityGroupName)
                _, err := deleteSecurityGroup(ctx, clusterScope, securityGroupsRef.ResourceMap[securityGroupName], securityGroupSvc, clock_time)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete securityGroup  for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/net"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getSubnetResourceId return the subnetId from the resourceMap base on subnetName (tag name + cluster object uid)
func getSubnetResourceId(resourceName string, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        subnetRef := clusterScope.GetSubnetRef()
        if subnetId, ok := subnetRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return subnetId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkSubnetFormatParameters check Subnet parameters format (Tag format, cidr format, ..)
func checkSubnetFormatParameters(clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        var subnetsSpec []*infrastructurev1beta1.OscSubnet
        networkSpec := clusterScope.GetNetwork()
        if networkSpec.Subnets == nil </span><span class="cov8" title="1">{
                networkSpec.SetSubnetDefaultValue()
                subnetsSpec = networkSpec.Subnets
        }</span> else<span class="cov8" title="1"> {
                subnetsSpec = clusterScope.GetSubnet()
        }</span>
        <span class="cov8" title="1">networkSpec.SetSubnetSubregionNameDefaultValue()
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                clusterScope.V(2).Info("Check subnet name parameters")
                subnetTagName, err := tag.ValidateTagNameValue(subnetName)
                if err != nil </span><span class="cov8" title="1">{
                        return subnetTagName, err
                }</span>
                <span class="cov8" title="1">subnetIpRange := subnetSpec.IpSubnetRange
                clusterScope.V(2).Info("Check subnet ipsubnetrange parameters")
                _, err = infrastructurev1beta1.ValidateCidr(subnetIpRange)
                if err != nil </span><span class="cov8" title="1">{
                        return subnetTagName, err
                }</span>
                <span class="cov8" title="1">subnetSubregionName := subnetSpec.SubregionName
                clusterScope.V(2).Info("Check subnet subregion parameters")
                _, err = infrastructurev1beta1.ValidateSubregionName(subnetSubregionName)
                if err != nil </span><span class="cov0" title="0">{
                        return subnetTagName, err
                }</span>
        }
        <span class="cov8" title="1">return "", nil</span>
}

// checkSubnetOscDuplicateName check that there are not the same name for subnet
func checkSubnetOscDuplicateName(clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        subnetsSpec := clusterScope.GetSubnet()
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                resourceNameList = append(resourceNameList, subnetSpec.Name)
        }</span>
        <span class="cov8" title="1">clusterScope.V(2).Info("Check unique subnet")
        duplicateResourceErr := alertDuplicate(resourceNameList)
        if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                return duplicateResourceErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// reconcileSubnet reconcile the subnet of the cluster.
func reconcileSubnet(ctx context.Context, clusterScope *scope.ClusterScope, subnetSvc net.OscSubnetInterface, tagSvc tag.OscTagInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()
        netId, err := getNetResourceId(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">var subnetsSpec []*infrastructurev1beta1.OscSubnet
        subnetsSpec = clusterScope.GetSubnet()

        subnetRef := clusterScope.GetSubnetRef()
        networkSpec := clusterScope.GetNetwork()
        clusterName := networkSpec.ClusterName + "-" + clusterScope.GetUID()
        var subnetIds []string
        clusterScope.V(2).Info("Check if the desired subnet exist")
        subnetIds, err = subnetSvc.GetSubnetIdsFromNetIds(netId)
        clusterScope.V(4).Info("Get subnetIds", "subnetIds", subnetIds)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">clusterScope.V(4).Info("Number of subnet", "subnet_length", len(subnetsSpec))
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                tagKey := "Name"
                tagValue := subnetName
                tag, err := tagSvc.ReadTag(tagKey, tagValue)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get tag for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
                <span class="cov8" title="1">subnetId := subnetSpec.ResourceId
                clusterScope.V(4).Info("Get subnetId", "subnetId", subnetId)
                if len(subnetRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                        subnetRef.ResourceMap = make(map[string]string)
                }</span>
                <span class="cov8" title="1">if subnetSpec.ResourceId != "" </span><span class="cov8" title="1">{
                        subnetRef.ResourceMap[subnetName] = subnetSpec.ResourceId
                }</span>
                <span class="cov8" title="1">_, resourceMapExist := subnetRef.ResourceMap[subnetName]
                if resourceMapExist </span><span class="cov8" title="1">{
                        subnetSpec.ResourceId = subnetRef.ResourceMap[subnetName]
                }</span>
                <span class="cov8" title="1">if !Contains(subnetIds, subnetId) &amp;&amp; tag == nil </span><span class="cov8" title="1">{
                        clusterScope.V(2).Info("Create the desired subnet", "subnetName", subnetName)
                        subnet, err := subnetSvc.CreateSubnet(subnetSpec, netId, clusterName, subnetName)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not create subnet for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">subnetRef.ResourceMap[subnetName] = subnet.GetSubnetId()
                        subnetSpec.ResourceId = subnet.GetSubnetId()</span>
                }
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteSubnet reconcile the destruction of the Subnet of the cluster.
func reconcileDeleteSubnet(ctx context.Context, clusterScope *scope.ClusterScope, subnetSvc net.OscSubnetInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        osccluster := clusterScope.OscCluster
        subnetsSpec := clusterScope.GetSubnet()
        netSpec := clusterScope.GetNet()
        netSpec.SetDefaultValue()
        netName := netSpec.Name + "-" + clusterScope.GetUID()

        networkSpec := clusterScope.GetNetwork()
        if networkSpec.Subnets == nil </span><span class="cov8" title="1">{
                networkSpec.SetSubnetDefaultValue()
                subnetsSpec = networkSpec.Subnets
        }</span> else<span class="cov8" title="1"> {
                subnetsSpec = clusterScope.GetSubnet()
        }</span>
        <span class="cov8" title="1">netId, err := getNetResourceId(netName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">subnetIds, err := subnetSvc.GetSubnetIdsFromNetIds(netId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">clusterScope.V(4).Info("Number of subnet", "subnet_length", len(subnetsSpec))
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetId := subnetSpec.ResourceId
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                if !Contains(subnetIds, subnetId) </span><span class="cov8" title="1">{
                        clusterScope.V(2).Info("the desired subnet does not exist anymore", "subnetName", subnetName)
                        controllerutil.RemoveFinalizer(osccluster, "oscclusters.infrastructure.cluster.x-k8s.io")
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov8" title="1">err = subnetSvc.DeleteSubnet(subnetId)
                if err != nil </span><span class="cov8" title="1">{
                        clusterScope.V(2).Info("Delete te desired subnet", "subnetName", subnetName)
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete subnet for Osccluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                }</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/compute"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/service"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/storage"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/util/reconciler"
        "github.com/pkg/errors"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/client-go/tools/record"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        capierrors "sigs.k8s.io/cluster-api/errors"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/conditions"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/source"

        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// OscMachineReconciler reconciles a OscMachine object
type OscMachineReconciler struct {
        client.Client
        Recorder         record.EventRecorder
        ReconcileTimeout time.Duration
}

//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=oscmachines,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=oscmachines/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=oscmachines/finalizers,verbs=update
//+kubebuilder:rbac:groups=cluster.x-k8s.io,resources=machines,verbs=get;list;watch
//+kubebuilder:rbac:groups=cluster.x-k8s.io,resources=machines/status,verbs=get;list;watch

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the OscMachine object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.11.0/pkg/reconcile

// getVolumeSvc retrieve volumeSvc
func (r *OscMachineReconciler) getVolumeSvc(ctx context.Context, scope scope.ClusterScope) storage.OscVolumeInterface <span class="cov0" title="0">{
        return storage.NewService(ctx, &amp;scope)
}</span>

// getVmSvc retrieve vmSvc
func (r *OscMachineReconciler) getVmSvc(ctx context.Context, scope scope.ClusterScope) compute.OscVmInterface <span class="cov0" title="0">{
        return compute.NewService(ctx, &amp;scope)
}</span>

// getImageSvc retrieve imageSvc
func (r *OscMachineReconciler) getImageSvc(ctx context.Context, scope scope.ClusterScope) compute.OscImageInterface <span class="cov0" title="0">{
        return compute.NewService(ctx, &amp;scope)
}</span>

// getPublicIpSvc retrieve publicIpSvc
func (r *OscMachineReconciler) getPublicIpSvc(ctx context.Context, scope scope.ClusterScope) security.OscPublicIpInterface <span class="cov0" title="0">{
        return security.NewService(ctx, &amp;scope)
}</span>

// getSecurityGroupSvc retrieve securityGroupSvc
func (r *OscMachineReconciler) getSecurityGroupSvc(ctx context.Context, scope scope.ClusterScope) security.OscSecurityGroupInterface <span class="cov0" title="0">{
        return security.NewService(ctx, &amp;scope)
}</span>

// getLoadBalancerSvc retrieve loadBalancerSvc
func (r *OscMachineReconciler) getLoadBalancerSvc(ctx context.Context, scope scope.ClusterScope) service.OscLoadBalancerInterface <span class="cov0" title="0">{
        return service.NewService(ctx, &amp;scope)
}</span>

// getKeyPairSvc retrieve keypairSvc
func (r *OscMachineReconciler) getKeyPairSvc(ctx context.Context, scope scope.ClusterScope) security.OscKeyPairInterface <span class="cov0" title="0">{
        return security.NewService(ctx, &amp;scope)
}</span>

// getTagSvc retrieve tagSvc
func (r *OscMachineReconciler) getTagSvc(ctx context.Context, scope scope.ClusterScope) tag.OscTagInterface <span class="cov0" title="0">{
        return tag.NewService(ctx, &amp;scope)
}</span>
func (r *OscMachineReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov0" title="0">{
        _ = log.FromContext(ctx)
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(r.ReconcileTimeout))
        defer cancel()

        log := ctrl.LoggerFrom(ctx)

        oscMachine := &amp;infrastructurev1beta1.OscMachine{}
        if err := r.Get(ctx, req.NamespacedName, oscMachine); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }
        <span class="cov0" title="0">machine, err := util.GetOwnerMachine(ctx, r.Client, oscMachine.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov0" title="0">if machine == nil </span><span class="cov0" title="0">{
                log.Info("Machine Controller has not yet set OwnRef")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">cluster, err := util.GetClusterFromMetadata(ctx, r.Client, machine.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                log.Info("Machine is missing cluster label or cluster does not exist")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">log = log.WithValues("machine", machine.Name)
        oscCluster := &amp;infrastructurev1beta1.OscCluster{}
        oscClusterNamespacedName := client.ObjectKey{
                Namespace: oscMachine.Namespace,
                Name:      cluster.Spec.InfrastructureRef.Name,
        }

        if err := r.Get(ctx, oscClusterNamespacedName, oscCluster); err != nil </span><span class="cov0" title="0">{
                log.Info("OscCluster is not available yet")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov0" title="0">if annotations.IsPaused(cluster, oscCluster) </span><span class="cov0" title="0">{
                log.Info("OscMachine or linked Cluster is marked as paused. Won't reconcile")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">clusterScope, err := scope.NewClusterScope(scope.ClusterScopeParams{
                Client:     r.Client,
                Logger:     log,
                Cluster:    cluster,
                OscCluster: oscCluster,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov0" title="0">machineScope, err := scope.NewMachineScope(scope.MachineScopeParams{
                Logger:     log,
                Client:     r.Client,
                Cluster:    cluster,
                Machine:    machine,
                OscCluster: oscCluster,
                OscMachine: oscMachine,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Errorf("failed to create scope: %+v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := machineScope.Close(); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()
        <span class="cov0" title="0">if !oscMachine.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return r.reconcileDelete(ctx, machineScope, clusterScope)
        }</span>
        <span class="cov0" title="0">return r.reconcile(ctx, machineScope, clusterScope)</span>
}

// reconcile reconcile the creation of the machine
func (r *OscMachineReconciler) reconcile(ctx context.Context, machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov0" title="0">{
        machineScope.V(2).Info("Reconciling OscMachine")
        oscmachine := machineScope.OscMachine
        if oscmachine.Status.FailureReason != nil || oscmachine.Status.FailureMessage != nil </span><span class="cov0" title="0">{
                machineScope.V(2).Info("Error state detected, skipping reconciliation")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">controllerutil.AddFinalizer(oscmachine, "oscmachine.infrastructure.cluster.x-k8s.io")

        machineScope.V(2).Info("Set OscMachine status to not ready")
        machineScope.SetNotReady()
        if !machineScope.Cluster.Status.InfrastructureReady </span><span class="cov0" title="0">{
                machineScope.V(2).Info("Cluster infrastructure is not ready yet")
                conditions.MarkFalse(oscmachine, infrastructurev1beta1.VmReadyCondition, infrastructurev1beta1.WaitingForClusterInfrastructureReason, clusterv1.ConditionSeverityInfo, "")
                return ctrl.Result{}, nil
        }</span>
        <span class="cov0" title="0">machineScope.V(2).Info("Check bootstrap data")
        if machineScope.Machine.Spec.Bootstrap.DataSecretName == nil </span><span class="cov0" title="0">{
                machineScope.V(2).Info("Bootstrap data secret reference is not yet availablle")
                return ctrl.Result{}, nil
        }</span>
        <span class="cov0" title="0">if len(machineScope.OscMachine.Spec.Node.Volumes) &gt; 0 </span><span class="cov0" title="0">{
                machineScope.V(2).Info("Find volumes")
                volumeName, err := checkVolumeFormatParameters(machineScope)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create volume %s for OscMachine %s/%s", err, volumeName, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
        }

        <span class="cov0" title="0">vmName, err := checkVmFormatParameters(machineScope, clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create vm %s for OscMachine %s/%s", err, vmName, machineScope.GetNamespace(), machineScope.GetName())
        }</span>

        <span class="cov0" title="0">keypairName, err := checkKeypairFormatParameters(machineScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, fmt.Errorf("%w Can not create vm %s for OscMachine %s/%s", err, keypairName, machineScope.GetNamespace(), machineScope.GetName())
        }</span>

        <span class="cov0" title="0">if len(machineScope.OscMachine.Spec.Node.Volumes) &gt; 0 </span><span class="cov0" title="0">{
                machineScope.V(2).Info("Find Volumes")
                duplicateResourceVolumeErr := checkVolumeOscDuplicateName(machineScope)
                if duplicateResourceVolumeErr != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, duplicateResourceVolumeErr
                }</span>
        }

        <span class="cov0" title="0">duplicateResourceVmPrivateIpErr := checkVmPrivateIpOscDuplicateName(machineScope)
        if duplicateResourceVmPrivateIpErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, duplicateResourceVmPrivateIpErr
        }</span>
        <span class="cov0" title="0">if len(machineScope.OscMachine.Spec.Node.Volumes) &gt; 0 </span><span class="cov0" title="0">{
                machineScope.V(2).Info("Find volumes")
                checkOscAssociateVmVolumeErr := checkVmVolumeOscAssociateResourceName(machineScope)
                if checkOscAssociateVmVolumeErr != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, checkOscAssociateVmVolumeErr
                }</span>
        }

        <span class="cov0" title="0">checkOscAssociateVmSecurityGroupErr := checkVmSecurityGroupOscAssociateResourceName(machineScope, clusterScope)
        if checkOscAssociateVmSecurityGroupErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociateVmSecurityGroupErr
        }</span>

        <span class="cov0" title="0">checkOscAssociateVmSubnetErr := checkVmSubnetOscAssociateResourceName(machineScope, clusterScope)
        if checkOscAssociateVmSubnetErr != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, checkOscAssociateVmSubnetErr
        }</span>

        <span class="cov0" title="0">vmSpec := machineScope.GetVm()
        vmSpec.SetDefaultValue()
        if vmSpec.PublicIpName != "" </span><span class="cov0" title="0">{
                checkOscAssociateVmPublicIpErr := checkVmPublicIpOscAssociateResourceName(machineScope, clusterScope)
                if checkOscAssociateVmPublicIpErr != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, checkOscAssociateVmPublicIpErr
                }</span>
        }

        <span class="cov0" title="0">if vmSpec.LoadBalancerName != "" </span><span class="cov0" title="0">{
                checkOscAssociateVmLoadBalancerErr := checkVmLoadBalancerOscAssociateResourceName(machineScope, clusterScope)
                if checkOscAssociateVmLoadBalancerErr != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, checkOscAssociateVmLoadBalancerErr
                }</span>
        }
        <span class="cov0" title="0">if len(machineScope.OscMachine.Spec.Node.Volumes) &gt; 0 </span><span class="cov0" title="0">{

                checkVmVolumeSubregionNameErr := checkVmVolumeSubregionName(machineScope)
                if checkVmVolumeSubregionNameErr != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, checkVmVolumeSubregionNameErr
                }</span>
        }

        <span class="cov0" title="0">imageSvc := r.getImageSvc(ctx, *clusterScope)
        reconcileImage, err := reconcileImage(ctx, machineScope, imageSvc)
        if err != nil </span><span class="cov0" title="0">{
                machineScope.Error(err, "failed to reconcile Image")
                return reconcileImage, err
        }</span>

        <span class="cov0" title="0">volumeSvc := r.getVolumeSvc(ctx, *clusterScope)
        tagSvc := r.getTagSvc(ctx, *clusterScope)
        if len(machineScope.OscMachine.Spec.Node.Volumes) &gt; 0 </span><span class="cov0" title="0">{
                machineScope.V(2).Info("Find Volumes")
                reconcileVolume, err := reconcileVolume(ctx, machineScope, volumeSvc, tagSvc)
                if err != nil </span><span class="cov0" title="0">{
                        machineScope.Error(err, "failed to reconcile volume")
                        conditions.MarkFalse(oscmachine, infrastructurev1beta1.VolumeReadyCondition, infrastructurev1beta1.VolumeReconciliationFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                        return reconcileVolume, err
                }</span>
        }

        <span class="cov0" title="0">keypairSvc := r.getKeyPairSvc(ctx, *clusterScope)
        reconcileKeypair, err := reconcileKeypair(ctx, machineScope, keypairSvc)
        if err != nil </span><span class="cov0" title="0">{
                machineScope.Error(err, "failed to reconcile keypair")
                return reconcileKeypair, err
        }</span>

        <span class="cov0" title="0">publicIpSvc := r.getPublicIpSvc(ctx, *clusterScope)
        vmSvc := r.getVmSvc(ctx, *clusterScope)
        loadBalancerSvc := r.getLoadBalancerSvc(ctx, *clusterScope)
        securityGroupSvc := r.getSecurityGroupSvc(ctx, *clusterScope)
        reconcileVm, err := reconcileVm(ctx, clusterScope, machineScope, vmSvc, volumeSvc, publicIpSvc, loadBalancerSvc, securityGroupSvc, tagSvc)
        if err != nil </span><span class="cov0" title="0">{
                machineScope.Error(err, "failed to reconcile vm")
                conditions.MarkFalse(oscmachine, infrastructurev1beta1.VmReadyCondition, infrastructurev1beta1.VmNotReadyReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcileVm, err
        }</span>
        <span class="cov0" title="0">conditions.MarkTrue(oscmachine, infrastructurev1beta1.VolumeReadyCondition)

        vmState := machineScope.GetVmState()

        switch *vmState </span>{
        case infrastructurev1beta1.VmStatePending:<span class="cov0" title="0">
                machineScope.SetNotReady()
                machineScope.V(4).Info("Vm pending", "state", vmState)
                conditions.MarkFalse(oscmachine, infrastructurev1beta1.VmReadyCondition, infrastructurev1beta1.VmNotReadyReason, clusterv1.ConditionSeverityWarning, "")</span>
        case infrastructurev1beta1.VmStateStopping, infrastructurev1beta1.VmStateStopped:<span class="cov0" title="0">
                machineScope.SetNotReady()
                machineScope.V(4).Info("Vm stopped", "state", vmState)
                conditions.MarkFalse(oscmachine, infrastructurev1beta1.VmReadyCondition, infrastructurev1beta1.VmStoppedReason, clusterv1.ConditionSeverityWarning, "")</span>
        case infrastructurev1beta1.VmStateRunning:<span class="cov0" title="0">
                machineScope.SetReady()
                machineScope.V(4).Info("Vm running", "state", vmState)
                conditions.MarkTrue(oscmachine, infrastructurev1beta1.VmReadyCondition)</span>
        case infrastructurev1beta1.VmStateShuttingDown, infrastructurev1beta1.VmStateTerminated:<span class="cov0" title="0">
                machineScope.SetNotReady()
                machineScope.V(4).Info("Unexpected vm termination", "state", vmState)
                conditions.MarkFalse(oscmachine, infrastructurev1beta1.VmReadyCondition, infrastructurev1beta1.VmTerminatedReason, clusterv1.ConditionSeverityError, "")</span>
        default:<span class="cov0" title="0">
                machineScope.SetNotReady()
                machineScope.V(4).Info("Vm state is undefined", "state", vmState)
                machineScope.SetFailureReason(capierrors.UpdateMachineError)
                machineScope.SetFailureMessage(errors.Errorf("instance state %+v  is undefined", vmState))
                conditions.MarkUnknown(oscmachine, infrastructurev1beta1.VmReadyCondition, "", "")</span>
        }
        <span class="cov0" title="0">return reconcile.Result{}, nil</span>
}

// reconcileDelete reconcile the deletion of the machine
func (r *OscMachineReconciler) reconcileDelete(ctx context.Context, machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov0" title="0">{
        machineScope.V(2).Info("Reconciling delete OscMachine")
        oscmachine := machineScope.OscMachine
        if len(machineScope.OscMachine.Spec.Node.Volumes) &gt; 0 </span><span class="cov0" title="0">{
                machineScope.V(2).Info("Find volumes")
                volumeSvc := r.getVolumeSvc(ctx, *clusterScope)
                reconcileDeleteVolume, err := reconcileDeleteVolume(ctx, machineScope, volumeSvc)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcileDeleteVolume, err
                }</span>
        }
        <span class="cov0" title="0">publicIpSvc := r.getPublicIpSvc(ctx, *clusterScope)
        vmSvc := r.getVmSvc(ctx, *clusterScope)
        loadBalancerSvc := r.getLoadBalancerSvc(ctx, *clusterScope)
        securityGroupSvc := r.getSecurityGroupSvc(ctx, *clusterScope)
        reconcileDeleteVm, err := reconcileDeleteVm(ctx, clusterScope, machineScope, vmSvc, publicIpSvc, loadBalancerSvc, securityGroupSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteVm, err
        }</span>
        <span class="cov0" title="0">keypairSvc := r.getKeyPairSvc(ctx, *clusterScope)
        reconcileDeleteKeyPair, err := reconcileDeleteKeypair(ctx, machineScope, keypairSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileDeleteKeyPair, err
        }</span>
        <span class="cov0" title="0">controllerutil.RemoveFinalizer(oscmachine, "oscmachine.infrastructure.cluster.x-k8s.io")
        return reconcile.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *OscMachineReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        clusterToObjectFunc, err := util.ClusterToObjectsMapper(r.Client, &amp;infrastructurev1beta1.OscMachineList{}, mgr.GetScheme())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Errorf("failed to create mapper for Cluster to OscMachines: %+v", err)
        }</span>
        <span class="cov0" title="0">err = ctrl.NewControllerManagedBy(mgr).
                For(&amp;infrastructurev1beta1.OscMachine{}).
                Watches(
                        &amp;source.Kind{Type: &amp;clusterv1.Machine{}},
                        handler.EnqueueRequestsFromMapFunc(util.MachineToInfrastructureMapFunc(infrastructurev1beta1.GroupVersion.WithKind("OscMachine"))),
                ).
                Watches(
                        &amp;source.Kind{Type: &amp;infrastructurev1beta1.OscCluster{}},
                        handler.EnqueueRequestsFromMapFunc(r.OscClusterToOscMachines(ctx)),
                ).
                Watches(
                        &amp;source.Kind{Type: &amp;clusterv1.Cluster{}},
                        handler.EnqueueRequestsFromMapFunc(clusterToObjectFunc),
                        builder.WithPredicates(predicates.ClusterUnpausedAndInfrastructureReady(ctrl.LoggerFrom(ctx))),
                ).
                Complete(r)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Errorf("error creating controller: %+v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OscClusterToOscMachines convert the cluster to machine spec
func (r *OscMachineReconciler) OscClusterToOscMachines(ctx context.Context) handler.MapFunc <span class="cov0" title="0">{
        return func(o client.Object) []ctrl.Request </span><span class="cov0" title="0">{
                result := []ctrl.Request{}
                log := log.FromContext(ctx)

                c, ok := o.(*infrastructurev1beta1.OscCluster)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(fmt.Errorf("expected a OscCluster but got a %T", o), "failed to get OscMachine for OscCluster")
                        return nil
                }</span>
                <span class="cov0" title="0">log = log.WithValues("objectMapper", "oscClusterToOscMachine", "namespace", c.Namespace, "oscCluster", c.Name)

                if !c.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        log.V(1).Info("OscCluster has a deletion timestamp, skipping mapping.")
                        return nil
                }</span>

                <span class="cov0" title="0">cluster, err := util.GetOwnerCluster(ctx, r.Client, c.ObjectMeta)
                switch </span>{
                case apierrors.IsNotFound(err) || cluster == nil:<span class="cov0" title="0">
                        log.V(1).Info("Cluster for OscCluster not found, skipping mapping.")
                        return result</span>
                case err != nil:<span class="cov0" title="0">
                        log.Error(err, "failed to get owning cluster, skipping mapping.")
                        return result</span>
                }

                <span class="cov0" title="0">labels := map[string]string{"cluster.x-k8s.io/cluster-name": cluster.Name}
                machineList := &amp;clusterv1.MachineList{}
                if err := r.List(ctx, machineList, client.InNamespace(c.Namespace), client.MatchingLabels(labels)); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to list Machines, skipping mapping.")
                        return nil
                }</span>
                <span class="cov0" title="0">for _, m := range machineList.Items </span><span class="cov0" title="0">{
                        log.WithValues("machine", m.Name)
                        if m.Spec.InfrastructureRef.GroupVersionKind().Kind != "OscMachine" </span><span class="cov0" title="0">{
                                log.V(1).Info("Machine has an InfrastructureRef for a different type, will not add to reconcilation request.")
                                continue</span>
                        }
                        <span class="cov0" title="0">if m.Spec.InfrastructureRef.Name == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">name := client.ObjectKey{Namespace: m.Namespace, Name: m.Spec.InfrastructureRef.Name}
                        log.WithValues("oscMachine", name.Name)
                        log.V(1).Info("Adding OscMachine to reconciliation request.")
                        result = append(result, ctrl.Request{NamespacedName: name})</span>
                }
                <span class="cov0" title="0">return result</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/compute"
        osc "github.com/outscale/osc-sdk-go/v2"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "time"
)

// checkImageFormatParameters check keypair format
func checkImageFormatParameters(machineScope *scope.MachineScope) (string, error) <span class="cov8" title="1">{
        var err error
        var imageSpec *infrastructurev1beta1.OscImage
        nodeSpec := machineScope.GetNode()
        if nodeSpec.Image.Name == "" </span><span class="cov8" title="1">{
                return "", nil
        }</span> else<span class="cov8" title="1"> {
                imageSpec = machineScope.GetImage()
        }</span>
        <span class="cov8" title="1">imageName := imageSpec.Name
        machineScope.V(2).Info("Check Image parameters")
        imageName, err = infrastructurev1beta1.ValidateImageName(imageName)
        if err != nil </span><span class="cov8" title="1">{
                return imageName, err
        }</span>
        <span class="cov8" title="1">return "", nil</span>
}

// getImageResourceId return the iamgeName from the resourceMap base on resourceName (tag name + cluster uid)
func getImageResourceId(resourceName string, machineScope *scope.MachineScope) (string, error) <span class="cov8" title="1">{
        imageRef := machineScope.GetImageRef()
        if imageId, ok := imageRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return imageId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// reconcileImage reconcile the image of the machine
func reconcileImage(ctx context.Context, machineScope *scope.MachineScope, imageSvc compute.OscImageInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        var imageSpec *infrastructurev1beta1.OscImage
        imageSpec = machineScope.GetImage()
        imageRef := machineScope.GetImageRef()
        imageName := imageSpec.Name
        imageId := machineScope.GetImageId()
        var image *osc.Image
        var err error

        if len(imageRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                imageRef.ResourceMap = make(map[string]string)
        }</span>

        <span class="cov8" title="1">if imageName != "" </span><span class="cov8" title="1">{
                machineScope.V(2).Info("Image Name exist", "imageName", imageName)
                if imageId, err = imageSvc.GetImageId(imageName); err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        } else<span class="cov8" title="1"> {
                machineScope.V(4).Info("Image Name is empty and we will try to get it from Id", "imageId", imageId)
                if imageName, err = imageSvc.GetImageName(imageId); err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        }
        <span class="cov8" title="1">if image, err = imageSvc.GetImage(imageId); err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if imageSpec.ResourceId != "" </span><span class="cov8" title="1">{
                imageRef.ResourceMap[imageName] = imageSpec.ResourceId
        }</span> else<span class="cov8" title="1"> {
                machineScope.SetImageId(imageId)
                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil

        }</span>
        <span class="cov8" title="1">if image == nil </span><span class="cov8" title="1">{
                machineScope.V(2).Info("Image is nil")
                return reconcile.Result{}, err
        }</span> else<span class="cov8" title="1"> {
                imageRef.ResourceMap[imageName] = imageId
        }</span>
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        osc "github.com/outscale/osc-sdk-go/v2"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// checkKeypairFormatParameters check keypair format
func checkKeypairFormatParameters(machineScope *scope.MachineScope) (string, error) <span class="cov8" title="1">{
        var keypairSpec *infrastructurev1beta1.OscKeypair
        nodeSpec := machineScope.GetNode()
        if nodeSpec.KeyPair.Name == "" </span><span class="cov8" title="1">{
                nodeSpec.SetKeyPairDefaultValue()
                keypairSpec = &amp;nodeSpec.KeyPair
        }</span> else<span class="cov8" title="1"> {
                keypairSpec = machineScope.GetKeypair()
        }</span>

        <span class="cov8" title="1">keypairName := keypairSpec.Name
        machineScope.V(2).Info("Check Keypair parameters")
        keypairTagName, err := tag.ValidateTagNameValue(keypairName)
        if err != nil </span><span class="cov8" title="1">{
                return keypairTagName, err
        }</span>

        <span class="cov8" title="1">return "", nil</span>
}

// getKeyPairResourceId return the keypairName from the resourceMap base on resourceName (tag name + cluster uid)
func getKeyPairResourceId(resourceName string, machineScope *scope.MachineScope) (string, error) <span class="cov8" title="1">{
        keypairRef := machineScope.GetKeypairRef()
        if keypairName, ok := keypairRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return keypairName, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// reconcileKeypair reconcile the keypair of the machine
func reconcileKeypair(ctx context.Context, machineScope *scope.MachineScope, keypairSvc security.OscKeyPairInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        var keypairSpec *infrastructurev1beta1.OscKeypair
        keypairSpec = machineScope.GetKeypair()
        keypairRef := machineScope.GetKeypairRef()
        keypairName := keypairSpec.Name
        machineScope.V(2).Info("Get Keypair if existing", "keypair", keypairName)
        var keypair *osc.Keypair
        var err error

        if len(keypairRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                keypairRef.ResourceMap = make(map[string]string)
        }</span>
        <span class="cov8" title="1">keypairRef.ResourceMap[keypairName] = keypairName

        if keypair, err = keypairSvc.GetKeyPair(keypairName); err != nil </span><span class="cov8" title="1">{
                machineScope.V(2).Info("Fail to get keypair", "keypair", keypairName)
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if keypair == nil </span><span class="cov8" title="1">{
                machineScope.V(2).Info("Keypair will be created", "keypair", keypairName)
                _, err := keypairSvc.CreateKeyPair(keypairName)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        } else<span class="cov8" title="1"> if keypairSpec.ResourceId == "" </span><span class="cov8" title="1">{
                machineScope.V(4).Info("Keypair Ressource id is empty", "keypair", keypairName)
                keypairRef.ResourceMap[keypairName] = keypairName
        }</span>
        <span class="cov8" title="1">machineScope.V(2).Info("Get Keypair after reconcile keypair", "keypair", keypairName)
        return reconcile.Result{}, nil</span>
}

// reconcileDeleteKeypair reconcile the destruction of the keypair of the machine
func reconcileDeleteKeypair(ctx context.Context, machineScope *scope.MachineScope, keypairSvc security.OscKeyPairInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        oscmachine := machineScope.OscMachine
        keypairSpec := machineScope.GetKeypair()
        keypairName := keypairSpec.Name

        keypair, err := keypairSvc.GetKeyPair(keypairName)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if keypair == nil </span><span class="cov8" title="1">{
                controllerutil.RemoveFinalizer(oscmachine, "")
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">deleteKeypair := machineScope.GetDeleteKeypair()
        if deleteKeypair </span><span class="cov8" title="1">{
                machineScope.V(2).Info("Remove keypair")
                err = keypairSvc.DeleteKeyPair(keypairName)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("Can not delete keypair for OscCluster %s/%s", machineScope.GetNamespace(), machineScope.GetName())
                }</span>
        } else<span class="cov8" title="1"> {
                machineScope.V(2).Info("Keep keypair")
        }</span>

        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "strings"
        "time"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/compute"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/security"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/service"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/storage"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        osc "github.com/outscale/osc-sdk-go/v2"
        corev1 "k8s.io/api/core/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getVmResourceId return the vmId from the resourceMap base on resourceName (tag name + cluster uid)
func getVmResourceId(resourceName string, machineScope *scope.MachineScope) (string, error) <span class="cov8" title="1">{
        vmRef := machineScope.GetVmRef()
        if vmId, ok := vmRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return vmId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkVmVolumeOscAssociateResourceName check that Volume dependancies tag name in both resource configuration are the same.
func checkVmVolumeOscAssociateResourceName(machineScope *scope.MachineScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        vmSpec := machineScope.GetVm()
        vmSpec.SetDefaultValue()
        vmVolumeName := vmSpec.VolumeName + "-" + machineScope.GetUID()
        volumesSpec := machineScope.GetVolume()
        for _, volumeSpec := range volumesSpec </span><span class="cov8" title="1">{
                volumeName := volumeSpec.Name + "-" + machineScope.GetUID()
                resourceNameList = append(resourceNameList, volumeName)
        }</span>
        <span class="cov8" title="1">machineScope.V(2).Info("Check match volume with vm")
        checkOscAssociate := Contains(resourceNameList, vmVolumeName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s volume does not exist in vm", vmVolumeName)
        }</span>
}

// checkVmLoadBalancerOscAssociateResourceName  check that LoadBalancer dependancies tag name in both resource configuration are the same.
func checkVmLoadBalancerOscAssociateResourceName(machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        vmSpec := machineScope.GetVm()
        vmSpec.SetDefaultValue()
        vmLoadBalancerName := vmSpec.LoadBalancerName + "-" + clusterScope.GetUID()
        machineScope.V(4).Info("Get VmLoadBalancerName", "vmLoadBalancerName", vmLoadBalancerName)
        loadBalancerSpec := clusterScope.GetLoadBalancer()
        loadBalancerName := loadBalancerSpec.LoadBalancerName + "-" + clusterScope.GetUID()
        machineScope.V(4).Info("Get LoadBalancerName", "loadBalancerName", loadBalancerName)
        machineScope.V(4).Info("Get Role", "Role", vmSpec.Role)
        resourceNameList = append(resourceNameList, loadBalancerName)
        checkOscAssociate := Contains(resourceNameList, vmLoadBalancerName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s loadBalancer does not exist in vm", vmLoadBalancerName)
        }</span>

}

func checkVmVolumeSubregionName(machineScope *scope.MachineScope) error <span class="cov8" title="1">{
        vmSpec := machineScope.GetVm()
        vmSpec.SetDefaultValue()
        vmVolumeName := vmSpec.VolumeName
        volumeSubregionName := machineScope.GetVolumeSubregionName(vmVolumeName)
        vmSubregionName := vmSpec.SubregionName
        vmName := vmSpec.Name
        machineScope.V(2).Info("Check have the same subregionName for vm and for volume")
        if vmSubregionName != volumeSubregionName </span><span class="cov8" title="1">{
                return fmt.Errorf("volume %s and vm %s are not in the same subregion %s", vmVolumeName, vmName, vmSubregionName)
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// checkVmSecurityGroupOscAssociateResourceName check that SecurityGroup dependancies tag name in both resource configuration are the same.
func checkVmSecurityGroupOscAssociateResourceName(machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        var vmSecurityGroupNameList []string
        var checkOscAssociate bool
        vmSpec := machineScope.GetVm()
        vmSpec.SetDefaultValue()
        vmSecurityGroups := machineScope.GetVmSecurityGroups()
        for _, vmSecurityGroup := range *vmSecurityGroups </span><span class="cov8" title="1">{
                vmSecurityGroupName := vmSecurityGroup.Name + "-" + clusterScope.GetUID()
                vmSecurityGroupNameList = append(vmSecurityGroupNameList, vmSecurityGroupName)
        }</span>
        <span class="cov8" title="1">securityGroupsSpec := clusterScope.GetSecurityGroups()
        for _, securityGroupSpec := range securityGroupsSpec </span><span class="cov8" title="1">{
                securityGroupName := securityGroupSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, securityGroupName)
        }</span>
        <span class="cov8" title="1">for _, validateVmSecurityGroupName := range vmSecurityGroupNameList </span><span class="cov8" title="1">{
                machineScope.V(2).Info("Check match securityGroup with vm")
                checkOscAssociate = Contains(resourceNameList, validateVmSecurityGroupName)
                if !checkOscAssociate </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s securityGroup does not exist in vm", validateVmSecurityGroupName)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// checkVmSubnetOscAssociateResourceName check that Subnet dependencies tag name in both resource configuration are the same.
func checkVmSubnetOscAssociateResourceName(machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        vmSpec := machineScope.GetVm()
        vmSpec.SetDefaultValue()
        vmSubnetName := vmSpec.SubnetName + "-" + clusterScope.GetUID()
        subnetsSpec := clusterScope.GetSubnet()
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, subnetName)
        }</span>
        <span class="cov8" title="1">machineScope.V(2).Info("Check match subnet with vm")
        checkOscAssociate := Contains(resourceNameList, vmSubnetName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s subnet does not exist in vm", vmSubnetName)
        }</span>
}

// checkVmPublicIpOscAssociateResourceName check that PublicIp dependancies tag name in both resource configuration are the same.
func checkVmPublicIpOscAssociateResourceName(machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        vmSpec := machineScope.GetVm()
        vmSpec.SetDefaultValue()
        vmPublicIpName := vmSpec.PublicIpName + "-" + clusterScope.GetUID()
        publicIpsSpec := clusterScope.GetPublicIp()
        for _, publicIpSpec := range publicIpsSpec </span><span class="cov8" title="1">{
                publicIpName := publicIpSpec.Name + "-" + clusterScope.GetUID()
                resourceNameList = append(resourceNameList, publicIpName)
        }</span>
        <span class="cov8" title="1">machineScope.V(2).Info("Check match publicip with vm")
        checkOscAssociate := Contains(resourceNameList, vmPublicIpName)
        if checkOscAssociate </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("%s publicIp does not exist in vm", vmPublicIpName)
        }</span>
}

// checkVmFormatParameters check Volume parameters format
func checkVmFormatParameters(machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) (string, error) <span class="cov8" title="1">{
        vmSpec := machineScope.GetVm()
        vmSpec.SetDefaultValue()
        vmName := vmSpec.Name + "-" + machineScope.GetUID()
        vmTagName, err := tag.ValidateTagNameValue(vmName)
        if err != nil </span><span class="cov8" title="1">{
                return vmTagName, err
        }</span>
        <span class="cov8" title="1">imageSpec := machineScope.GetImage()
        imageName := imageSpec.Name

        if imageName != "" </span><span class="cov8" title="1">{
                _, err = infrastructurev1beta1.ValidateImageName(imageName)
                if err != nil </span><span class="cov8" title="1">{
                        return vmTagName, err
                }</span>
        } else<span class="cov8" title="1"> {
                _, err = infrastructurev1beta1.ValidateImageId(vmSpec.ImageId)
                if err != nil </span><span class="cov8" title="1">{
                        return vmTagName, err
                }</span>
        }

        <span class="cov8" title="1">vmKeypairName := vmSpec.KeypairName
        _, err = infrastructurev1beta1.ValidateKeypairName(vmKeypairName)
        if err != nil </span><span class="cov8" title="1">{
                return vmTagName, err
        }</span>

        <span class="cov8" title="1">vmType := vmSpec.VmType
        _, err = infrastructurev1beta1.ValidateVmType(vmType)
        if err != nil </span><span class="cov8" title="1">{
                return vmTagName, err
        }</span>

        <span class="cov8" title="1">vmDeviceName := vmSpec.DeviceName
        _, err = infrastructurev1beta1.ValidateDeviceName(vmDeviceName)
        if err != nil </span><span class="cov8" title="1">{
                return vmTagName, err
        }</span>
        <span class="cov8" title="1">if vmSpec.VolumeDeviceName != "" </span><span class="cov8" title="1">{
                vmVolumeDeviceName := vmSpec.VolumeDeviceName
                _, err = infrastructurev1beta1.ValidateDeviceName(vmVolumeDeviceName)
                if err != nil </span><span class="cov8" title="1">{
                        return vmTagName, err
                }</span>
        }

        <span class="cov8" title="1">vmSubregionName := vmSpec.SubregionName
        _, err = infrastructurev1beta1.ValidateSubregionName(vmSubregionName)
        if err != nil </span><span class="cov8" title="1">{
                return vmTagName, err
        }</span>

        <span class="cov8" title="1">vmSubnetName := vmSpec.SubnetName
        machineScope.V(4).Info("Get vmSubnetName", "vmSubnetName", vmSubnetName)
        ipSubnetRange := clusterScope.GetIpSubnetRange(vmSubnetName)
        vmPrivateIps := machineScope.GetVmPrivateIps()
        var subnetsSpec []*infrastructurev1beta1.OscSubnet
        networkSpec := clusterScope.GetNetwork()
        networkSpec.SetSubnetDefaultValue()
        subnetsSpec = networkSpec.Subnets
        for _, subnetSpec := range subnetsSpec </span><span class="cov8" title="1">{
                subnetName := subnetSpec.Name
                machineScope.V(4).Info("Get SubnetName", "subnetName", subnetName)
                ipSubnetRange := subnetSpec.IpSubnetRange
                machineScope.V(4).Info("Get IpSubnetRange", "ipSubnetRange", ipSubnetRange)
        }</span>
        <span class="cov8" title="1">for _, vmPrivateIp := range *vmPrivateIps </span><span class="cov8" title="1">{
                privateIp := vmPrivateIp.PrivateIp
                machineScope.V(4).Info("Get Valid IP", "privateIp", privateIp)
                _, err := compute.ValidateIpAddrInCidr(privateIp, ipSubnetRange)
                if err != nil </span><span class="cov8" title="1">{
                        return vmTagName, err
                }</span>
        }

        <span class="cov8" title="1">if vmSpec.RootDisk.RootDiskIops != 0 </span><span class="cov8" title="1">{
                rootDiskIops := vmSpec.RootDisk.RootDiskIops
                machineScope.V(4).Info("Check rootDiskIops", "rootDiskIops", rootDiskIops)
                _, err := infrastructurev1beta1.ValidateIops(rootDiskIops)
                if err != nil </span><span class="cov8" title="1">{
                        return vmTagName, err
                }</span>
        }
        <span class="cov8" title="1">rootDiskSize := vmSpec.RootDisk.RootDiskSize
        machineScope.V(4).Info("Check rootDiskSize", "rootDiskSize", rootDiskSize)
        _, err = infrastructurev1beta1.ValidateSize(rootDiskSize)
        if err != nil </span><span class="cov8" title="1">{
                return vmTagName, err
        }</span>

        <span class="cov8" title="1">rootDiskType := vmSpec.RootDisk.RootDiskType
        machineScope.V(4).Info("Check rootDiskType", "rootDiskTyp", rootDiskType)
        _, err = infrastructurev1beta1.ValidateVolumeType(rootDiskType)
        if err != nil </span><span class="cov8" title="1">{
                return vmTagName, err
        }</span>

        <span class="cov8" title="1">if vmSpec.RootDisk.RootDiskType == "io1" &amp;&amp; vmSpec.RootDisk.RootDiskIops != 0 &amp;&amp; vmSpec.RootDisk.RootDiskSize != 0 </span><span class="cov8" title="1">{
                ratioRootDiskSizeIops := vmSpec.RootDisk.RootDiskIops / vmSpec.RootDisk.RootDiskSize
                machineScope.V(4).Info("Check ratio rootdisk size iops", "ratioRootDiskSizeIops", ratioRootDiskSizeIops)
                _, err = infrastructurev1beta1.ValidateRatioSizeIops(ratioRootDiskSizeIops)
                if err != nil </span><span class="cov8" title="1">{
                        return vmTagName, err
                }</span>
        }
        <span class="cov8" title="1">return "", nil</span>
}

// checkVmPrivateIpOscDuplicateName check that there are not the same name for vm resource
func checkVmPrivateIpOscDuplicateName(machineScope *scope.MachineScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        vmPrivateIps := machineScope.GetVmPrivateIps()
        for _, vmPrivateIp := range *vmPrivateIps </span><span class="cov8" title="1">{
                privateIpName := vmPrivateIp.Name
                resourceNameList = append(resourceNameList, privateIpName)
        }</span>
        <span class="cov8" title="1">machineScope.V(2).Info("Check unique privateIp")
        duplicateResourceErr := alertDuplicate(resourceNameList)
        if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                return duplicateResourceErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// reconcileVm reconcile the vm of the machine
func reconcileVm(ctx context.Context, clusterScope *scope.ClusterScope, machineScope *scope.MachineScope, vmSvc compute.OscVmInterface, volumeSvc storage.OscVolumeInterface, publicIpSvc security.OscPublicIpInterface, loadBalancerSvc service.OscLoadBalancerInterface, securityGroupSvc security.OscSecurityGroupInterface, tagSvc tag.OscTagInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        vmSpec := machineScope.GetVm()
        vmRef := machineScope.GetVmRef()
        vmName := vmSpec.Name + "-" + machineScope.GetUID()

        var volumeId string
        var err error
        if vmSpec.VolumeName != "" </span><span class="cov8" title="1">{
                volumeName := vmSpec.VolumeName + "-" + machineScope.GetUID()
                volumeId, err = getVolumeResourceId(volumeName, machineScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
        }

        <span class="cov8" title="1">subnetName := vmSpec.SubnetName + "-" + clusterScope.GetUID()
        subnetId, err := getSubnetResourceId(subnetName, clusterScope)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">var publicIpId string
        var vmPublicIpName string
        var linkPublicIpRef *infrastructurev1beta1.OscResourceReference
        if vmSpec.PublicIpName != "" </span><span class="cov8" title="1">{
                vmPublicIpName = vmSpec.PublicIpName + "-" + clusterScope.GetUID()
                publicIpId, err = getPublicIpResourceId(vmPublicIpName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">linkPublicIpRef = machineScope.GetLinkPublicIpRef()
                if len(linkPublicIpRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                        linkPublicIpRef.ResourceMap = make(map[string]string)
                }</span>
        }
        <span class="cov8" title="1">var privateIps []string
        vmPrivateIps := machineScope.GetVmPrivateIps()
        if len(*vmPrivateIps) &gt; 0 </span><span class="cov8" title="1">{
                for _, vmPrivateIp := range *vmPrivateIps </span><span class="cov8" title="1">{
                        privateIp := vmPrivateIp.PrivateIp
                        privateIps = append(privateIps, privateIp)
                }</span>
        }

        <span class="cov8" title="1">var securityGroupIds []string
        vmSecurityGroups := machineScope.GetVmSecurityGroups()
        for _, vmSecurityGroup := range *vmSecurityGroups </span><span class="cov8" title="1">{
                machineScope.V(4).Info("Get vmSecurityGroup", "vmSecurityGroup", vmSecurityGroup)
                securityGroupName := vmSecurityGroup.Name + "-" + clusterScope.GetUID()
                securityGroupId, err := getSecurityGroupResourceId(securityGroupName, clusterScope)
                machineScope.V(4).Info("Get securityGroupId", "securityGroupId", securityGroupId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">securityGroupIds = append(securityGroupIds, securityGroupId)</span>
        }

        <span class="cov8" title="1">var vmVolumeDeviceName string
        if vmSpec.VolumeDeviceName != "" </span><span class="cov8" title="1">{
                vmVolumeDeviceName = vmSpec.VolumeDeviceName
        }</span>
        <span class="cov8" title="1">var vm *osc.Vm
        var vmID string
        if len(vmRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                vmRef.ResourceMap = make(map[string]string)
        }</span>
        <span class="cov8" title="1">tagKey := "Name"
        tagValue := vmName
        tag, err := tagSvc.ReadTag(tagKey, tagValue)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, fmt.Errorf("%w Can not get tag for OscMachine %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
        }</span>
        <span class="cov8" title="1">machineScope.V(4).Info("Get ResourceId", "resourceId", vmSpec.ResourceId)
        machineScope.V(4).Info("Get ResourceMap", "resourceMap", vmRef.ResourceMap)
        if vmSpec.ResourceId != "" </span><span class="cov8" title="1">{
                vmRef.ResourceMap[vmName] = vmSpec.ResourceId
                vmId := vmSpec.ResourceId
                machineScope.V(4).Info("Check if the desired vm exist", "vmName", vmName)
                vm, err = vmSvc.GetVm(vmId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">clusterName := vmSpec.ClusterName + "-" + clusterScope.GetUID()
                privateDnsName, ok := vm.GetPrivateDnsNameOk()
                if !ok </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("Can not found privateDnsName %s/%s", machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">privateIp, ok := vm.GetPrivateIpOk()
                if !ok </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("Can not found privateIp %s/%s", machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">addresses := []corev1.NodeAddress{}
                addresses = append(
                        addresses,
                        corev1.NodeAddress{
                                Type:    corev1.NodeInternalIP,
                                Address: *privateIp,
                        },
                )
                machineScope.SetAddresses(addresses)
                err = vmSvc.AddCcmTag(clusterName, *privateDnsName, vmId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w can not add ccm tag %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">vmState, err := vmSvc.GetVmState(vmId)
                if err != nil </span><span class="cov8" title="1">{
                        machineScope.SetVmState(infrastructurev1beta1.VmState("unknown"))
                        return reconcile.Result{}, fmt.Errorf("%w Can not get vm %s state for OscMachine %s/%s", err, vmId, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">machineScope.SetVmState(infrastructurev1beta1.VmState(vmState))
                machineScope.V(4).Info("Get vm state", "vmState", vmState)</span>
        }
        <span class="cov8" title="1">if (vm == nil &amp;&amp; tag == nil) || (vmSpec.ResourceId == "" &amp;&amp; tag == nil) </span><span class="cov8" title="1">{
                machineScope.V(4).Info("Create the desired vm", "vmName", vmName)
                imageId := vmSpec.ImageId
                machineScope.V(4).Info("Info ImageId", "imageId", imageId)
                keypairName := vmSpec.KeypairName
                machineScope.V(4).Info("Info keypairName", "keypairName", keypairName)
                vmType := vmSpec.VmType
                machineScope.V(4).Info("Info vmType", "vmType", vmType)

                vm, err := vmSvc.CreateVm(machineScope, vmSpec, subnetId, securityGroupIds, privateIps, vmName)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not create vm for OscMachine %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
                }</span>

                <span class="cov8" title="1">vmID = vm.GetVmId()
                err = vmSvc.CheckVmState(20, 240, "running", vmID)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get vm %s running for OscMachine %s/%s", err, vmID, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">machineScope.V(4).Info("Vm is running", "vmId", vmID)
                machineScope.SetVmState(infrastructurev1beta1.VmState("pending"))
                if vmSpec.VolumeName != "" </span><span class="cov8" title="1">{
                        err = volumeSvc.CheckVolumeState(20, 240, "available", volumeId)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not get volume %s available for OscMachine %s/%s", err, volumeId, machineScope.GetNamespace(), machineScope.GetName())
                        }</span>
                        <span class="cov8" title="1">machineScope.V(4).Info("Volume is available", "volumeId", volumeId)
                        err = volumeSvc.LinkVolume(volumeId, vmID, vmVolumeDeviceName)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not link volume %s with vm %s for OscMachine %s/%s", err, volumeId, vmID, machineScope.GetNamespace(), machineScope.GetName())
                        }</span>
                        <span class="cov8" title="1">machineScope.V(4).Info("Volume is linked", "volumeId", volumeId)
                        err = volumeSvc.CheckVolumeState(20, 240, "in-use", volumeId)
                        machineScope.V(4).Info("Volume is in-use", "volumeId", volumeId)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not get volume %s in use for OscMachine %s/%s", err, volumeId, machineScope.GetNamespace(), machineScope.GetName())
                        }</span>
                }
                <span class="cov8" title="1">err = vmSvc.CheckVmState(20, 240, "running", vmID)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get vm %s running for OscMachine %s/%s", err, vmID, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">machineScope.V(4).Info("Vm is running again", "vmId", vmID)

                if vmSpec.PublicIpName != "" </span><span class="cov8" title="1">{
                        linkPublicIpId, err := publicIpSvc.LinkPublicIp(publicIpId, vmID)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not link publicIp  %s with %s for OscCluster %s/%s", err, publicIpId, vmID, machineScope.GetNamespace(), machineScope.GetName())
                        }</span>
                        <span class="cov8" title="1">machineScope.V(4).Info("Link public ip", "linkPublicIpId", linkPublicIpId)
                        linkPublicIpRef.ResourceMap[vmPublicIpName] = linkPublicIpId

                        err = vmSvc.CheckVmState(20, 240, "running", vmID)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not get vm %s running for OscMachine %s/%s", err, vmID, machineScope.GetNamespace(), machineScope.GetName())
                        }</span>
                }
                <span class="cov8" title="1">if vmSpec.LoadBalancerName != "" </span><span class="cov8" title="1">{
                        loadBalancerName := vmSpec.LoadBalancerName
                        vmIds := []string{vmID}
                        err := loadBalancerSvc.LinkLoadBalancerBackendMachines(vmIds, loadBalancerName)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not link vm %s with loadBalancerName %s for OscCluster %s/%s", err, loadBalancerName, vmID, machineScope.GetNamespace(), machineScope.GetName())
                        }</span>
                        <span class="cov8" title="1">securityGroupsRef := clusterScope.GetSecurityGroupsRef()
                        loadBalancerSpec := clusterScope.GetLoadBalancer()
                        loadBalancerSpec.SetDefaultValue()
                        loadBalancerSecurityGroupName := loadBalancerSpec.SecurityGroupName
                        ipProtocol := strings.ToLower(loadBalancerSpec.Listener.BackendProtocol)
                        machineScope.V(4).Info("Get IpProtocol", "IpProtocol", ipProtocol)
                        fromPortRange := loadBalancerSpec.Listener.BackendPort
                        machineScope.V(4).Info("Get fromPortRange", "fromPortRange", fromPortRange)
                        toPortRange := loadBalancerSpec.Listener.BackendPort
                        machineScope.V(4).Info("Get ToPortRange", "ToPortRange", toPortRange)
                        loadBalancerSecurityGroupClusterScopeName := loadBalancerSecurityGroupName + "-" + clusterScope.GetUID()
                        associateSecurityGroupId := securityGroupsRef.ResourceMap[loadBalancerSecurityGroupClusterScopeName]
                        machineScope.V(4).Info("Get sg", "associateSecurityGroupId", associateSecurityGroupId)
                        securityGroupFromSecurityGroupOutboundRule, err := securityGroupSvc.GetSecurityGroupFromSecurityGroupRule(associateSecurityGroupId, "Outbound", ipProtocol, "", securityGroupIds[0], fromPortRange, toPortRange)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not get outbound securityGroupRule for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">if securityGroupFromSecurityGroupOutboundRule == nil </span><span class="cov8" title="1">{
                                _, err = securityGroupSvc.CreateSecurityGroupRule(associateSecurityGroupId, "Outbound", ipProtocol, "", securityGroupIds[0], fromPortRange, toPortRange)
                                if err != nil </span><span class="cov8" title="1">{
                                        return reconcile.Result{}, fmt.Errorf("%w Can not create outbound securityGroupRule for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                                }</span>
                        }
                        <span class="cov8" title="1">securityGroupFromSecurityGroupInboundRule, err := securityGroupSvc.GetSecurityGroupFromSecurityGroupRule(securityGroupIds[0], "Inbound", ipProtocol, "", associateSecurityGroupId, fromPortRange, toPortRange)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not get inbound securityGroupRule for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                        }</span>
                        <span class="cov8" title="1">if securityGroupFromSecurityGroupInboundRule == nil </span><span class="cov8" title="1">{
                                _, err = securityGroupSvc.CreateSecurityGroupRule(securityGroupIds[0], "Inbound", ipProtocol, "", associateSecurityGroupId, fromPortRange, toPortRange)
                                if err != nil </span><span class="cov8" title="1">{
                                        return reconcile.Result{}, fmt.Errorf("%w Can not create inbound securityGroupRule for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                                }</span>
                        }

                }

                <span class="cov8" title="1">machineScope.V(2).Info("Get Vm", "vm", vm)
                vmRef.ResourceMap[vmName] = vmID
                vmSpec.ResourceId = vmID
                subregionName := vmSpec.SubregionName
                machineScope.SetProviderID(subregionName, vmID)</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteVm reconcile the destruction of the vm of the machine
func reconcileDeleteVm(ctx context.Context, clusterScope *scope.ClusterScope, machineScope *scope.MachineScope, vmSvc compute.OscVmInterface, publicIpSvc security.OscPublicIpInterface, loadBalancerSvc service.OscLoadBalancerInterface, securityGroupSvc security.OscSecurityGroupInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        oscmachine := machineScope.OscMachine
        vmSpec := machineScope.GetVm()
        vmSpec.SetDefaultValue()
        vmId := vmSpec.ResourceId
        machineScope.V(4).Info("Get VmID", "vmId", vmId)
        vmName := vmSpec.Name
        if vmSpec.ResourceId == "" </span><span class="cov8" title="1">{
                machineScope.V(2).Info("The desired vm is currently destroyed", "vmName", vmName)
                controllerutil.RemoveFinalizer(oscmachine, "")
                return reconcile.Result{}, nil
        }</span>
        <span class="cov8" title="1">keypairSpec := machineScope.GetKeypair()
        machineScope.V(4).Info("Check keypair", "keypair", keypairSpec.Name)
        deleteKeypair := machineScope.GetDeleteKeypair()

        vm, err := vmSvc.GetVm(vmId)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">var securityGroupIds []string
        vmSecurityGroups := machineScope.GetVmSecurityGroups()
        for _, vmSecurityGroup := range *vmSecurityGroups </span><span class="cov8" title="1">{
                securityGroupName := vmSecurityGroup.Name + "-" + clusterScope.GetUID()
                securityGroupId, err := getSecurityGroupResourceId(securityGroupName, clusterScope)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, err
                }</span>
                <span class="cov8" title="1">securityGroupIds = append(securityGroupIds, securityGroupId)</span>
        }
        <span class="cov8" title="1">if vmSpec.PublicIpName != "" </span><span class="cov8" title="1">{
                linkPublicIpRef := machineScope.GetLinkPublicIpRef()
                publicIpName := vmSpec.PublicIpName + "-" + clusterScope.GetUID()
                err = publicIpSvc.UnlinkPublicIp(linkPublicIpRef.ResourceMap[publicIpName])
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not unlink publicIp for OscCluster %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
                }</span>

        }
        <span class="cov8" title="1">if vmSpec.LoadBalancerName != "" </span><span class="cov8" title="1">{
                vmIds := []string{vmId}
                loadBalancerName := vmSpec.LoadBalancerName
                err := loadBalancerSvc.UnlinkLoadBalancerBackendMachines(vmIds, loadBalancerName)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not unlink vm %s with loadBalancerName %s for OscCluster %s/%s", err, loadBalancerName, vmId, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">clusterScope.V(2).Info("Get list OscMachine")
                var machineSize int
                var machineKcpCount int32
                var machineKwCount int32
                var machineCount int32

                var machines []*clusterv1.Machine
                if vmSpec.Replica != 1 </span><span class="cov0" title="0">{
                        machines, _, err = clusterScope.ListMachines(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not get ListMachine", err)
                        }</span>
                        <span class="cov0" title="0">machineSize = len(machines)
                        clusterScope.V(4).Info("Get info OscMachine", "machineSize", machineSize)</span>
                } else<span class="cov8" title="1"> {
                        machineSize = 1
                        machineKcpCount = 1
                        machineCount = 1

                }</span>

                <span class="cov8" title="1">if machineSize &gt; 0 </span><span class="cov8" title="1">{
                        if vmSpec.Replica != 1 </span><span class="cov0" title="0">{
                                clusterScope.V(2).Info("Get  MachineList")
                                names := make([]string, len(machines))
                                for i, m := range machines </span><span class="cov0" title="0">{
                                        names[i] = fmt.Sprintf("machine/%s", m.Name)
                                        machineScope.V(4).Info("Get Machines", "machine", m.Name)
                                        machineLabel := m.Labels
                                        for labelKey := range machineLabel </span><span class="cov0" title="0">{
                                                if labelKey == "cluster.x-k8s.io/control-plane" </span><span class="cov0" title="0">{
                                                        machineScope.V(4).Info("Get Kcp Machine", "machineKcp", m.Name)
                                                        machineKcpCount++
                                                }</span>
                                                <span class="cov0" title="0">if labelKey == "cluster.x-k8s.io/deployment-name" </span><span class="cov0" title="0">{
                                                        machineScope.V(4).Info("Get Kw Machine", "machineKw", m.Name)
                                                        machineKwCount++
                                                }</span>

                                        }
                                        <span class="cov0" title="0">machineCount = machineKwCount + machineKcpCount</span>
                                }
                        }
                        <span class="cov8" title="1">if machineCount != 1 </span><span class="cov0" title="0">{
                                machineScope.SetDeleteKeypair(false)
                                machineScope.V(2).Info("Keep Keypair from vm")
                                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil
                        }</span>
                        <span class="cov8" title="1">if machineKcpCount == 1 </span><span class="cov8" title="1">{
                                machineScope.SetDeleteKeypair(deleteKeypair)
                                securityGroupsRef := clusterScope.GetSecurityGroupsRef()
                                loadBalancerSpec := clusterScope.GetLoadBalancer()
                                loadBalancerSecurityGroupName := loadBalancerSpec.SecurityGroupName
                                ipProtocol := strings.ToLower(loadBalancerSpec.Listener.BackendProtocol)
                                machineScope.V(4).Info("Get IpProtocol", "ipProtocol", ipProtocol)
                                fromPortRange := loadBalancerSpec.Listener.BackendPort
                                machineScope.V(4).Info("Get FromPortRange", "FromPortRange", fromPortRange)
                                toPortRange := loadBalancerSpec.Listener.BackendPort
                                machineScope.V(4).Info("Get ToPortRange", "ToPortRange", toPortRange)
                                loadBalancerSecurityGroupClusterScopeName := loadBalancerSecurityGroupName + "-" + clusterScope.GetUID()
                                associateSecurityGroupId := securityGroupsRef.ResourceMap[loadBalancerSecurityGroupClusterScopeName]
                                machineScope.V(4).Info("Get associate", "AssociateSecurityGroupId", associateSecurityGroupId)
                                machineScope.V(4).Info("Get sg id", "securityGroupIds", securityGroupIds[0])
                                machineScope.V(2).Info("Delete LoadBalancer sg")
                                err = securityGroupSvc.DeleteSecurityGroupRule(associateSecurityGroupId, "Outbound", ipProtocol, "", securityGroupIds[0], fromPortRange, toPortRange)
                                if err != nil </span><span class="cov8" title="1">{
                                        return reconcile.Result{}, fmt.Errorf("%w Can not delete outbound securityGroupRule for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                                }</span>
                                <span class="cov8" title="1">err = securityGroupSvc.DeleteSecurityGroupRule(securityGroupIds[0], "Inbound", ipProtocol, "", securityGroupIds[0], fromPortRange, toPortRange)
                                if err != nil </span><span class="cov8" title="1">{
                                        return reconcile.Result{}, fmt.Errorf("%w Can not delete inbound securityGroupRule for OscCluster %s/%s", err, clusterScope.GetNamespace(), clusterScope.GetName())
                                }</span>

                        } else<span class="cov0" title="0"> {
                                machineScope.V(2).Info("Get several control plane machine, can not delete loadBalancer securityGroup", "machineKcp", machineKcpCount)
                        }</span>
                }
        }

        <span class="cov8" title="1">if vm == nil </span><span class="cov8" title="1">{
                machineScope.V(2).Info("The desired vm does not exist anymore", "vmName", vmName)
                controllerutil.RemoveFinalizer(oscmachine, "")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">err = vmSvc.DeleteVm(vmId)
        vmSpec.ResourceId = ""
        machineScope.V(2).Info("Delete the desired vm", "vmName", vmName)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{RequeueAfter: 30 * time.Second}, fmt.Errorf("%w Can not delete vm for OscMachine %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
        }</span>
        <span class="cov8" title="1">return reconcile.Result{RequeueAfter: 30 * time.Second}, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/storage"
        tag "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/tag"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"

        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getVolumeResourceId return the volumeId from the resourceMap base on resourceName (tag name + cluster uid)
func getVolumeResourceId(resourceName string, machineScope *scope.MachineScope) (string, error) <span class="cov8" title="1">{
        volumeRef := machineScope.GetVolumeRef()
        if volumeId, ok := volumeRef.ResourceMap[resourceName]; ok </span><span class="cov8" title="1">{
                return volumeId, nil
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("%s does not exist", resourceName)
        }</span>
}

// checkVolumeOscDuplicateName check that there are not the same name for volume resource
func checkVolumeOscDuplicateName(machineScope *scope.MachineScope) error <span class="cov8" title="1">{
        var resourceNameList []string
        volumesSpec := machineScope.GetVolume()
        for _, volumeSpec := range volumesSpec </span><span class="cov8" title="1">{
                resourceNameList = append(resourceNameList, volumeSpec.Name)
        }</span>
        <span class="cov8" title="1">machineScope.V(2).Info("Check unique name volume")
        duplicateResourceErr := alertDuplicate(resourceNameList)
        if duplicateResourceErr != nil </span><span class="cov8" title="1">{
                return duplicateResourceErr
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

// checkVolumeFormatParameters check Volume parameters format
func checkVolumeFormatParameters(machineScope *scope.MachineScope) (string, error) <span class="cov0" title="0">{
        var volumesSpec []*infrastructurev1beta1.OscVolume
        nodeSpec := machineScope.GetNode()
        if nodeSpec.Volumes == nil </span><span class="cov0" title="0">{
                nodeSpec.SetVolumeDefaultValue()
                volumesSpec = nodeSpec.Volumes
        }</span> else<span class="cov0" title="0"> {
                volumesSpec = machineScope.GetVolume()
        }</span>
        <span class="cov0" title="0">machineScope.V(4).Info("Number of volumes", "volumeLength", len(volumesSpec))
        for _, volumeSpec := range volumesSpec </span><span class="cov0" title="0">{

                volumeName := volumeSpec.Name + "-" + machineScope.GetUID()
                machineScope.V(2).Info("Check Volumes parameters")
                volumeTagName, err := tag.ValidateTagNameValue(volumeName)
                if err != nil </span><span class="cov0" title="0">{
                        return volumeTagName, err
                }</span>

                <span class="cov0" title="0">if volumeSpec.Iops != 0 </span><span class="cov0" title="0">{
                        volumeIops := volumeSpec.Iops
                        _, err = infrastructurev1beta1.ValidateIops(volumeIops)
                        if err != nil </span><span class="cov0" title="0">{
                                return volumeTagName, err
                        }</span>
                }

                <span class="cov0" title="0">volumeSize := volumeSpec.Size
                machineScope.V(4).Info("Check volume size", "volumeSize", volumeSize)
                _, err = infrastructurev1beta1.ValidateSize(volumeSize)
                if err != nil </span><span class="cov0" title="0">{
                        return volumeTagName, err
                }</span>

                <span class="cov0" title="0">volumeSubregionName := volumeSpec.SubregionName
                _, err = infrastructurev1beta1.ValidateSubregionName(volumeSubregionName)
                if err != nil </span><span class="cov0" title="0">{
                        return volumeTagName, err
                }</span>
                <span class="cov0" title="0">volumeType := volumeSpec.VolumeType
                _, err = infrastructurev1beta1.ValidateVolumeType(volumeType)
                if err != nil </span><span class="cov0" title="0">{
                        return volumeTagName, err
                }</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}

// reconcileVolume reconcile the volume of the machine

func reconcileVolume(ctx context.Context, machineScope *scope.MachineScope, volumeSvc storage.OscVolumeInterface, tagSvc tag.OscTagInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        var volumeId string
        var volumeIds []string
        var volumesSpec []*infrastructurev1beta1.OscVolume
        volumesSpec = machineScope.GetVolume()
        volumeRef := machineScope.GetVolumeRef()
        for _, volumeSpec := range volumesSpec </span><span class="cov8" title="1">{
                volumeId = volumeSpec.ResourceId
                volumeIds = append(volumeIds, volumeId)
        }</span>
        <span class="cov8" title="1">validVolumeIds, err := volumeSvc.ValidateVolumeIds(volumeIds)
        machineScope.V(4).Info("Check Id", "volume", validVolumeIds)

        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">for _, volumeSpec := range volumesSpec </span><span class="cov8" title="1">{
                volumeName := volumeSpec.Name + "-" + machineScope.GetUID()
                if len(volumeRef.ResourceMap) == 0 </span><span class="cov8" title="1">{
                        volumeRef.ResourceMap = make(map[string]string)
                }</span>
                <span class="cov8" title="1">if volumeSpec.ResourceId != "" </span><span class="cov8" title="1">{
                        volumeRef.ResourceMap[volumeName] = volumeSpec.ResourceId
                }</span>
                <span class="cov8" title="1">tagKey := "Name"
                tagValue := volumeName
                tag, err := tagSvc.ReadTag(tagKey, tagValue)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get tag for OscMachine %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">volumeId := volumeRef.ResourceMap[volumeName]
                machineScope.V(2).Info("Check if the desired volumes exist")
                if !Contains(validVolumeIds, volumeId) &amp;&amp; tag == nil </span><span class="cov8" title="1">{
                        volume, err := volumeSvc.CreateVolume(volumeSpec, volumeName)
                        if err != nil </span><span class="cov8" title="1">{
                                return reconcile.Result{}, fmt.Errorf("%w Can not create volume for OscMachine %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
                        }</span>
                        <span class="cov8" title="1">volumeId := volume.GetVolumeId()
                        machineScope.V(4).Info("Get VolumeId", "volumeId", volumeId)
                        if volumeId != "" </span><span class="cov8" title="1">{
                                err = volumeSvc.CheckVolumeState(5, 60, "available", volumeId)
                                if err != nil </span><span class="cov8" title="1">{
                                        return reconcile.Result{}, fmt.Errorf("%w Can not get volume available for OscMachine %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
                                }</span>
                                <span class="cov8" title="1">machineScope.V(4).Info("Volume is available", "volumeId", volumeId)</span>
                        }
                        <span class="cov8" title="1">machineScope.V(4).Info("Get volume", "volume", volume)
                        volumeRef.ResourceMap[volumeName] = volume.GetVolumeId()
                        volumeSpec.ResourceId = volume.GetVolumeId()</span>
                }
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

// reconcileDeleteVolume reconcile the destruction of the volume of the machine
func reconcileDeleteVolume(ctx context.Context, machineScope *scope.MachineScope, volumeSvc storage.OscVolumeInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        oscmachine := machineScope.OscMachine

        var volumesSpec []*infrastructurev1beta1.OscVolume
        nodeSpec := machineScope.GetNode()
        if nodeSpec.Volumes == nil </span><span class="cov8" title="1">{
                nodeSpec.SetVolumeDefaultValue()
                volumesSpec = nodeSpec.Volumes
        }</span> else<span class="cov8" title="1"> {
                volumesSpec = machineScope.GetVolume()
        }</span>

        <span class="cov8" title="1">var volumeIds []string
        var volumeId string
        for _, volumeSpec := range volumesSpec </span><span class="cov8" title="1">{
                volumeId = volumeSpec.ResourceId
                volumeIds = append(volumeIds, volumeId)
        }</span>
        <span class="cov8" title="1">validVolumeIds, err := volumeSvc.ValidateVolumeIds(volumeIds)
        machineScope.V(4).Info("Check Volume Id", "volume", volumeIds)
        if err != nil </span><span class="cov8" title="1">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">machineScope.V(4).Info("Number of volume", "volumeLength", len(volumesSpec))
        for _, volumeSpec := range volumesSpec </span><span class="cov8" title="1">{
                volumeId = volumeSpec.ResourceId
                volumeName := volumeSpec.Name + "-" + machineScope.GetUID()
                if !Contains(validVolumeIds, volumeId) </span><span class="cov8" title="1">{
                        controllerutil.RemoveFinalizer(oscmachine, "")
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov8" title="1">err = volumeSvc.CheckVolumeState(5, 60, "in-use", volumeId)
                machineScope.V(4).Info("Volume is in use", "volumeId", volumeId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get volume %s in use for OscMachine %s/%s", err, volumeId, machineScope.GetNamespace(), machineScope.GetName())
                }</span>

                <span class="cov8" title="1">err = volumeSvc.UnlinkVolume(volumeId)
                machineScope.V(4).Info("Volume is unlinked", "volumeId", volumeId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not unlink volume %s in use for OscMachine %s/%s", err, volumeId, machineScope.GetNamespace(), machineScope.GetName())
                }</span>

                <span class="cov8" title="1">err = volumeSvc.CheckVolumeState(5, 60, "available", volumeId)
                machineScope.V(4).Info("Volume is available", "volumeId", volumeId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get volume %s available for OscMachine %s/%s", err, volumeId, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
                <span class="cov8" title="1">machineScope.V(2).Info("Delete the desired volume", "volumeName", volumeName)
                err = volumeSvc.DeleteVolume(volumeId)
                if err != nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not delete volume for OscMachine %s/%s", err, machineScope.GetNamespace(), machineScope.GetName())
                }</span>
        }
        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "time"

        infrastructurev1beta1 "github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/compute"
        "github.com/pkg/errors"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/client-go/tools/record"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// getVmSvc retrieve vmSvc
func (r *OscMachineTemplateReconciler) getVmSvc(ctx context.Context, scope scope.ClusterScope) compute.OscVmInterface <span class="cov0" title="0">{
        return compute.NewService(ctx, &amp;scope)
}</span>

type OscMachineTemplateReconciler struct {
        client.Client
        Recorder         record.EventRecorder
        ReconcileTimeout time.Duration
}

// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=oscmachinetemplates,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=oscmachinetemplates/status,verbs=get;update;patch

// Reconcile manages the lifecycle of an OscMachineTemplate object.
func (r *OscMachineTemplateReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov0" title="0">{
        log := ctrl.LoggerFrom(ctx).WithValues("oscmachinetemplate", req.NamespacedName)
        log.V(2).Info("Reconcile OscMachineTemplate")

        machineTemplate := &amp;infrastructurev1beta1.OscMachineTemplate{}
        if err := r.Get(ctx, req.NamespacedName, machineTemplate); err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        <span class="cov0" title="0">machineTemplateScope, err := scope.NewMachineTemplateScope(scope.MachineTemplateScopeParams{
                Client:             r.Client,
                Logger:             log,
                OscMachineTemplate: machineTemplate,
        })
        clusterName := machineTemplateScope.GetClusterName()

        labels := map[string]string{"ccm": clusterName + "-crs-ccm"}
        clusterList := &amp;clusterv1.ClusterList{}
        cluster := clusterv1.Cluster{}
        err = r.List(ctx, clusterList, client.InNamespace(machineTemplate.Namespace), client.MatchingLabels(labels))
        if err != nil </span><span class="cov0" title="0">{
                log.V(2).Info("Cluster is not available yet")
                log.Error(err, "failed to get owning cluster.")
                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil
        }</span> else<span class="cov0" title="0"> {
                for _, cluster = range clusterList.Items </span><span class="cov0" title="0">{
                        machineTemplateScope.V(4).Info("Get Cluster", "cluster", cluster.Name)
                        log.V(2).Info("Find cluster")

                }</span>
                <span class="cov0" title="0">if len(clusterList.Items) == 0 </span><span class="cov0" title="0">{
                        log.V(2).Info("OscCluster is not available yet")
                        return reconcile.Result{RequeueAfter: 30 * time.Second}, nil
                }</span>
        }
        <span class="cov0" title="0">oscCluster := &amp;infrastructurev1beta1.OscCluster{}
        oscClusterName := client.ObjectKey{
                Namespace: machineTemplate.Namespace,
                Name:      cluster.Spec.InfrastructureRef.Name,
        }
        if err := r.Client.Get(ctx, oscClusterName, oscCluster); err != nil </span><span class="cov0" title="0">{
                log.Info("OscCluster is not available yet")
                return reconcile.Result{}, err
        }</span>
        <span class="cov0" title="0">clusterScope, err := scope.NewClusterScope(scope.ClusterScopeParams{
                Client:     r.Client,
                Logger:     log,
                Cluster:    &amp;cluster,
                OscCluster: oscCluster,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Errorf("failed to create scope: %+v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := machineTemplateScope.Close(); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()
        <span class="cov0" title="0">if !machineTemplate.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return r.reconcileDelete(ctx, machineTemplateScope, clusterScope)
        }</span>
        <span class="cov0" title="0">return r.reconcile(ctx, machineTemplateScope, clusterScope)</span>
}

// reconcile reconcile the creation of the machine
func (r *OscMachineTemplateReconciler) reconcile(ctx context.Context, machineTemplateScope *scope.MachineTemplateScope, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov0" title="0">{
        machineTemplateScope.V(2).Info("Reconciling OscMachineTemplate")
        controllerutil.AddFinalizer(machineTemplateScope.OscMachineTemplate, "oscmachine.infrastructure.cluster.x-k8s.io")

        if err := machineTemplateScope.PatchObject(); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov0" title="0">vmSvc := r.getVmSvc(ctx, *clusterScope)
        reconcileCapacity, err := reconcileCapacity(ctx, clusterScope, machineTemplateScope, vmSvc)
        if err != nil </span><span class="cov0" title="0">{
                return reconcileCapacity, err
        }</span>
        <span class="cov0" title="0">return reconcileCapacity, nil</span>

}

// reconcileDelete reconcile the deletion of the machine
func (r *OscMachineTemplateReconciler) reconcileDelete(ctx context.Context, machineTemplateScope *scope.MachineTemplateScope, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov0" title="0">{
        machineTemplateScope.V(2).Info("Reconciling delete OscMachineTemplate")
        oscmachinetemplate := machineTemplateScope.OscMachineTemplate
        controllerutil.RemoveFinalizer(oscmachinetemplate, "oscmachine.infrastructure.cluster.x-k8s.io")
        return reconcile.Result{}, nil
}</span>

// SetupWithManager sets up the controller with the Manager.
func (r *OscMachineTemplateReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                WithOptions(options).
                For(&amp;infrastructurev1beta1.OscMachineTemplate{}).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/scope"
        "github.com/outscale-dev/cluster-api-provider-outscale.git/cloud/services/compute"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// reconcileCapacity reconcile oscmachinetemplate capacity
func reconcileCapacity(ctx context.Context, clusterScope *scope.ClusterScope, machineTemplateScope *scope.MachineTemplateScope, vmSvc compute.OscVmInterface) (reconcile.Result, error) <span class="cov8" title="1">{
        var machineSize int
        var machineKcpCount int32
        var machineKwCount int32
        var machineKcpReady int32
        var machineKwReady int32
        var machines []*clusterv1.Machine
        var err error
        vmReplica := machineTemplateScope.GetReplica()
        if vmReplica != 1 </span><span class="cov0" title="0">{
                machines, _, err = clusterScope.ListMachines(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, fmt.Errorf("%w Can not get ListMachine", err)
                }</span>
                <span class="cov0" title="0">machineSize = len(machines)
                clusterScope.V(4).Info("Get OscMachine Size", "machineSize", machineSize)</span>
        } else<span class="cov8" title="1"> {
                clusterScope.V(2).Info("Do not wait for OscMachine")
                machineSize = 1
                machineKcpReady = 1
                machineKcpCount = 1
        }</span>

        <span class="cov8" title="1">if machineSize &gt; 0 </span><span class="cov8" title="1">{
                if vmReplica != 1 </span><span class="cov0" title="0">{
                        names := make([]string, len(machines))
                        for i, m := range machines </span><span class="cov0" title="0">{
                                names[i] = fmt.Sprintf("machine/%s", m.Name)
                                machineTemplateScope.V(4).Info("Get Machines", "machine", m.Name)
                                machineLabel := m.Labels
                                for labelKey := range machineLabel </span><span class="cov0" title="0">{
                                        if labelKey == "cluster.x-k8s.io/control-plane" </span><span class="cov0" title="0">{
                                                machineTemplateScope.V(4).Info("Get Kcp Machine", "machineKcp", m.Name)
                                                machineKcpCount++
                                                if m.Status.Phase == "Running" || m.Status.Phase == "Provisioned" </span><span class="cov0" title="0">{
                                                        machineKcpReady++
                                                }</span>
                                        }
                                        <span class="cov0" title="0">if labelKey == "cluster.x-k8s.io/deployment-name" </span><span class="cov0" title="0">{
                                                machineTemplateScope.V(4).Info("Get Kw Machine", "machineKw", m.Name)
                                                machineKwCount++
                                                if m.Status.Phase == "Running" || m.Status.Phase == "Provisioned" </span><span class="cov0" title="0">{
                                                        machineKwReady++
                                                }</span>
                                        }
                                }
                        }
                }
                <span class="cov8" title="1">role := machineTemplateScope.GetRole()
                if role == "controlplane" &amp;&amp; machineKcpReady &gt; 0 &amp;&amp; machineKcpCount &gt; 0 </span><span class="cov8" title="1">{
                        machineTemplateScope.V(2).Info("At least one controlplane node ready")
                }</span> else<span class="cov0" title="0"> if role == "" &amp;&amp; machineKwReady &gt; 0 &amp;&amp; machineKwCount &gt; 0 </span><span class="cov0" title="0">{
                        machineTemplateScope.V(2).Info("At least one worker node ready")
                }</span> else<span class="cov0" title="0"> {
                        machineTemplateScope.V(2).Info("Node is not ready yet")
                        return reconcile.Result{RequeueAfter: 30 * time.Second}, nil
                }</span>
        } else<span class="cov0" title="0"> {
                return reconcile.Result{RequeueAfter: 30 * time.Second}, nil
        }</span>
        <span class="cov8" title="1">clusterName := machineTemplateScope.GetClusterName() + "-" + clusterScope.GetUID()
        machineTemplateScope.V(4).Info("Get ClusterName", "clusterName", clusterName)
        vmType := machineTemplateScope.GetVmType()
        capacity, err := vmSvc.GetCapacity("OscK8sClusterID/"+clusterName, "owned", vmType)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">machineTemplateScope.SetCapacity(capacity)
        return reconcile.Result{}, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
