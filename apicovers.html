
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1beta1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1/osccluster_types.go (20.0%)</option>
				
				<option value="file1">github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1/osccluster_validation.go (28.0%)</option>
				
				<option value="file2">github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1/osccluster_webhook.go (63.2%)</option>
				
				<option value="file3">github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1/oscclustertemplate_types.go (100.0%)</option>
				
				<option value="file4">github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1/oscclustertemplate_webhook.go (58.8%)</option>
				
				<option value="file5">github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1/oscmachine_types.go (33.3%)</option>
				
				<option value="file6">github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1/oscmachine_validation.go (82.5%)</option>
				
				<option value="file7">github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1/oscmachine_webhook.go (79.1%)</option>
				
				<option value="file8">github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1/oscmachinetemplate_type.go (33.3%)</option>
				
				<option value="file9">github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1/oscmachinetemplate_webhook.go (76.5%)</option>
				
				<option value="file10">github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1/tags.go (0.0%)</option>
				
				<option value="file11">github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1/types.go (0.0%)</option>
				
				<option value="file12">github.com/outscale-dev/cluster-api-provider-outscale.git/api/v1beta1/zz_generated.deepcopy.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "strings"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

func OscReplaceName(name string) string <span class="cov0" title="0">{
        replacer := strings.NewReplacer(".", "-", "/", "-", "_", "-")
        return replacer.Replace(name)
}</span>

// OscClusterSpec defines the desired state of OscCluster
type OscClusterSpec struct {
        Network              OscNetwork            `json:"network,omitempty"`
        ControlPlaneEndpoint clusterv1.APIEndpoint `json:"controlPlaneEndpoint,omitempty"`
}

// OscClusterStatus defines the observed state of OscCluster
type OscClusterStatus struct {
        Ready      bool                 `json:"ready,omitempty"`
        Network    OscNetworkResource   `json:"network,omitempty"`
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`
        VmState    *VmState             `json:"vmState,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

// OscCluster is the Schema for the oscclusters API
type OscCluster struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OscClusterSpec   `json:"spec,omitempty"`
        Status OscClusterStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// OscClusterList contains a list of OscCluster
type OscClusterList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OscCluster `json:"items"`
}

// GetConditions returns status of the state of the cluster resource.
func (r *OscCluster) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return r.Status.Conditions
}</span>

// SetConditions set status of the state of the cluster resource from clusterv1.Conditions.
func (r *OscCluster) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        r.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OscCluster{}, &amp;OscClusterList{})
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "errors"
        "net"
        "regexp"
        "strings"

        "k8s.io/apimachinery/pkg/util/validation/field"
)

const (
        minPort      = 0
        maxPort      = 65536
        minInterval  = 4
        maxInterval  = 601
        minThreshold = 0
        maxThreshold = 11
        minTimeout   = 1
        maxTimeout   = 61
)

// ValidateOscClusterSpec validate each parameters of oscCluster spec
func ValidateOscClusterSpec(spec OscClusterSpec) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        if spec.Network.LoadBalancer.LoadBalancerName != "" </span><span class="cov8" title="1">{
                if errs := ValidateAndReturnErrorList(spec.Network.LoadBalancer.LoadBalancerName, field.NewPath("loadBalancerName"), ValidateLoadBalancerName); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, errs...)
                }</span>
        }

        <span class="cov8" title="1">return allErrs</span>
}

// ValidateCidr check that the cidr string is a valide CIDR
func ValidateCidr(cidr string) (string, error) <span class="cov0" title="0">{
        if !strings.Contains(cidr, "/") </span><span class="cov0" title="0">{
                return cidr, errors.New("Invalid Not A CIDR")
        }</span>
        <span class="cov0" title="0">_, _, err := net.ParseCIDR(cidr)
        if err != nil </span><span class="cov0" title="0">{
                return cidr, err
        }</span>
        <span class="cov0" title="0">return cidr, nil</span>
}

// ValidateIpProtocol check that ipProtocol is valid
func ValidateIpProtocol(protocol string) (string, error) <span class="cov0" title="0">{
        switch </span>{
        case protocol == "tcp" || protocol == "udp" || protocol == "icmp" || protocol == "-1":<span class="cov0" title="0">
                return protocol, nil</span>
        default:<span class="cov0" title="0">
                return protocol, errors.New("Invalid protocol")</span>
        }
}

// ValidateFlow check that flow is valid
func ValidateFlow(flow string) (string, error) <span class="cov0" title="0">{
        switch </span>{
        case flow == "Inbound" || flow == "Outbound":<span class="cov0" title="0">
                return flow, nil</span>
        default:<span class="cov0" title="0">
                return flow, errors.New("Invalid flow")</span>
        }
}

// ValidateDescription check that description is valid
func ValidateDescription(description string) (string, error) <span class="cov0" title="0">{
        isValidateDescription := regexp.MustCompile("^[\x20-\x7E]{0,255}$").MatchString
        if isValidateDescription(description) </span><span class="cov0" title="0">{
                return description, nil
        }</span> else<span class="cov0" title="0"> {
                return description, errors.New("Invalid Description")
        }</span>
}

// ValidatePort check that the  port is a valide port
func ValidatePort(port int32) (int32, error) <span class="cov0" title="0">{
        if port &gt; minPort &amp;&amp; port &lt; maxPort </span><span class="cov0" title="0">{
                return port, nil
        }</span> else<span class="cov0" title="0"> {
                return port, errors.New("Invalid Port")
        }</span>
}

// ValidateLoadBalancerType check that the  loadBalancerType is a valid
func ValidateLoadBalancerType(loadBalancerType string) (string, error) <span class="cov0" title="0">{
        if loadBalancerType == "internet-facing" || loadBalancerType == "internal" </span><span class="cov0" title="0">{
                return loadBalancerType, nil
        }</span> else<span class="cov0" title="0"> {
                return loadBalancerType, errors.New("Invalid LoadBalancerType")
        }</span>
}

// ValidateInterval check that the interval is a valide time of second
func ValidateInterval(interval int32) (int32, error) <span class="cov0" title="0">{
        if interval &gt; minInterval &amp;&amp; interval &lt; maxInterval </span><span class="cov0" title="0">{
                return interval, nil
        }</span> else<span class="cov0" title="0"> {
                return interval, errors.New("Invalid Interval")
        }</span>
}

// ValidateThreshold check that the threshold is a valide number of ping
func ValidateThreshold(threshold int32) (int32, error) <span class="cov0" title="0">{
        if threshold &gt; minThreshold &amp;&amp; threshold &lt; maxThreshold </span><span class="cov0" title="0">{
                return threshold, nil
        }</span> else<span class="cov0" title="0"> {
                return threshold, errors.New("Invalid threshold")
        }</span>
}

// ValidateProtocol check that the protocol string is a valide protocol
func ValidateProtocol(protocol string) (string, error) <span class="cov0" title="0">{
        switch </span>{
        case protocol == "HTTP" || protocol == "TCP":<span class="cov0" title="0">
                return protocol, nil</span>
        case protocol == "SSL" || protocol == "HTTPS":<span class="cov0" title="0">
                return protocol, errors.New("Ssl certificat is required")</span>
        default:<span class="cov0" title="0">
                return protocol, errors.New("Invalid protocol")</span>
        }
}

// ValidateTimeout check that the timeoout is a valide maximum time of second
func ValidateTimeout(timeout int32) (int32, error) <span class="cov0" title="0">{
        if timeout &gt; minTimeout &amp;&amp; timeout &lt; maxTimeout </span><span class="cov0" title="0">{
                return timeout, nil
        }</span> else<span class="cov0" title="0"> {
                return timeout, errors.New("Invalid Timeout")
        }</span>
}

// ValidateLoadBalancerName check that the loadBalancerName is a valide name of load balancer
func ValidateLoadBalancerName(loadBalancerName string) (string, error) <span class="cov8" title="1">{
        isValidateLoadBalancerName := regexp.MustCompile(`^[0-9A-Za-z\s\-]{0,32}$`).MatchString
        if isValidateLoadBalancerName(loadBalancerName) </span><span class="cov0" title="0">{
                return loadBalancerName, nil
        }</span> else<span class="cov8" title="1"> {
                return loadBalancerName, errors.New("Invalid Description")
        }</span>
}

func ValidateAndReturnErrorList[T any](value T, fieldPath *field.Path, validateFunc func(T) (T, error)) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}
        _, err := validateFunc(value)
        if err != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fieldPath, value, err.Error()))
                return allErrs
        }</span>
        <span class="cov8" title="1">return allErrs</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "reflect"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/validation/field"
        ctrl "sigs.k8s.io/controller-runtime"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
)

var oscClusterLog = logf.Log.WithName("osccluster-resource")

// SetupWithManager sets up the controller with the Manager.
func (r *OscCluster) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewWebhookManagedBy(mgr).
                For(r).
                Complete()
}</span>

// +kubebuilder:webhook:path=/mutate-infrastructure-cluster-x-k8s-io-v1beta1-osccluster,mutating=true,failurePolicy=fail,sideEffects=None,groups=infrastructure.cluster.x-k8s.io,resources=oscclusters,verbs=create;update,versions=v1beta1,name=mosccluster.kb.io,admissionReviewVersions=v1
var _ webhook.Defaulter = &amp;OscCluster{}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (m *OscCluster) Default() <span class="cov0" title="0">{
        oscClusterLog.Info("default", "name", m.Name)

}</span>

//+kubebuilder:webhook:path=/validate-infrastructure-cluster-x-k8s-io-v1beta1-osccluster,mutating=false,failurePolicy=fail,sideEffects=None,groups=infrastructure.cluster.x-k8s.io,resources=oscclusters,verbs=create;update,versions=v1beta1,name=vosccluster.kb.io,admissionReviewVersions=v1

var _ webhook.Validator = &amp;OscCluster{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (m *OscCluster) ValidateCreate() error <span class="cov8" title="1">{
        oscMachineLog.Info("validate create", "name", m.Name)
        if allErrs := ValidateOscClusterSpec(m.Spec); len(allErrs) &gt; 0 </span><span class="cov8" title="1">{
                oscClusterLog.Info("validate error", "error", allErrs)
                return apierrors.NewInvalid(GroupVersion.WithKind("OscCluster").GroupKind(), m.Name, allErrs)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (r *OscCluster) ValidateUpdate(oldRaw runtime.Object) error <span class="cov8" title="1">{
        oscClusterLog.Info("validate update", "name", r.Name)
        var allErrs field.ErrorList
        old := oldRaw.(*OscCluster)

        oscClusterLog.Info("validate update old loadBalanceName", "loadBalanceName", old.Spec.Network.LoadBalancer.LoadBalancerName)
        oscClusterLog.Info("validate update old loadBalanceName", "loadBalanceName", r.Spec.Network.LoadBalancer.LoadBalancerName)

        if !reflect.DeepEqual(r.Spec.Network.LoadBalancer.LoadBalancerName, old.Spec.Network.LoadBalancer.LoadBalancerName) </span><span class="cov0" title="0">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "loadBalancerName"),
                                r.Spec.Network.LoadBalancer.LoadBalancerName, "field is immutable"),
                )
        }</span>
        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">return apierrors.NewInvalid(GroupVersion.WithKind("OscCluster").GroupKind(), r.Name, allErrs)</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (r *OscCluster) ValidateDelete() error <span class="cov0" title="0">{
        oscClusterLog.Info("validate delete", "name", r.Name)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

// OscClusterTemplateSpec defines the desired state of OscClusterTemplate
type OscClusterTemplateSpec struct {
        Template OscClusterTemplateResource `json:"template"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=oscclustertemplates,scope=Namespaced,categories=cluster-api
// +kubebuilder:storageversion
// OscClusterTemplate is the Schema for the oscclustertemplates API
type OscClusterTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`
        Spec              OscClusterTemplateSpec `json:"spec,omitempty"`
}

//+kubebuilder:object:root=true

// OscClusterTemplateList contains a list of OscClusterTemplate
type OscClusterTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OscClusterTemplate `json:"items"`
}

type OscClusterTemplateResource struct {
        ObjectMeta clusterv1.ObjectMeta `json:"metadata,omitempty"`
        Spec       OscClusterSpec       `json:"spec"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OscClusterTemplate{}, &amp;OscClusterTemplateList{})
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "reflect"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/util/validation/field"

        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
)

const (
        OscClusterTemplateImmutableMsg = "OscClusterTemplate spec.template.spec field is immutable."
)

// log is for logging in this package.
var oscClusterTemplateLog = logf.Log.WithName("oscclustertemplate-resource")

func (r *OscClusterTemplate) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewWebhookManagedBy(mgr).For(r).Complete()
}</span>

//+kubebuilder:webhook:path=/mutate-infrastructure-cluster-x-k8s-io-v1beta1-oscclustertemplate,mutating=true,failurePolicy=fail,sideEffects=None,groups=infrastructure.cluster.x-k8s.io,resources=oscclustertemplates,verbs=create;update,versions=v1beta1,name=moscclustertemplate.kb.io,admissionReviewVersions=v1

var _ webhook.Defaulter = &amp;OscClusterTemplate{}

func (r *OscClusterTemplate) Default() <span class="cov0" title="0">{
        oscClusterTemplateLog.Info("default", "name", r.Name)

}</span>

// TODO(user): change verbs to "verbs=create;update;delete" if you want to enable deletion validation.
//+kubebuilder:webhook:path=/validate-infrastructure-cluster-x-k8s-io-v1beta1-oscclustertemplate,mutating=false,failurePolicy=fail,sideEffects=None,groups=infrastructure.cluster.x-k8s.io,resources=oscclustertemplates,verbs=create;update,versions=v1beta1,name=voscclustertemplate.kb.io,admissionReviewVersions=v1

var _ webhook.Validator = &amp;OscClusterTemplate{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (r *OscClusterTemplate) ValidateCreate() error <span class="cov8" title="1">{
        oscClusterTemplateLog.Info("validate create", "name", r.Name)
        if allErrs := ValidateOscClusterSpec(r.Spec.Template.Spec); len(allErrs) &gt; 0 </span><span class="cov8" title="1">{
                oscClusterTemplateLog.Info("validate error", "error", allErrs)
                return apierrors.NewInvalid(GroupVersion.WithKind("OscClusterTemplate").GroupKind(), r.Name, allErrs)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (r *OscClusterTemplate) ValidateUpdate(oldRaw runtime.Object) error <span class="cov8" title="1">{
        oscClusterTemplateLog.Info("validate update", "name", r.Name)
        var allErrs field.ErrorList
        old := oldRaw.(*OscClusterTemplate)
        if !reflect.DeepEqual(r.Spec.Template.Spec, old.Spec.Template.Spec) </span><span class="cov0" title="0">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("OscClusterTemplate", "spec", "template", "spec"), r, OscClusterTemplateImmutableMsg),
                )
        }</span>
        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">return apierrors.NewInvalid(GroupVersion.WithKind("OscClusterTemmplate").GroupKind(), r.Name, allErrs)</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (r *OscClusterTemplate) ValidateDelete() error <span class="cov0" title="0">{
        oscClusterTemplateLog.Info("validate delete", "name", r.Name)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/errors"
)

// OscMachineSpec defines the desired state of OscMachine
type OscMachineSpec struct {
        ProviderID *string `json:"providerID,omitempty"`
        Node       OscNode `json:"node,omitempty"`
}

// OscMachineStatus defines the observed state of OscMachine
type OscMachineStatus struct {
        Ready          bool                       `json:"ready,omitempty"`
        Addresses      []corev1.NodeAddress       `json:"addresses,omitempty"`
        FailureReason  *errors.MachineStatusError `json:"failureReason,omitempty"`
        VmState        *VmState                   `json:"vmState,omitempty"`
        Node           OscNodeResource            `json:"node,omitempty"`
        FailureMessage *string                    `json:"failureMessage,omitempty"`
        Conditions     clusterv1.Conditions       `json:"conditions,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

// OscMachine is the Schema for the oscmachines API
type OscMachine struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OscMachineSpec   `json:"spec,omitempty"`
        Status OscMachineStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// OscMachineList contains a list of OscMachine
type OscMachineList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OscMachine `json:"items"`
}

// GetConditions return status of the state of the machine resource
func (r *OscMachine) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return r.Status.Conditions
}</span>

// SetConditions set status of the state of the machine resource from machine
func (r *OscMachine) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        r.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OscMachine{}, &amp;OscMachineList{})
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "errors"
        "regexp"
        "strings"

        "k8s.io/apimachinery/pkg/util/validation/field"
)

const (
        minIops = 0
        maxIops = 13000
        minSize = 0
        maxSize = 14901
)

// ValidateOscMachineSpec validate each parameters of OscMachine spec
func ValidateOscMachineSpec(spec OscMachineSpec) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        if spec.Node.Vm.KeypairName != "" </span><span class="cov8" title="1">{
                if errs := ValidateAndReturnErrorList(spec.Node.Vm.KeypairName, field.NewPath("keypairName"), ValidateKeypairName); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, errs...)
                }</span>
        }
        <span class="cov8" title="1">if spec.Node.Vm.DeviceName != "" </span><span class="cov8" title="1">{
                if errs := ValidateAndReturnErrorList(spec.Node.Vm.DeviceName, field.NewPath("deviceName"), ValidateDeviceName); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, errs...)
                }</span>
        }
        <span class="cov8" title="1">if spec.Node.Vm.VmType != "" </span><span class="cov8" title="1">{
                if errs := ValidateAndReturnErrorList(spec.Node.Vm.VmType, field.NewPath("vmType"), ValidateVmType); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, errs...)
                }</span>
        }
        <span class="cov8" title="1">if spec.Node.Vm.SubregionName != "" </span><span class="cov0" title="0">{
                if errs := ValidateAndReturnErrorList(spec.Node.Vm.SubregionName, field.NewPath("subregionName"), ValidateSubregionName); len(errs) &gt; 0 </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, errs...)
                }</span>
        }
        <span class="cov8" title="1">if len(spec.Node.Volumes) != 0 </span><span class="cov8" title="1">{
                volumesSpec := spec.Node.Volumes
                for _, volumeSpec := range volumesSpec </span><span class="cov8" title="1">{
                        if volumeSpec.Iops != 0 </span><span class="cov8" title="1">{
                                if errs := ValidateAndReturnErrorList(volumeSpec.Iops, field.NewPath("iops"), ValidateIops); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                                        allErrs = append(allErrs, errs...)
                                }</span>
                        }

                        <span class="cov8" title="1">if volumeSpec.Size != 0 </span><span class="cov8" title="1">{
                                if errs := ValidateAndReturnErrorList(volumeSpec.Size, field.NewPath("size"), ValidateSize); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                                        allErrs = append(allErrs, errs...)
                                }</span>
                        }

                        <span class="cov8" title="1">if volumeSpec.VolumeType != "" </span><span class="cov8" title="1">{
                                if errs := ValidateAndReturnErrorList(volumeSpec.VolumeType, field.NewPath("volumeType"), ValidateVolumeType); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                                        allErrs = append(allErrs, errs...)
                                }</span>
                        }
                        <span class="cov8" title="1">if volumeSpec.Iops != 0 &amp;&amp; volumeSpec.Size != 0 &amp;&amp; volumeSpec.VolumeType == "io1" </span><span class="cov8" title="1">{
                                ratioIopsSize := volumeSpec.Iops / volumeSpec.Size
                                if errs := ValidateAndReturnErrorList(ratioIopsSize, field.NewPath("size"), ValidateRatioSizeIops); len(errs) &gt; 0 </span><span class="cov0" title="0">{
                                        allErrs = append(allErrs, errs...)
                                }</span>
                        }
                        <span class="cov8" title="1">if volumeSpec.SubregionName != "" </span><span class="cov8" title="1">{
                                if errs := ValidateAndReturnErrorList(volumeSpec.SubregionName, field.NewPath("subregionName"), ValidateSubregionName); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                                        allErrs = append(allErrs, errs...)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if spec.Node.Vm.RootDisk.RootDiskIops != 0 </span><span class="cov8" title="1">{
                if errs := ValidateAndReturnErrorList(spec.Node.Vm.RootDisk.RootDiskIops, field.NewPath("iops"), ValidateIops); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, errs...)
                }</span>
        }
        <span class="cov8" title="1">if spec.Node.Vm.RootDisk.RootDiskSize != 0 </span><span class="cov8" title="1">{
                if errs := ValidateAndReturnErrorList(spec.Node.Vm.RootDisk.RootDiskSize, field.NewPath("size"), ValidateSize); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, errs...)
                }</span>
        }
        <span class="cov8" title="1">if spec.Node.Vm.RootDisk.RootDiskType != "" </span><span class="cov8" title="1">{
                if errs := ValidateAndReturnErrorList(spec.Node.Vm.RootDisk.RootDiskType, field.NewPath("diskType"), ValidateVolumeType); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, errs...)
                }</span>
        }
        <span class="cov8" title="1">if spec.Node.Vm.RootDisk.RootDiskIops != 0 &amp;&amp; spec.Node.Vm.RootDisk.RootDiskSize != 0 &amp;&amp; spec.Node.Vm.RootDisk.RootDiskType == "io1" </span><span class="cov0" title="0">{
                ratioIopsSize := spec.Node.Vm.RootDisk.RootDiskIops / spec.Node.Vm.RootDisk.RootDiskSize
                if errs := ValidateAndReturnErrorList(ratioIopsSize, field.NewPath("size"), ValidateRatioSizeIops); len(errs) &gt; 0 </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, errs...)
                }</span>
        }
        <span class="cov8" title="1">return allErrs</span>
}

// ValidateKeypairName check that KeypairName is a valid name of keypair
func ValidateKeypairName(keypairName string) (string, error) <span class="cov8" title="1">{
        isValidateKeypairName := regexp.MustCompile("^[\x20-\x7E]{0,255}$").MatchString
        if isValidateKeypairName(keypairName) </span><span class="cov8" title="1">{
                return keypairName, nil
        }</span> else<span class="cov8" title="1"> {
                return keypairName, errors.New("Invalid KeypairName")
        }</span>
}

// ValidateImageId check that imageId is a valid imageId
func ValidateImageId(imageId string) (string, error) <span class="cov0" title="0">{
        switch </span>{
        case strings.HasPrefix(imageId, "ami"):<span class="cov0" title="0">
                return imageId, nil</span>
        default:<span class="cov0" title="0">
                return imageId, errors.New("Invalid imageId")</span>
        }
}

// ValidateRatioSizeIops check that Ratio iops size should not exceed 300
func ValidateRatioSizeIops(ratioIopsSize int32) (int32, error) <span class="cov8" title="1">{
        if ratioIopsSize &lt; 300 </span><span class="cov8" title="1">{
                return ratioIopsSize, nil
        }</span> else<span class="cov0" title="0"> {
                return ratioIopsSize, errors.New("Invalid ratio Iops size that exceed 300")
        }</span>

}

// ValidateIamegName check that Image name is a valide name
func ValidateImageName(imageName string) (string, error) <span class="cov0" title="0">{
        isValidateName := regexp.MustCompile(`^[0-9A-Za-z\-_\s\.\(\)\\]{0,255}$`).MatchString
        if isValidateName(imageName) </span><span class="cov0" title="0">{
                return imageName, nil
        }</span> else<span class="cov0" title="0"> {
                return imageName, errors.New("Invalid Image Name")
        }</span>
}

// ValidateIops check that iops is valid
func ValidateIops(iops int32) (int32, error) <span class="cov8" title="1">{
        if iops &lt; maxIops &amp;&amp; iops &gt; minIops </span><span class="cov8" title="1">{
                return iops, nil
        }</span> else<span class="cov8" title="1"> {
                return iops, errors.New("Invalid iops")
        }</span>
}

// ValidateSize check that size is valid
func ValidateSize(size int32) (int32, error) <span class="cov8" title="1">{
        if size &lt; maxSize &amp;&amp; size &gt; minSize </span><span class="cov8" title="1">{
                return size, nil
        }</span> else<span class="cov8" title="1"> {
                return size, errors.New("Invalid size")
        }</span>
}

// ValidateVolumeType check that volumeType is a valid volumeType
func ValidateVolumeType(volumeType string) (string, error) <span class="cov8" title="1">{
        switch volumeType </span>{
        case "standard", "gp2", "io1":<span class="cov8" title="1">
                return volumeType, nil</span>
        default:<span class="cov8" title="1">
                return volumeType, errors.New("Invalid volumeType")</span>
        }
}

// ValidateSubregionName check that subregionName is a valid az format
func ValidateSubregionName(subregionName string) (string, error) <span class="cov8" title="1">{
        switch </span>{
        case strings.HasSuffix(subregionName, "1a") || strings.HasSuffix(subregionName, "1b") || strings.HasSuffix(subregionName, "2a") || strings.HasSuffix(subregionName, "2b"):<span class="cov8" title="1">
                return subregionName, nil</span>
        default:<span class="cov8" title="1">
                return subregionName, errors.New("Invalid subregionName")</span>
        }
}

// ValidateDeviceName check that DeviceName  is a valid DeviceName
func ValidateDeviceName(deviceName string) (string, error) <span class="cov8" title="1">{
        isValidateDeviceName := regexp.MustCompile(`^(\/dev\/sda1|\/dev\/sd[a-z]{1}|\/dev\/xvd[a-z]{1})$`).MatchString
        switch </span>{
        case isValidateDeviceName(deviceName):<span class="cov8" title="1">
                return deviceName, nil</span>
        default:<span class="cov8" title="1">
                return deviceName, errors.New("Invalid deviceName")</span>
        }
}

// ValidateVmType check that vmType is a valid vmType
func ValidateVmType(vmType string) (string, error) <span class="cov8" title="1">{
        isValidateVmType := regexp.MustCompile(`^tinav[3-6].c[0-9]+r[0-9]+p[1-3]$`).MatchString
        switch </span>{
        case isValidateVmType(vmType):<span class="cov8" title="1">
                return vmType, nil</span>
        default:<span class="cov8" title="1">
                return vmType, errors.New("Invalid vmType")</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "reflect"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        "k8s.io/apimachinery/pkg/util/validation/field"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
)

var oscMachineLog = logf.Log.WithName("oscmachine-resource")

func (r *OscMachine) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewWebhookManagedBy(mgr).For(r).Complete()
}</span>

//+kubebuilder:webhook:path=/mutate-infrastructure-cluster-x-k8s-io-v1beta1-oscmachine,mutating=true,failurePolicy=fail,sideEffects=None,groups=infrastructure.cluster.x-k8s.io,resources=oscmachines,verbs=create;update,versions=v1beta1,name=moscmachine.kb.io,admissionReviewVersions=v1

var _ webhook.Defaulter = &amp;OscMachine{}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (m *OscMachine) Default() <span class="cov0" title="0">{
        oscMachineLog.Info("default", "name", m.Name)

}</span>

//+kubebuilder:webhook:path=/validate-infrastructure-cluster-x-k8s-io-v1beta1-oscmachine,mutating=false,failurePolicy=fail,sideEffects=None,groups=infrastructure.cluster.x-k8s.io,resources=oscmachines,verbs=create;update,versions=v1beta1,name=voscmachine.kb.io,admissionReviewVersions=v1

var _ webhook.Validator = &amp;OscMachine{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (m *OscMachine) ValidateCreate() error <span class="cov8" title="1">{
        oscMachineLog.Info("validate create", "name", m.Name)
        if allErrs := ValidateOscMachineSpec(m.Spec); len(allErrs) &gt; 0 </span><span class="cov8" title="1">{
                oscMachineLog.Info("validate error", "error", allErrs)
                return apierrors.NewInvalid(GroupVersion.WithKind("OscMachine").GroupKind(), m.Name, allErrs)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (m *OscMachine) ValidateUpdate(oldRaw runtime.Object) error <span class="cov8" title="1">{
        oscMachineLog.Info("validate update", "name", m.Name)
        var allErrs field.ErrorList
        old := oldRaw.(*OscMachine)

        oscMachineLog.Info("validate update old vmType", "old vmType", old.Spec.Node.Vm.VmType)
        oscMachineLog.Info("validate update vmType", "vmType", m.Spec.Node.Vm.VmType)

        if !reflect.DeepEqual(m.Spec.Node.Vm.VmType, old.Spec.Node.Vm.VmType) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "vmType"),
                                m.Spec.Node.Vm.VmType, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">oscMachineLog.Info("validate update old keypairName", "old keypairName", old.Spec.Node.Vm.KeypairName)
        oscMachineLog.Info("validate update keyPairName", "keypairName", m.Spec.Node.Vm.KeypairName)

        if !reflect.DeepEqual(m.Spec.Node.Vm.KeypairName, old.Spec.Node.Vm.KeypairName) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "keyPairName"),
                                m.Spec.Node.Vm.KeypairName, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">oscMachineLog.Info("validate update old loadBalancerName", "old loadBalancerName", old.Spec.Node.Vm.LoadBalancerName)
        oscMachineLog.Info("validate update loadBalancerName", "loadBalancerName", m.Spec.Node.Vm.LoadBalancerName)

        if !reflect.DeepEqual(m.Spec.Node.Vm.LoadBalancerName, old.Spec.Node.Vm.LoadBalancerName) </span><span class="cov0" title="0">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "loadBalancerName"),
                                m.Spec.Node.Vm.LoadBalancerName, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">oscMachineLog.Info("validate update old subregionName", "old subregionName", old.Spec.Node.Vm.SubregionName)
        oscMachineLog.Info("validate update subregionName", "subregionName", m.Spec.Node.Vm.SubregionName)

        if !reflect.DeepEqual(m.Spec.Node.Vm.SubregionName, old.Spec.Node.Vm.SubregionName) </span><span class="cov0" title="0">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "subregionName"),
                                m.Spec.Node.Vm.SubregionName, "field is immutable"),
                )
        }</span>
        <span class="cov8" title="1">oscMachineLog.Info("validate update old rootDiskSize", "old rootDiskSize", old.Spec.Node.Vm.RootDisk.RootDiskSize)
        oscMachineLog.Info("validate update rootDiskSize", "rootDiskSize", m.Spec.Node.Vm.RootDisk.RootDiskSize)

        if !reflect.DeepEqual(m.Spec.Node.Vm.RootDisk.RootDiskSize, old.Spec.Node.Vm.RootDisk.RootDiskSize) </span><span class="cov0" title="0">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "rootDiskSize"),
                                m.Spec.Node.Vm.RootDisk.RootDiskSize, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">oscMachineLog.Info("validate update of old rootDiskIops", "old rootDiskIops", old.Spec.Node.Vm.RootDisk.RootDiskIops)
        oscMachineLog.Info("validate update rootDiskIops", "old rootDiskIops", m.Spec.Node.Vm.RootDisk.RootDiskIops)
        if !reflect.DeepEqual(m.Spec.Node.Vm.RootDisk.RootDiskIops, old.Spec.Node.Vm.RootDisk.RootDiskIops) </span><span class="cov0" title="0">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "rootDiskIops"),
                                m.Spec.Node.Vm.RootDisk.RootDiskIops, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">oscMachineLog.Info("validate update of old rootDiskTyp", "old rootDisktype", old.Spec.Node.Vm.RootDisk.RootDiskType)
        oscMachineLog.Info("validate update rootDiskType", "old rootDiskType", m.Spec.Node.Vm.RootDisk.RootDiskType)
        if !reflect.DeepEqual(m.Spec.Node.Vm.RootDisk.RootDiskType, old.Spec.Node.Vm.RootDisk.RootDiskType) </span><span class="cov0" title="0">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "rootDiskTyp"),
                                m.Spec.Node.Vm.RootDisk.RootDiskType, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return apierrors.NewInvalid(GroupVersion.WithKind("OscMachine").GroupKind(), m.Name, allErrs)</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (m *OscMachine) ValidateDelete() error <span class="cov0" title="0">{
        oscMachineLog.Info("validate delete", "name", m.Name)

        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

// OscMachineTemplateSpec define oscMachine template
type OscMachineTemplateSpec struct {
        Template OscMachineTemplateResource `json:"template"`
}

type OscMachineTemplateStatus struct {
        Capacity   corev1.ResourceList  `json:"capacity,omitempty"`
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`
}

// +kubebuilder:subresource:status
// +kubebuilder:object:root=true
// +kubebuilder:resource:path=oscmachinetemplates,scope=Namespaced,categories=cluster-api
// +kubebuilder:storageversion

// OscMachineTemplate is the Schema for the OscMachineTemplate API
type OscMachineTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OscMachineTemplateSpec   `json:"spec,omitempty"`
        Status OscMachineTemplateStatus `json:"status,omitempty"`
}

// OscMachineTemplateList contains a list of OscMachineTemplate
// +kubebuilder:object:root=true
type OscMachineTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitemmpty"`
        Items           []OscMachineTemplate `json:"items"`
}

// OscMachineTemplateResource is the Schema for the OscMachineTemplate api
type OscMachineTemplateResource struct {
        ObjectMeta clusterv1.ObjectMeta `json:"metadata,omitempty"`
        Spec       OscMachineSpec       `json:"spec"`
}

func (m *OscMachineTemplate) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return m.Status.Conditions
}</span>

func (m *OscMachineTemplate) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        m.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;OscMachineTemplate{}, &amp;OscMachineTemplateList{})
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/util/validation/field"
        "reflect"

        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
)

const (
        OscMachineTemplateImmutableMsg = "OscMachineTemplate spec.template.spec field is immutable."
)

var oscMachineTemplateLog = logf.Log.WithName("oscmachinetemplate-resource")

func (m *OscMachineTemplate) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewWebhookManagedBy(mgr).For(m).Complete()
}</span>

//+kubebuilder:webhook:path=/mutate-infrastructure-cluster-x-k8s-io-v1beta1-oscmachinetemplate,mutating=true,failurePolicy=fail,sideEffects=None,groups=infrastructure.cluster.x-k8s.io,resources=oscmachinetemplates,verbs=create;update,versions=v1beta1,name=moscmachinetemplate.kb.io,admissionReviewVersions=v1

var _ webhook.Defaulter = &amp;OscMachineTemplate{}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (m *OscMachineTemplate) Default() <span class="cov0" title="0">{
        oscMachineTemplateLog.Info("default", "name", m.Name)
}</span>

// TODO(user): change verbs to "verbs=create;update;delete" if you want to enable deletion validation.
//+kubebuilder:webhook:path=/validate-infrastructure-cluster-x-k8s-io-v1beta1-oscmachinetemplate,mutating=false,failurePolicy=fail,sideEffects=None,groups=infrastructure.cluster.x-k8s.io,resources=oscmachinetemplates,verbs=create;update,versions=v1beta1,name=voscmachinetemplate.kb.io,admissionReviewVersions=v1

var _ webhook.Validator = &amp;OscMachineTemplate{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (m *OscMachineTemplate) ValidateCreate() error <span class="cov8" title="1">{
        oscMachineTemplateLog.Info("validate create", "name", m.Name)
        if allErrs := ValidateOscMachineSpec(m.Spec.Template.Spec); len(allErrs) &gt; 0 </span><span class="cov8" title="1">{
                oscMachineTemplateLog.Info("validate error", "error", allErrs)
                return apierrors.NewInvalid(GroupVersion.WithKind("OscMachine").GroupKind(), m.Name, allErrs)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (m *OscMachineTemplate) ValidateUpdate(oldRaw runtime.Object) error <span class="cov8" title="1">{
        oscMachineTemplateLog.Info("validate update", "name", m.Name)
        var allErrs field.ErrorList
        old := oldRaw.(*OscMachineTemplate)
        if !reflect.DeepEqual(m.Spec.Template.Spec, old.Spec.Template.Spec) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("OscMachineTemplate", "spec", "template", "spec"), m, OscMachineTemplateImmutableMsg),
                )
        }</span>
        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return apierrors.NewInvalid(GroupVersion.WithKind("OscMachineTemplate").GroupKind(), m.Name, allErrs)</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (m *OscMachineTemplate) ValidateDelete() error <span class="cov0" title="0">{
        oscMachineTemplateLog.Info("validate delete", "name", m.Name)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "fmt"
)

const (
        NameOutscaleProviderPrefix = "capo-"
        NameOutscaleProvider       = NameOutscaleProviderPrefix + "cluster-"
        APIServerRoleTagValue      = "apiserver"
        NodeRoleTagValue           = "node"
)

// ClusterTagKey add cluster tag key
func ClusterTagKey(name string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", NameOutscaleProvider, name)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        base64 "encoding/base64"
        "log"
        "strings"

        "golang.org/x/crypto/ssh"
)

type OscNode struct {
        Vm          OscVm        `json:"vm,omitempty"`
        Image       OscImage     `json:"image,omitempty"`
        Volumes     []*OscVolume `json:"volumes,omitempty"`
        KeyPair     OscKeypair   `json:"keypair,omitempty"`
        ClusterName string       `json:"clusterName,omitempty"`
}

type OscNetwork struct {
        // The Load Balancer configuration
        // +optional
        LoadBalancer OscLoadBalancer `json:"loadBalancer,omitempty"`
        // The Net configuration
        // +optional
        Net OscNet `json:"net,omitempty"`
        // The Subnet configuration
        // +optional
        Subnets []*OscSubnet `json:"subnets,omitempty"`
        // The Internet Service configuration
        // +optional
        InternetService OscInternetService `json:"internetService,omitempty"`
        // The Nat Service configuration
        // +optional
        NatService OscNatService `json:"natService,omitempty"`
        // The Route Table configuration
        // +optional
        RouteTables    []*OscRouteTable    `json:"routeTables,omitempty"`
        SecurityGroups []*OscSecurityGroup `json:"securityGroups,omitempty"`
        // The Public Ip configuration
        // +optional
        PublicIps []*OscPublicIp `json:"publicIps,omitempty"`
        // The name of the cluster
        // +optional
        ClusterName string `json:"clusterName,omitempty"`
        // The image configuration
        // +optional
        Image OscImage `json:"image,omitempty"`
        // The bastion configuration
        // + optional
        Bastion OscBastion `json:"bastion,omitempty"`
        // The subregion name
        // + optional
        SubregionName string `json:"subregionName,omitempty"`
}

type OscLoadBalancer struct {
        // The Load Balancer unique name
        // +optional
        LoadBalancerName string `json:"loadbalancername,omitempty"`
        // The Load Balancer Type internet-facing or internal
        // +optional
        LoadBalancerType string `json:"loadbalancertype,omitempty"`
        // The subnet tag name associate with a Subnet
        // +optional
        SubnetName string `json:"subnetname,omitempty"`
        // The security group tag name associate with a security group
        // +optional
        SecurityGroupName string `json:"securitygroupname,omitempty"`
        // The Listener cofiguration of the loadBalancer
        // +optional
        Listener OscLoadBalancerListener `json:"listener,omitempty"`
        // The healthCheck configuration  of the Load Balancer
        // +optional
        HealthCheck OscLoadBalancerHealthCheck `json:"healthCheck,omitempty"`
        ClusterName string                     `json:"clusterName,omitempty"`
}

type OscLoadBalancerListener struct {
        // The port on which the backend vm will listen
        // +optional
        BackendPort int32 `json:"backendport,omitempty"`
        // The protocol ('HTTP'|'TCP') to route the traffic to the backend vm
        // +optional
        BackendProtocol string `json:"backendprotocol,omitempty"`
        // The port on which the loadbalancer will listen
        // +optional
        LoadBalancerPort int32 `json:"loadbalancerport,omitempty"`
        // the routing protocol ('HTTP'|'TCP')
        // +optional
        LoadBalancerProtocol string `json:"loadbalancerprotocol,omiempty"`
}

type OscLoadBalancerHealthCheck struct {
        // the time in second between two pings
        // +optional
        CheckInterval int32 `json:"checkinterval,omitempty"`
        // the consecutive number of pings which are sucessful to consider the vm healthy
        // +optional
        HealthyThreshold int32 `json:"healthythreshold,omitempty"`
        // the HealthCheck port number
        // +optional
        Port int32 `json:"port,omitempty"`
        // The HealthCheck protocol ('HTTP'|'TCP')
        // +optional
        Protocol string `json:"protocol,omitepty"`
        // the Timeout to consider VM unhealthy
        // +optional
        Timeout int32 `json:"timeout,omitempty"`
        // the consecutive number of pings which are failed to consider the vm unhealthy
        // +optional
        UnhealthyThreshold int32 `json:"unhealthythreshold,omitempty"`
}

type OscNet struct {
        // the tag name associate with the Net
        // +optional
        Name string `json:"name,omitempty"`
        // the net ip range with CIDR notation
        // +optional
        IpRange string `json:"ipRange,omitempty"`
        // the name of the cluster
        // +optional
        ClusterName string `json:"clusterName,omitempty"`
        // The Net Id response
        // +optional
        ResourceId string `json:"resourceId,omitempty"`
}

type OscInternetService struct {
        // The tag name associate with the Subnet
        // +optional
        Name string `json:"name,omitempty"`
        // the name of the cluster
        // +optional
        ClusterName string `json:"clusterName,omitempty"`
        // the Internet Service response
        // +optional
        ResourceId string `json:"resourceId,omitempty"`
}

type OscSubnet struct {
        // The tag name associate with the Subnet
        // +optional
        Name string `json:"name,omitempty"`
        // Subnet Ip range with CIDR notation
        // +optional
        IpSubnetRange string `json:"ipSubnetRange,omitempty"`
        // The subregion name of the Subnet
        // +optional
        SubregionName string `json:"subregionName,omitempty"`
        // The Subnet Id response
        // +optional
        ResourceId string `json:"resourceId,omitempty"`
}

type OscNatService struct {
        // The tag name associate with the Nat Service
        // +optional
        Name string `json:"name,omitempty"`
        // The Public Ip tag name associated wtih a Public Ip
        // +optional
        PublicIpName string `json:"publicipname,omitempty"`
        // The subnet tag name associate with a Subnet
        // +optional
        SubnetName string `json:"subnetname,omitempty"`
        // The name of the cluster
        // +optional
        ClusterName string `json:"clusterName,omitempty"`
        // The Nat Service Id response
        // +optional
        ResourceId string `json:"resourceId,omitempty"`
}

type OscRouteTable struct {
        // The tag name associate with the Route Table
        // +optional
        Name string `json:"name,omitempty"`
        // The subnet tag name associate with a Subnet
        Subnets []string `json:"subnets,omitempty"`
        // The Route configuration
        // +optional
        Routes []OscRoute `json:"routes,omitempty"`
        // The Route Table Id response
        // +optional
        ResourceId string `json:"resourceId,omitempty"`
}

type OscSecurityGroup struct {
        // The tag name associate with the security group
        // +optional
        Name string `json:"name,omitempty"`
        // The description of the security group
        // +optional
        Description string `json:"description,omitempty"`
        // The Security Group Rules configuration
        // +optional
        SecurityGroupRules []OscSecurityGroupRule `json:"securityGroupRules,omitempty"`
        // The Security Group Id response
        // +optional
        ResourceId string `json:"resourceId,omitempty"`
        Tag        string `json:"tag,omitempty"`
}

type OscPublicIp struct {
        // The tag name associate with the Public Ip
        // +optional
        Name string `json:"name,omitempty"`
        // The Public Ip Id response
        // +optional
        ResourceId  string `json:"resourceId,omitempty"`
        ClusterName string `json:"clusterName,omitempty"`
}

type OscRoute struct {
        // The tag name associate with the Route
        // +optional
        Name string `json:"name,omitempty"`
        // The tag name associate with the target resource type
        // +optional
        TargetName string `json:"targetName,omitempty"`
        // The target resource type which can be Internet Service (gateway) or Nat Service (nat-service)
        // +optional
        TargetType string `json:"targetType,omitempty"`
        // the destination match Ip range with CIDR notation
        // +optional
        Destination string `json:"destination,omitempty"`
        // The Route Id response
        // +optional
        ResourceId string `json:"resourceId,omitempty"`
}

type OscPrivateIpElement struct {
        Name      string `json:"name,omitempty"`
        PrivateIp string `json:"privateIp,omiteempty"`
}

type OscSecurityGroupElement struct {
        Name string `json:"name,omitempty"`
}

type OscSecurityGroupRule struct {
        // The tag name associate with the security group
        // +optional
        Name string `json:"name,omitempty"`
        // The flow of the security group (inbound or outbound)
        // +optional
        Flow string `json:"flow,omitempty"`
        // The ip protocol name (tcp, udp, icmp or -1)
        // +optional
        IpProtocol string `json:"ipProtocol,omitempty"`
        // The ip range of the security group rule
        // +optional
        IpRange string `json:"ipRange,omitempty"`
        // The beginning of the port range
        // +optional
        FromPortRange int32 `json:"fromPortRange,omitempty"`
        // The end of the port range
        // +optional
        ToPortRange int32 `json:"toPortRange,omitempty"`
        // The security group rule id
        // +optional
        ResourceId string `json:"resourceId,omitempty"`
}

// Map between resourceId and resourceName (tag Name with cluster UID)
type OscResourceReference struct {
        ResourceMap map[string]string `json:"resourceMap,omitempty"`
}

type OscNetworkResource struct {
        // Map between LoadbalancerId  and LoadbalancerName (Load Balancer tag Name with cluster UID)
        LoadbalancerRef OscResourceReference `json:"LoadbalancerRef,omitempty"`
        // Map between NetId  and NetName (Net tag Name with cluster UID)
        NetRef OscResourceReference `json:"netref,omitempty"`
        // Map between SubnetId  and SubnetName (Subnet tag Name with cluster UID)
        SubnetRef OscResourceReference `json:"subnetref,omitempty"`
        // Map between InternetServiceId  and InternetServiceName (Internet Service tag Name with cluster UID)
        InternetServiceRef OscResourceReference `json:"internetserviceref,omitempty"`
        // Map between RouteTablesId  and RouteTablesName (Route Tables tag Name with cluster UID)
        RouteTablesRef OscResourceReference `json:"routetableref,omitempty"`
        // Map between LinkRouteTableId and RouteTablesName (Route Table tag Name with cluster UID)
        LinkRouteTableRef map[string][]string `json:"linkroutetableref,omitempty"`
        // Map between RouteId  and RouteName (Route tag Name with cluster UID)
        RouteRef OscResourceReference `json:"routeref,omitempty"`
        // Map between SecurityGroupId  and SecurityGroupName (Security Group tag Name with cluster UID)
        SecurityGroupsRef OscResourceReference `json:"securitygroupref,omitempty"`
        // Map between SecurityGroupRuleId  and SecurityGroupName (Security Group Rule tag Name with cluster UID)
        SecurityGroupRuleRef OscResourceReference `json:"securitygroupruleref,omitempty"`
        // Map between PublicIpId  and PublicIpName (Public IP tag Name with cluster UID)
        PublicIpRef OscResourceReference `json:"publicipref,omitempty"`
        // Map between NatServiceId  and NatServiceName (Nat Service tag Name with cluster UID)
        NatServiceRef OscResourceReference `json:"natref,omitempty"`
        // Map between InstanceId  and BastionName (Bastion tag Name with cluster UID)
        BastionRef OscResourceReference `json:"bastionref,omitempty"`
        // Map between LinkPublicIpId  and PublicIpName (Public IP tag Name with cluster UID)
        LinkPublicIpRef OscResourceReference `json:"linkPublicIpRef,omitempty"`
}

type OscNodeResource struct {
        VolumeRef       OscResourceReference `json:"volumeRef,omitempty"`
        ImageRef        OscResourceReference `json:"imageRef,omitempty"`
        KeypairRef      OscResourceReference `json:"keypairRef,omitempty"`
        VmRef           OscResourceReference `json:"vmRef,omitempty"`
        LinkPublicIpRef OscResourceReference `json:"linkPublicIpRef,omitempty"`
}

type OscImage struct {
        Name       string `json:"name,omitempty"`
        ResourceId string `json:"resourceId,omitempty"`
}

type OscVolume struct {
        Name          string `json:"name,omitempty"`
        Iops          int32  `json:"iops,omitempty"`
        Size          int32  `json:"size,omitempty"`
        SubregionName string `json:"subregionName,omitempty"`
        VolumeType    string `json:"volumeType,omitempty"`
        ResourceId    string `json:"resourceId,omitempty"`
}

type OscKeypair struct {
        Name          string `json:"name,omitempty"`
        PublicKey     string `json:"publicKey,omitempty"`
        ResourceId    string `json:"resourceId,omitempty"`
        ClusterName   string `json:"clusterName,omitempty"`
        DeleteKeypair bool   `json:"deleteKeypair,omitempty"`
}

type OscVm struct {
        Name               string                    `json:"name,omitempty"`
        ImageId            string                    `json:"imageId,omitempty"`
        KeypairName        string                    `json:"keypairName,omitempty"`
        VmType             string                    `json:"vmType,omitempty"`
        VolumeName         string                    `json:"volumeName,omitempty"`
        VolumeDeviceName   string                    `json:"volumeDeviceName,omitempty"`
        DeviceName         string                    `json:"deviceName,omitempty"`
        SubnetName         string                    `json:"subnetName,omitempty"`
        RootDisk           OscRootDisk               `json:"rootDisk,omitempty"`
        LoadBalancerName   string                    `json:"loadBalancerName,omitempty"`
        PublicIpName       string                    `json:"publicIpName,omitempty"`
        SubregionName      string                    `json:"subregionName,omitempty"`
        PrivateIps         []OscPrivateIpElement     `json:"privateIps,omitempty"`
        SecurityGroupNames []OscSecurityGroupElement `json:"securityGroupNames,omitempty"`
        ResourceId         string                    `json:"resourceId,omitempty"`
        Role               string                    `json:"role,omitempty"`
        ClusterName        string                    `json:"clusterName,omitempty"`
        Replica            int32                     `json:"replica,omitempty"`
}

type OscBastion struct {
        Name               string                    `json:"name,omitempty"`
        ImageId            string                    `json:"imageId,omitempty"`
        ImageName          string                    `json:"imageName,omitempty"`
        KeypairName        string                    `json:"keypairName,omitempty"`
        VmType             string                    `json:"vmType,omitempty"`
        DeviceName         string                    `json:"deviceName,omitempty"`
        SubnetName         string                    `json:"subnetName,omitempty"`
        RootDisk           OscRootDisk               `json:"rootDisk,omitempty"`
        PublicIpName       string                    `json:"publicIpName,omitempty"`
        SubregionName      string                    `json:"subregionName,omitempty"`
        PrivateIps         []OscPrivateIpElement     `json:"privateIps,omitempty"`
        SecurityGroupNames []OscSecurityGroupElement `json:"securityGroupNames,omitempty"`
        ResourceId         string                    `json:"resourceId,omitempty"`
        ClusterName        string                    `json:"clusterName,omitempty"`
        Enable             bool                      `json:"enable,omitempty"`
}

type OscRootDisk struct {
        RootDiskIops int32  `json:"rootDiskIops,omitempty"`
        RootDiskSize int32  `json:"rootDiskSize,omitempty"`
        RootDiskType string `json:"rootDiskType,omitempty"`
}

type VmState string

var (
        VmStatePending      = VmState("pending")
        VmStateRunning      = VmState("running")
        VmStateShuttingDown = VmState("shutting-down")
        VmStateTerminated   = VmState("terminated")
        VmStateStopping     = VmState("stopping")
        VmStateStopped      = VmState("stopped")

        DefaultClusterName string = "cluster-api"

        DefaultKeypairName string = "cluster-api-keypair"

        DefaultVmName          string = "cluster-api-vm"
        DefaultVmSubregionName string = "eu-west-2a"
        DefaultVmImageId       string = "ami-e1a786f1"

        DefaultVmKeypairName string = "cluster-api"
        DefaultVmType        string = "tinav3.c4r8p1"
        DefaultVmDeviceName  string = "/dev/sda1"

        DefaultVmBastionImageId       string = "ami-bb490c7e"
        DefaultVmBastionKeypairName   string = "cluster-api"
        DefaultVmBastionSubregionName string = "eu-west-2a"

        DefaultVmKwName               string = "cluster-api-vm-kw"
        DefaultVmKwType               string = "tinav3.c4r8p1"
        DefaultVmKcpName              string = "cluster-api-vm-kcp"
        DefaultVmKcpType              string = "tinav3.c4r8p1"
        DefaultVmBastionName          string = "cluster-api-vm-bastion"
        DefaultVmBastionType          string = "tinav3.c2r2p1"
        DefaultVolumeKcpName          string = "cluster-api-volume-kcp"
        DefaultVolumeKcpIops          int32  = 1000
        DefaultVolumeKcpSize          int32  = 30
        DefaultVolumeKcpSubregionName string = "eu-west-2a"
        DefaultVolumeKcpType          string = "io1"

        DefaultRootDiskKwType string = "io1"
        DefaultRootDiskKwSize int32  = 60
        DefaultRootDiskKwIops int32  = 1500

        DefaultRootDiskKcpType                      string = "io1"
        DefaultRootDiskKcpSize                      int32  = 60
        DefaultRootDiskKcpIops                      int32  = 1500
        DefaultRootDiskBastionType                  string = "io1"
        DefaultRootDiskBastionSize                  int32  = 15
        DefaultRootDiskBastionIops                  int32  = 1000
        DefaultVolumeKwName                         string = "cluster-api-volume-kw"
        DefaultVolumeKwIops                         int32  = 1000
        DefaultVolumeKwSize                         int32  = 30
        DefaultVolumeKwSubregionName                string = "eu-west-2a"
        DefaultVolumeKwType                         string = "io1"
        DefaultSubregionName                        string = "eu-west-2a"
        DefaultLoadBalancerName                     string = "OscClusterApi-1"
        DefaultLoadBalancerType                     string = "internet-facing"
        DefaultBackendPort                          int32  = 6443
        DefaultBackendProtocol                      string = "TCP"
        DefaultLoadBalancerPort                     int32  = 6443
        DefaultLoadBalancerProtocol                 string = "TCP"
        DefaultCheckInterval                        int32  = 5
        DefaultHealthyThreshold                     int32  = 5
        DefaultUnhealthyThreshold                   int32  = 2
        DefaultTimeout                              int32  = 5
        DefaultProtocol                             string = "TCP"
        DefaultPort                                 int32  = 6443
        DefaultIpRange                              string = "10.0.0.0/16"
        DefaultIpSubnetKcpRange                     string = "10.0.4.0/24"
        DefaultIpSubnetKwRange                      string = "10.0.3.0/24"
        DefaultIpSubnetPublicRange                  string = "10.0.2.0/24"
        DefaultTargetType                           string = "gateway"
        DefaultTargetKwName                         string = "cluster-api-natservice"
        DefaultTargetKwType                         string = "nat"
        DefaultDestinationKw                        string = "0.0.0.0/0"
        DefaultRouteTableKwName                     string = "cluster-api-routetable-kw"
        DefaultRouteKwName                          string = "cluster-api-route-kw"
        DefaultTargetKcpName                        string = "cluster-api-natservice"
        DefaultTargetKcpType                        string = "nat"
        DefaultDestinationKcp                       string = "0.0.0.0/0"
        DefaultRouteTableKcpName                    string = "cluster-api-routetable-kcp"
        DefaultRouteKcpName                         string = "cluster-api-route-kcp"
        DefaultTargetPublicName                     string = "cluster-api-internetservice"
        DefaultTargetPublicType                     string = "gateway"
        DefaultDestinationPublic                    string = "0.0.0.0/0"
        DefaultRouteTablePublicName                 string = "cluster-api-routetable-public"
        DefaultRoutePublicName                      string = "cluster-api-route-public"
        DefaultTargetNatName                        string = "cluster-api-internetservice"
        DefaultTargetNatType                        string = "gateway"
        DefaultDestinationNat                       string = "0.0.0.0/0"
        DefaultRouteTableNatName                    string = "cluster-api-routetable-nat"
        DefaultRouteNatName                         string = "cluster-api-route-nat"
        DefaultPublicIpNatName                      string = "cluster-api-publicip-nat"
        DefaultNatServiceName                       string = "cluster-api-natservice"
        DefaultSubnetName                           string = "cluster-api-subnet"
        DefaultSubnetKcpName                        string = "cluster-api-subnet-kcp"
        DefaultSubnetKwName                         string = "cluster-api-subnet-kw"
        DefaultSubnetPublicName                     string = "cluster-api-subnet-public"
        DefaultSubnetNatName                        string = "cluster-api-subnet-nat"
        DefaultNetName                              string = "cluster-api-net"
        DefaultInternetServiceName                  string = "cluster-api-internetservice"
        DefaultSecurityGroupKwName                  string = "cluster-api-securitygroup-kw"
        DefaultDescriptionKw                        string = "Security Group Kw with cluster-api"
        DefaultSecurityGroupRuleApiKubeletKwName    string = "cluster-api-securitygrouprule-api-kubelet-kw"
        DefaultFlowApiKubeletKw                     string = "Inbound"
        DefaultIpProtocolApiKubeletKw               string = "tcp"
        DefaultRuleIpRangeApiKubeletKw              string = "10.0.3.0/24"
        DefaultFromPortRangeApiKubeletKw            int32  = 10250
        DefaultToPortRangeApiKubeletKw              int32  = 10250
        DefaultSecurityGroupRuleApiKubeletKcpName   string = "cluster-api-securitygrouprule-api-kubelet-kcp"
        DefaultFlowApiKubeletKcp                    string = "Inbound"
        DefaultIpProtocolApiKubeletKcp              string = "tcp"
        DefaultRuleIpRangeApiKubeletKcp             string = "10.0.4.0/24"
        DefaultFromPortRangeApiKubeletKcp           int32  = 10250
        DefaultToPortRangeApiKubeletKcp             int32  = 10250
        DefaultSecurityGroupRuleKwNodeIpKwName      string = "cluster-api-securitygrouprule-kw-nodeip-kw"
        DefaultSecurityGroupRuleKcpNodeIpKwName     string = "cluster-api-securitygrouprule-kcp-nodeip-kw"
        DefaultFlowNodeIpKw                         string = "Inbound"
        DefaultIpProtocolNodeIpKw                   string = "tcp"
        DefaultRuleIpRangeNodeIpKw                  string = "10.0.3.0/24"
        DefaultFromPortRangeNodeIpKw                int32  = 30000
        DefaultToPortRangeNodeIpKw                  int32  = 32767
        DefaultSecurityGroupRuleKcpNodeIpKcpName    string = "cluster-api-securitugrouprule-kcp-nodeip-kcp"
        DefaultSecurityGroupRuleKwNodeIpKcpName     string = "cluster-api-securitygrouprule-kw-nodeip-kcp"
        DefaultFlowNodeIpKcp                        string = "Inbound"
        DefaultIpProtocolNodeIpKcp                  string = "tcp"
        DefaultRuleIpRangeNodeIpKcp                 string = "10.0.4.0/24"
        DefaultFromPortRangeNodeIpKcp               int32  = 30000
        DefaultToPortRangeNodeIpKcp                 int32  = 32767
        DefaultSecurityGroupKcpName                 string = "cluster-api-securitygroup-kcp"
        DefaultDescriptionKcp                       string = "Security Group Kcp with cluster-api"
        DefaultSecurityGroupRuleApiKwName           string = "cluster-api-securitygrouprule-api-kw"
        DefaultFlowApiKw                            string = "Inbound"
        DefaultIpProtocolApiKw                      string = "tcp"
        DefaultRuleIpRangeApiKw                     string = "10.0.3.0/24"
        DefaultFromPortRangeApiKw                   int32  = 6443
        DefaultToPortRangeApiKw                     int32  = 6443
        DefaultSecurityGroupRuleApiKcpName          string = "cluster-api-securitygrouprule-api-kcp"
        DefaultFlowApiKcp                           string = "Inbound"
        DefaultIpProtocolApiKcp                     string = "tcp"
        DefaultRuleIpRangeApiKcp                    string = "10.0.4.0/24"
        DefaultFromPortRangeApiKcp                  int32  = 6443
        DefaultToPortRangeApiKcp                    int32  = 6443
        DefaultSecurityGroupRuleEtcdName            string = "cluster-api-securitygrouprule-etcd"
        DefaultFlowEtcd                             string = "Inbound"
        DefaultIpProtocolEtcd                       string = "tcp"
        DefaultRuleIpRangeEtcd                      string = "10.0.4.0/24"
        DefaultFromPortRangeEtcd                    int32  = 2378
        DefaultToPortRangeEtcd                      int32  = 2379
        DefaultSecurityGroupRuleKcpBgpName          string = "cluster-api-securitygrouprule-kcp-bgp"
        DefaultFlowKcpBgp                           string = "Inbound"
        DefaultIpProtocolKcpBgp                     string = "tcp"
        DefaultRuleIpRangeKcpBgp                    string = "10.0.0.0/16"
        DefaultFromPortRangeKcpBgp                  int32  = 179
        DefaultToPortRangeKcpBgp                    int32  = 179
        DefaultSecurityGroupRuleKwBgpName           string = "cluster-api-securitygrouprule-kw-bgp"
        DefaultFlowKwBgp                            string = "Inbound"
        DefaultIpProtocolKwBgp                      string = "tcp"
        DefaultRuleIpRangeKwBgp                     string = "10.0.0.0/16"
        DefaultFromPortRangeKwBgp                   int32  = 179
        DefaultToPortRangeKwBgp                     int32  = 179
        DefaultSecurityGroupRuleKubeletKcpName      string = "cluster-api-securitygrouprule-kubelet-kcp"
        DefaultFlowKubeletKcp                       string = "Inbound"
        DefaultIpProtocolKubeletKcp                 string = "tcp"
        DefaultRuleIpRangeKubeletKcp                string = "10.0.4.0/24"
        DefaultFromPortRangeKubeletKcp              int32  = 10250
        DefaultToPortRangeKubeletKcp                int32  = 10252
        DefaultSecurityGroupPublicName              string = "cluster-api-securitygroup-lb"
        DefaultDescriptionLb                        string = "Security Group Lb with cluster-api"
        DefaultSecurityGroupRuleLbName              string = "cluster-api-securitygrouprule-lb"
        DefaultFlowLb                               string = "Inbound"
        DefaultIpProtocolLb                         string = "tcp"
        DefaultRuleIpRangeLb                        string = "0.0.0.0/0"
        DefaultFromPortRangeLb                      int32  = 6443
        DefaultToPortRangeLb                        int32  = 6443
        DefaultSecurityGroupNodeName                string = "cluster-api-securitygroup-node"
        DefaultDescriptionNode                      string = "Security Group Node with cluster-api"
        DefaultSecurityGroupRuleCalicoVxlanName     string = "cluster-api-securitygroup-calico-vxlan"
        DefaultFlowCalicoVxlan                      string = "Inbound"
        DefaultIpProtocolCalicoVxlan                string = "udp"
        DefaultRuleIpRangeCalicoVxlan               string = "10.0.0.0/16"
        DefaultFromPortRangeCalicoVxlan             int32  = 4789
        DefaultToPortRangeCalicoVxlan               int32  = 4789
        DefaultSecurityGroupRuleCalicoTypha         string = "cluster-api-securitygroup-typha"
        DefaultFlowCalicoTypha                      string = "Inbound"
        DefaultIpProtocolCalicoTypha                string = "udp"
        DefaultRuleIpRangeCalicoTypha               string = "10.0.0.0/16"
        DefaultFromPortRangeCalicoTypha             int32  = 5473
        DefaultToPortRangeCalicoTypha               int32  = 5473
        DefaultSecurityGroupRuleCalicoWireguard     string = "cluster-api-securitygroup-wireguard"
        DefaultFlowCalicoWireguard                  string = "Inbound"
        DefaultIpProtocolCalicoWireguard            string = "udp"
        DefaultRuleIpRangeCalicoWireguard           string = "10.0.0.0/16"
        DefaultFromPortRangeCalicoWireguard         int32  = 51820
        DefaultToPortRangeCalicoWireguard           int32  = 51820
        DefaultSecurityGroupRuleCalicoWireguardIpv6 string = "cluster-api-securitygroup-wireguard-ipv6"
        DefaultFlowCalicoWireguardIpv6              string = "Inbound"
        DefaultIpProtocolCalicoWireguardIpv6        string = "udp"
        DefaultRuleIpRangeCalicoWireguardIpv6       string = "10.0.0.0/16"
        DefaultFromPortRangeCalicoWireguardIpv6     int32  = 51821
        DefaultToPortRangeCalicoWireguardIpv6       int32  = 51821
        DefaultSecurityGroupRuleFlannel             string = "cluster-api-securitygroup-flannel"
        DefaultFlowFlannel                          string = "Inbound"
        DefaultIpProtocolFlannel                    string = "udp"
        DefaultRuleIpRangeFlannel                   string = "10.0.0.0/16"
        DefaultFromPortRangeFlannel                 int32  = 4789
        DefaultToPortRangeFlannel                   int32  = 4789
        DefaultSecurityGroupRuleFlannelUdp          string = "cluster-api-securitygroup-flannel-udp"
        DefaultFlowFlannelUdp                       string = "Inbound"
        DefaultIpProtocolFlannelUdp                 string = "udp"
        DefaultRuleIpRangeFlannelUdp                string = "10.0.0.0/16"
        DefaultFromPortRangeFlannelUdp              int32  = 8285
        DefaultToPortRangeFlannelUdp                int32  = 8285
        DefaultSecurityGroupRuleFlannelVxlan        string = "cluster-api-securityrgroup-flannel-vxlan"
        DefaultFlowFlannelVxlan                     string = "Inbound"
        DefaultIpProtocolFlannelVxlan               string = "udp"
        DefaultRuleIpRangeFlannelVxlan              string = "10.0.0.0/16"
        DefaultFromPortRangeFlannelVxlan            int32  = 8472
        DefaultToPortRangeFlannelVxlan              int32  = 8472
)

// SetDefaultValue set the Net default values
func (net *OscNet) SetDefaultValue() <span class="cov0" title="0">{
        var netName string = DefaultNetName
        if net.ClusterName != "" </span><span class="cov0" title="0">{
                netName = strings.Replace(DefaultNetName, DefaultClusterName, net.ClusterName, -1)
        }</span>
        <span class="cov0" title="0">if net.IpRange == "" </span><span class="cov0" title="0">{
                net.IpRange = DefaultIpRange
        }</span>
        <span class="cov0" title="0">if net.Name == "" </span><span class="cov0" title="0">{
                net.Name = netName
        }</span>
}

// SetVolumeDefaultValue set the Volume default values from volume configuration
func (node *OscNode) SetVolumeDefaultValue() <span class="cov0" title="0">{
        if len(node.Volumes) == 0 </span><span class="cov0" title="0">{
                var volume OscVolume
                var volumeKcpName string = DefaultVolumeKcpName
                var volumeKwName string = DefaultVolumeKwName
                var volumeKcpSubregionName string = DefaultVolumeKcpSubregionName
                var volumeKwSubregionName string = DefaultVolumeKwSubregionName
                if node.ClusterName != "" </span><span class="cov0" title="0">{
                        volumeKcpName = strings.Replace(DefaultVolumeKcpName, DefaultClusterName, node.ClusterName, -1)
                        volumeKwName = strings.Replace(DefaultVolumeKwName, DefaultClusterName, node.ClusterName, -1)
                        volumeKcpSubregionName = strings.Replace(DefaultVolumeKcpSubregionName, DefaultClusterName, node.ClusterName, -1)
                        volumeKwSubregionName = strings.Replace(DefaultVolumeKwSubregionName, DefaultClusterName, node.ClusterName, -1)

                }</span>
                <span class="cov0" title="0">if node.Vm.Role == "controlplane" </span><span class="cov0" title="0">{
                        volume = OscVolume{
                                Name:          volumeKcpName,
                                Iops:          DefaultVolumeKcpIops,
                                Size:          DefaultVolumeKcpSize,
                                SubregionName: volumeKcpSubregionName,
                                VolumeType:    DefaultVolumeKcpType,
                        }
                }</span> else<span class="cov0" title="0"> {
                        volume = OscVolume{
                                Name:          volumeKwName,
                                Iops:          DefaultVolumeKwIops,
                                Size:          DefaultVolumeKwSize,
                                SubregionName: volumeKwSubregionName,
                                VolumeType:    DefaultVolumeKwType,
                        }
                }</span>
                <span class="cov0" title="0">node.Volumes = append(node.Volumes, &amp;volume)</span>
        }
}

// SetKeyPairDefaultValue set the KeyPair default values
func (node *OscNode) SetKeyPairDefaultValue() <span class="cov0" title="0">{
        if len(node.KeyPair.PublicKey) == 0 </span><span class="cov0" title="0">{
                privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">publicKey, err := ssh.NewPublicKey(&amp;privateKey.PublicKey)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">node.KeyPair.PublicKey = base64.StdEncoding.EncodeToString(ssh.MarshalAuthorizedKey(publicKey))</span>
        }
        <span class="cov0" title="0">if len(node.KeyPair.Name) == 0 </span><span class="cov0" title="0">{
                node.KeyPair.Name = DefaultKeypairName
        }</span>

}

// SetDefaultValue set the Internet Service default values
func (igw *OscInternetService) SetDefaultValue() <span class="cov0" title="0">{
        var internetServiceName string = DefaultInternetServiceName
        if igw.ClusterName != "" </span><span class="cov0" title="0">{
                internetServiceName = strings.Replace(DefaultInternetServiceName, DefaultClusterName, igw.ClusterName, -1)
        }</span>
        <span class="cov0" title="0">if igw.Name == "" </span><span class="cov0" title="0">{
                igw.Name = internetServiceName
        }</span>
}

// SetDefaultValue set the vm default values
func (vm *OscVm) SetDefaultValue() <span class="cov0" title="0">{
        var vmKcpName string = DefaultVmKcpName
        var vmKwName string = DefaultVmKwName
        var subnetKcpName string = DefaultSubnetKcpName
        var subnetKwName string = DefaultSubnetKwName
        var securityGroupKcpName string = DefaultSecurityGroupKcpName
        var securityGroupKwName string = DefaultSecurityGroupKwName
        var securityGroupNodeName string = DefaultSecurityGroupNodeName
        if vm.ClusterName != "" </span><span class="cov0" title="0">{
                vmKcpName = strings.Replace(DefaultVmKcpName, DefaultClusterName, vm.ClusterName, -1)
                vmKwName = strings.Replace(DefaultVmKwName, DefaultClusterName, vm.ClusterName, -1)
                subnetKcpName = strings.Replace(DefaultSubnetKcpName, DefaultClusterName, vm.ClusterName, -1)
                subnetKwName = strings.Replace(DefaultSubnetKwName, DefaultClusterName, vm.ClusterName, -1)
                securityGroupKcpName = strings.Replace(DefaultSecurityGroupKcpName, DefaultClusterName, vm.ClusterName, -1)
                securityGroupKwName = strings.Replace(DefaultSecurityGroupKwName, DefaultClusterName, vm.ClusterName, -1)
                securityGroupNodeName = strings.Replace(DefaultSecurityGroupNodeName, DefaultClusterName, vm.ClusterName, -1)
        }</span>
        <span class="cov0" title="0">if vm.Role == "controlplane" </span><span class="cov0" title="0">{
                if vm.Name == "" </span><span class="cov0" title="0">{
                        vm.Name = vmKcpName
                }</span>
                <span class="cov0" title="0">if vm.VmType == "" </span><span class="cov0" title="0">{
                        vm.VmType = DefaultVmKcpType
                }</span>
                <span class="cov0" title="0">if vm.SubnetName == "" </span><span class="cov0" title="0">{
                        vm.SubnetName = subnetKcpName
                }</span>

                <span class="cov0" title="0">if vm.RootDisk.RootDiskIops == 0 &amp;&amp; vm.RootDisk.RootDiskType == "io1" </span><span class="cov0" title="0">{
                        vm.RootDisk.RootDiskIops = DefaultRootDiskKcpIops
                }</span>

                <span class="cov0" title="0">if vm.RootDisk.RootDiskType == "" </span><span class="cov0" title="0">{
                        vm.RootDisk.RootDiskType = DefaultRootDiskKcpType
                }</span>

                <span class="cov0" title="0">if vm.RootDisk.RootDiskSize == 0 </span><span class="cov0" title="0">{
                        vm.RootDisk.RootDiskSize = DefaultRootDiskKcpSize
                }</span>

                <span class="cov0" title="0">if vm.LoadBalancerName == "" </span><span class="cov0" title="0">{
                        vm.LoadBalancerName = DefaultLoadBalancerName
                }</span>
                <span class="cov0" title="0">if len(vm.SecurityGroupNames) == 0 </span><span class="cov0" title="0">{
                        securityGroupKw := OscSecurityGroupElement{
                                Name: securityGroupKcpName,
                        }
                        securityGroupNode := OscSecurityGroupElement{
                                Name: securityGroupNodeName,
                        }
                        vm.SecurityGroupNames = []OscSecurityGroupElement{securityGroupKw, securityGroupNode}
                }</span>
        } else<span class="cov0" title="0"> {
                if vm.Name == "" </span><span class="cov0" title="0">{
                        vm.Name = vmKwName
                }</span>
                <span class="cov0" title="0">if vm.VmType == "" </span><span class="cov0" title="0">{
                        vm.VmType = DefaultVmKwType
                }</span>

                <span class="cov0" title="0">if vm.RootDisk.RootDiskIops == 0 &amp;&amp; vm.RootDisk.RootDiskType == "io1" </span><span class="cov0" title="0">{
                        vm.RootDisk.RootDiskIops = DefaultRootDiskKwIops
                }</span>

                <span class="cov0" title="0">if vm.RootDisk.RootDiskType == "" </span><span class="cov0" title="0">{
                        vm.RootDisk.RootDiskType = DefaultRootDiskKwType
                }</span>

                <span class="cov0" title="0">if vm.RootDisk.RootDiskSize == 0 </span><span class="cov0" title="0">{
                        vm.RootDisk.RootDiskSize = DefaultRootDiskKwSize
                }</span>

                <span class="cov0" title="0">if vm.SubnetName == "" </span><span class="cov0" title="0">{
                        vm.SubnetName = subnetKwName
                }</span>
                <span class="cov0" title="0">if len(vm.SecurityGroupNames) == 0 </span><span class="cov0" title="0">{
                        securityGroupKw := OscSecurityGroupElement{
                                Name: securityGroupKwName,
                        }
                        securityGroupNode := OscSecurityGroupElement{
                                Name: securityGroupNodeName,
                        }
                        vm.SecurityGroupNames = []OscSecurityGroupElement{securityGroupKw, securityGroupNode}
                }</span>
        }
        <span class="cov0" title="0">if vm.ImageId == "" </span><span class="cov0" title="0">{
                vm.ImageId = DefaultVmImageId
        }</span>
        <span class="cov0" title="0">if vm.KeypairName == "" </span><span class="cov0" title="0">{
                vm.KeypairName = DefaultVmKeypairName
        }</span>
        <span class="cov0" title="0">if vm.DeviceName == "" </span><span class="cov0" title="0">{
                vm.DeviceName = DefaultVmDeviceName
        }</span>
        <span class="cov0" title="0">if vm.SubregionName == "" </span><span class="cov0" title="0">{
                vm.SubregionName = DefaultVmSubregionName
        }</span>

}

// SetDefaultValue set the bastion default values
func (bastion *OscBastion) SetDefaultValue() <span class="cov0" title="0">{
        var vmBastionName string = DefaultVmBastionName
        var subnetPublicName string = DefaultSubnetPublicName
        var securityGroupPublicName string = DefaultSecurityGroupPublicName
        if bastion.Enable </span><span class="cov0" title="0">{
                if bastion.ClusterName != "" </span><span class="cov0" title="0">{
                        vmBastionName = strings.Replace(DefaultVmBastionName, DefaultClusterName, bastion.ClusterName, -1)
                        subnetPublicName = strings.Replace(DefaultSubnetPublicName, DefaultClusterName, bastion.ClusterName, -1)
                        securityGroupPublicName = strings.Replace(DefaultSecurityGroupPublicName, DefaultClusterName, bastion.ClusterName, -1)
                }</span>
                <span class="cov0" title="0">if bastion.Name == "" </span><span class="cov0" title="0">{
                        bastion.Name = vmBastionName
                }</span>
                <span class="cov0" title="0">if bastion.VmType == "" </span><span class="cov0" title="0">{
                        bastion.VmType = DefaultVmBastionType
                }</span>
                <span class="cov0" title="0">if bastion.RootDisk.RootDiskIops == 0 &amp;&amp; bastion.RootDisk.RootDiskType == "io1" </span><span class="cov0" title="0">{
                        bastion.RootDisk.RootDiskIops = DefaultRootDiskBastionIops
                }</span>
                <span class="cov0" title="0">if bastion.RootDisk.RootDiskType == "" </span><span class="cov0" title="0">{
                        bastion.RootDisk.RootDiskType = DefaultRootDiskBastionType
                }</span>
                <span class="cov0" title="0">if bastion.SubnetName == "" </span><span class="cov0" title="0">{
                        bastion.SubnetName = subnetPublicName
                }</span>
                <span class="cov0" title="0">if len(bastion.SecurityGroupNames) == 0 </span><span class="cov0" title="0">{
                        securityGroupPublic := OscSecurityGroupElement{
                                Name: securityGroupPublicName,
                        }
                        bastion.SecurityGroupNames = []OscSecurityGroupElement{securityGroupPublic}
                }</span>
                <span class="cov0" title="0">if bastion.ImageId == "" </span><span class="cov0" title="0">{
                        bastion.ImageId = DefaultVmBastionImageId
                }</span>
                <span class="cov0" title="0">if bastion.KeypairName == "" </span><span class="cov0" title="0">{
                        bastion.KeypairName = DefaultVmBastionKeypairName
                }</span>
                <span class="cov0" title="0">if bastion.DeviceName == "" </span><span class="cov0" title="0">{
                        bastion.DeviceName = DefaultVmDeviceName
                }</span>
                <span class="cov0" title="0">if bastion.SubregionName == "" </span><span class="cov0" title="0">{
                        bastion.SubregionName = DefaultVmBastionSubregionName
                }</span>
        }
}

// SetDefaultValue set the image default values
func (node *OscNode) SetImageDefaultValue() <span class="cov0" title="0">{
        if node.Image.Name == "" </span><span class="cov0" title="0">{
                node.Image.Name = DefaultVmImageId
        }</span>
}

// SetDefaultValue set the Nat Service default values
func (nat *OscNatService) SetDefaultValue() <span class="cov0" title="0">{
        var natServiceName string = DefaultNatServiceName
        var publicIpNatName string = DefaultPublicIpNatName
        var subnetNatName string = DefaultSubnetPublicName
        if nat.ClusterName != "" </span><span class="cov0" title="0">{
                natServiceName = strings.Replace(DefaultNatServiceName, DefaultClusterName, nat.ClusterName, -1)
                publicIpNatName = strings.Replace(DefaultPublicIpNatName, DefaultClusterName, nat.ClusterName, -1)
                subnetNatName = strings.Replace(DefaultSubnetPublicName, DefaultClusterName, nat.ClusterName, -1)
        }</span>
        <span class="cov0" title="0">if nat.Name == "" </span><span class="cov0" title="0">{
                nat.Name = natServiceName
        }</span>
        <span class="cov0" title="0">if nat.PublicIpName == "" </span><span class="cov0" title="0">{
                nat.PublicIpName = publicIpNatName
        }</span>
        <span class="cov0" title="0">if nat.SubnetName == "" </span><span class="cov0" title="0">{
                nat.SubnetName = subnetNatName
        }</span>
}

// SetRouteTableDefaultValue set the Route Table default values from network configuration
func (network *OscNetwork) SetRouteTableDefaultValue() <span class="cov0" title="0">{
        if len(network.RouteTables) == 0 </span><span class="cov0" title="0">{
                var routeKwName string = DefaultRouteKwName
                var targetKwName string = DefaultTargetKwName
                var routeTableKwName string = DefaultRouteTableKwName
                var subnetKwName string = DefaultSubnetKwName

                var routeKcpName string = DefaultRouteKcpName
                var targetKcpName string = DefaultTargetKcpName
                var routeTableKcpName string = DefaultRouteTableKcpName
                var subnetKcpName string = DefaultSubnetKcpName

                var routePublicName string = DefaultRoutePublicName
                var targetPublicName string = DefaultTargetPublicName
                var routeTablePublicName string = DefaultRouteTablePublicName
                var subnetPublicName string = DefaultSubnetPublicName

                if network.ClusterName != "" </span><span class="cov0" title="0">{
                        routeKwName = strings.Replace(DefaultRouteKwName, DefaultClusterName, network.ClusterName, -1)
                        targetKwName = strings.Replace(DefaultTargetKwName, DefaultClusterName, network.ClusterName, -1)
                        routeTableKwName = strings.Replace(DefaultRouteTableKwName, DefaultClusterName, network.ClusterName, -1)
                        subnetKwName = strings.Replace(DefaultSubnetKwName, DefaultClusterName, network.ClusterName, -1)
                        routeKcpName = strings.Replace(DefaultRouteKcpName, DefaultClusterName, network.ClusterName, -1)
                        targetKcpName = strings.Replace(DefaultTargetKcpName, DefaultClusterName, network.ClusterName, -1)
                        routeTableKcpName = strings.Replace(DefaultRouteTableKcpName, DefaultClusterName, network.ClusterName, -1)
                        subnetKcpName = strings.Replace(DefaultSubnetKcpName, DefaultClusterName, network.ClusterName, -1)

                        routePublicName = strings.Replace(DefaultRoutePublicName, DefaultClusterName, network.ClusterName, -1)
                        targetPublicName = strings.Replace(DefaultTargetPublicName, DefaultClusterName, network.ClusterName, -1)
                        routeTablePublicName = strings.Replace(DefaultRouteTablePublicName, DefaultClusterName, network.ClusterName, -1)
                        subnetPublicName = strings.Replace(DefaultSubnetPublicName, DefaultClusterName, network.ClusterName, -1)
                }</span>

                <span class="cov0" title="0">routeKw := OscRoute{
                        Name:        routeKwName,
                        TargetName:  targetKwName,
                        TargetType:  DefaultTargetKwType,
                        Destination: DefaultDestinationKw,
                }

                routeKcp := OscRoute{
                        Name:        routeKcpName,
                        TargetName:  targetKcpName,
                        TargetType:  DefaultTargetKcpType,
                        Destination: DefaultDestinationKcp,
                }
                routePublic := OscRoute{
                        Name:        routePublicName,
                        TargetName:  targetPublicName,
                        TargetType:  DefaultTargetPublicType,
                        Destination: DefaultDestinationPublic,
                }

                subnetKw := []string{subnetKwName}
                subnetKcp := []string{subnetKcpName}
                subnetPublic := []string{subnetPublicName}
                routeTableKw := OscRouteTable{
                        Name:   routeTableKwName,
                        Routes: []OscRoute{routeKw},
                }

                network.RouteTables = append(network.RouteTables, &amp;routeTableKw)
                routeTableKw.Subnets = subnetKw
                routeTableKcp := OscRouteTable{
                        Name:   routeTableKcpName,
                        Routes: []OscRoute{routeKcp},
                }
                network.RouteTables = append(network.RouteTables, &amp;routeTableKcp)
                routeTableKcp.Subnets = subnetKcp

                routeTablePublic := OscRouteTable{
                        Name:   routeTablePublicName,
                        Routes: []OscRoute{routePublic},
                }
                network.RouteTables = append(network.RouteTables, &amp;routeTablePublic)
                routeTablePublic.Subnets = subnetPublic</span>
        }
}

// SetSecurityGroupDefaultValue set the security group default value
func (network *OscNetwork) SetSecurityGroupDefaultValue() <span class="cov0" title="0">{
        if len(network.SecurityGroups) == 0 </span><span class="cov0" title="0">{
                var securityGroupRuleApiKubeletKwName string = DefaultSecurityGroupRuleApiKubeletKwName
                var securityGroupRuleApiKubeletKcpName string = DefaultSecurityGroupRuleApiKubeletKcpName
                var securityGroupRuleKwNodeIpKwName string = DefaultSecurityGroupRuleKwNodeIpKwName
                var securityGroupRuleKcpNodeIpKwName string = DefaultSecurityGroupRuleKcpNodeIpKwName
                var securityGroupRuleKcpNodeIpKcpName string = DefaultSecurityGroupRuleKcpNodeIpKcpName
                var securityGroupRuleKwNodeIpKcpName string = DefaultSecurityGroupRuleKwNodeIpKcpName
                var securityGroupKwName string = DefaultSecurityGroupKwName
                var securityGroupRuleApiKwName string = DefaultSecurityGroupRuleApiKwName
                var securityGroupRuleApiKcpName string = DefaultSecurityGroupRuleApiKcpName
                var securityGroupRuleEtcdName string = DefaultSecurityGroupRuleEtcdName
                var securityGroupRuleKwBgpName string = DefaultSecurityGroupRuleKwBgpName
                var securityGroupRuleKcpBgpName string = DefaultSecurityGroupRuleKcpBgpName
                var securityGroupRuleKubeletKcpName string = DefaultSecurityGroupRuleKubeletKcpName
                var securityGroupKcpName string = DefaultSecurityGroupKcpName
                var securityGroupRuleLbName string = DefaultSecurityGroupRuleLbName
                var securityGroupLbName string = DefaultSecurityGroupPublicName
                var securityGroupNodeName string = DefaultSecurityGroupNodeName
                if network.ClusterName != "" </span><span class="cov0" title="0">{
                        securityGroupRuleApiKubeletKwName = strings.Replace(DefaultSecurityGroupRuleApiKubeletKwName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupRuleApiKubeletKcpName = strings.Replace(DefaultSecurityGroupRuleApiKubeletKcpName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupRuleKwNodeIpKwName = strings.Replace(DefaultSecurityGroupRuleKwNodeIpKwName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupRuleKcpNodeIpKwName = strings.Replace(DefaultSecurityGroupRuleKcpNodeIpKwName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupRuleKcpNodeIpKcpName = strings.Replace(DefaultSecurityGroupRuleKcpNodeIpKcpName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupRuleKwNodeIpKcpName = strings.Replace(DefaultSecurityGroupRuleKwNodeIpKcpName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupKwName = strings.Replace(DefaultSecurityGroupKwName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupRuleApiKwName = strings.Replace(DefaultSecurityGroupRuleApiKwName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupRuleApiKcpName = strings.Replace(DefaultSecurityGroupRuleApiKcpName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupRuleEtcdName = strings.Replace(DefaultSecurityGroupRuleEtcdName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupRuleKwBgpName = strings.Replace(DefaultSecurityGroupRuleKwBgpName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupRuleKcpBgpName = strings.Replace(DefaultSecurityGroupRuleKcpBgpName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupRuleKubeletKcpName = strings.Replace(DefaultSecurityGroupRuleKubeletKcpName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupKcpName = strings.Replace(DefaultSecurityGroupKcpName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupRuleLbName = strings.Replace(DefaultSecurityGroupRuleLbName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupLbName = strings.Replace(DefaultSecurityGroupPublicName, DefaultClusterName, network.ClusterName, -1)
                        securityGroupNodeName = strings.Replace(DefaultSecurityGroupNodeName, DefaultClusterName, network.ClusterName, -1)

                }</span>
                <span class="cov0" title="0">securityGroupRuleApiKubeletKw := OscSecurityGroupRule{
                        Name:          securityGroupRuleApiKubeletKwName,
                        Flow:          DefaultFlowApiKubeletKw,
                        IpProtocol:    DefaultIpProtocolApiKubeletKw,
                        IpRange:       DefaultRuleIpRangeApiKubeletKw,
                        FromPortRange: DefaultFromPortRangeApiKubeletKw,
                        ToPortRange:   DefaultToPortRangeApiKubeletKw,
                }

                securityGroupRuleApiKubeletKcp := OscSecurityGroupRule{
                        Name:          securityGroupRuleApiKubeletKcpName,
                        Flow:          DefaultFlowApiKubeletKcp,
                        IpProtocol:    DefaultIpProtocolApiKubeletKcp,
                        IpRange:       DefaultRuleIpRangeApiKubeletKcp,
                        FromPortRange: DefaultFromPortRangeApiKubeletKcp,
                        ToPortRange:   DefaultToPortRangeApiKubeletKcp,
                }

                securityGroupRuleKwNodeIpKw := OscSecurityGroupRule{
                        Name:          securityGroupRuleKwNodeIpKwName,
                        Flow:          DefaultFlowNodeIpKw,
                        IpProtocol:    DefaultIpProtocolNodeIpKw,
                        IpRange:       DefaultRuleIpRangeNodeIpKw,
                        FromPortRange: DefaultFromPortRangeNodeIpKw,
                        ToPortRange:   DefaultToPortRangeNodeIpKw,
                }

                securityGroupRuleKwNodeIpKcp := OscSecurityGroupRule{
                        Name:          securityGroupRuleKwNodeIpKcpName,
                        Flow:          DefaultFlowNodeIpKcp,
                        IpProtocol:    DefaultIpProtocolNodeIpKcp,
                        IpRange:       DefaultRuleIpRangeNodeIpKcp,
                        FromPortRange: DefaultFromPortRangeNodeIpKcp,
                        ToPortRange:   DefaultToPortRangeNodeIpKcp,
                }

                securityGroupRuleKwBgp := OscSecurityGroupRule{
                        Name:          securityGroupRuleKwBgpName,
                        Flow:          DefaultFlowKwBgp,
                        IpProtocol:    DefaultIpProtocolKwBgp,
                        IpRange:       DefaultRuleIpRangeKwBgp,
                        FromPortRange: DefaultFromPortRangeKwBgp,
                        ToPortRange:   DefaultToPortRangeKwBgp,
                }

                securityGroupKw := OscSecurityGroup{
                        Name:               securityGroupKwName,
                        Description:        DefaultDescriptionKw,
                        SecurityGroupRules: []OscSecurityGroupRule{securityGroupRuleKwBgp, securityGroupRuleApiKubeletKw, securityGroupRuleKwNodeIpKcp, securityGroupRuleApiKubeletKcp, securityGroupRuleKwNodeIpKw},
                }
                network.SecurityGroups = append(network.SecurityGroups, &amp;securityGroupKw)

                securityGroupRuleApiKw := OscSecurityGroupRule{
                        Name:          securityGroupRuleApiKwName,
                        Flow:          DefaultFlowApiKw,
                        IpProtocol:    DefaultIpProtocolApiKw,
                        IpRange:       DefaultRuleIpRangeApiKw,
                        FromPortRange: DefaultFromPortRangeApiKw,
                        ToPortRange:   DefaultToPortRangeApiKw,
                }

                securityGroupRuleApiKcp := OscSecurityGroupRule{
                        Name:          securityGroupRuleApiKcpName,
                        Flow:          DefaultFlowApiKcp,
                        IpProtocol:    DefaultIpProtocolApiKcp,
                        IpRange:       DefaultRuleIpRangeApiKcp,
                        FromPortRange: DefaultFromPortRangeApiKcp,
                        ToPortRange:   DefaultToPortRangeApiKcp,
                }

                securityGroupRuleEtcd := OscSecurityGroupRule{
                        Name:          securityGroupRuleEtcdName,
                        Flow:          DefaultFlowEtcd,
                        IpProtocol:    DefaultIpProtocolEtcd,
                        IpRange:       DefaultRuleIpRangeEtcd,
                        FromPortRange: DefaultFromPortRangeEtcd,
                        ToPortRange:   DefaultToPortRangeEtcd,
                }

                securityGroupRuleKubeletKcp := OscSecurityGroupRule{
                        Name:          securityGroupRuleKubeletKcpName,
                        Flow:          DefaultFlowKubeletKcp,
                        IpProtocol:    DefaultIpProtocolKubeletKcp,
                        IpRange:       DefaultRuleIpRangeKubeletKcp,
                        FromPortRange: DefaultFromPortRangeKubeletKcp,
                        ToPortRange:   DefaultToPortRangeKubeletKcp,
                }

                securityGroupRuleKcpBgp := OscSecurityGroupRule{
                        Name:          securityGroupRuleKcpBgpName,
                        Flow:          DefaultFlowKcpBgp,
                        IpProtocol:    DefaultIpProtocolKcpBgp,
                        IpRange:       DefaultRuleIpRangeKcpBgp,
                        FromPortRange: DefaultFromPortRangeKcpBgp,
                        ToPortRange:   DefaultToPortRangeKcpBgp,
                }

                securityGroupRuleKcpNodeIpKw := OscSecurityGroupRule{
                        Name:          securityGroupRuleKcpNodeIpKwName,
                        Flow:          DefaultFlowNodeIpKw,
                        IpProtocol:    DefaultIpProtocolNodeIpKw,
                        IpRange:       DefaultRuleIpRangeNodeIpKw,
                        FromPortRange: DefaultFromPortRangeNodeIpKw,
                        ToPortRange:   DefaultToPortRangeNodeIpKw,
                }

                securityGroupRuleKcpNodeIpKcp := OscSecurityGroupRule{
                        Name:          securityGroupRuleKcpNodeIpKcpName,
                        Flow:          DefaultFlowNodeIpKcp,
                        IpProtocol:    DefaultIpProtocolNodeIpKcp,
                        IpRange:       DefaultRuleIpRangeNodeIpKcp,
                        FromPortRange: DefaultFromPortRangeNodeIpKcp,
                        ToPortRange:   DefaultToPortRangeNodeIpKcp,
                }

                securityGroupKcp := OscSecurityGroup{
                        Name:               securityGroupKcpName,
                        Description:        DefaultDescriptionKcp,
                        SecurityGroupRules: []OscSecurityGroupRule{securityGroupRuleKcpBgp, securityGroupRuleApiKw, securityGroupRuleApiKcp, securityGroupRuleKcpNodeIpKw, securityGroupRuleEtcd, securityGroupRuleKubeletKcp, securityGroupRuleKcpNodeIpKcp},
                }
                network.SecurityGroups = append(network.SecurityGroups, &amp;securityGroupKcp)

                securityGroupRuleLb := OscSecurityGroupRule{
                        Name:          securityGroupRuleLbName,
                        Flow:          DefaultFlowLb,
                        IpProtocol:    DefaultIpProtocolLb,
                        IpRange:       DefaultRuleIpRangeLb,
                        FromPortRange: DefaultFromPortRangeLb,
                        ToPortRange:   DefaultToPortRangeLb,
                }
                securityGroupLb := OscSecurityGroup{
                        Name:               securityGroupLbName,
                        Description:        DefaultDescriptionLb,
                        SecurityGroupRules: []OscSecurityGroupRule{securityGroupRuleLb},
                }

                securityGroupRuleCalicoVxlan := OscSecurityGroupRule{
                        Name:          DefaultSecurityGroupRuleCalicoVxlanName,
                        Flow:          DefaultFlowCalicoVxlan,
                        IpProtocol:    DefaultIpProtocolCalicoVxlan,
                        IpRange:       DefaultRuleIpRangeCalicoVxlan,
                        FromPortRange: DefaultFromPortRangeCalicoVxlan,
                        ToPortRange:   DefaultToPortRangeCalicoVxlan,
                }

                securityGroupRuleCalicoTypha := OscSecurityGroupRule{
                        Name:          DefaultSecurityGroupRuleCalicoTypha,
                        Flow:          DefaultFlowCalicoTypha,
                        IpProtocol:    DefaultIpProtocolCalicoTypha,
                        IpRange:       DefaultRuleIpRangeCalicoTypha,
                        FromPortRange: DefaultFromPortRangeCalicoTypha,
                        ToPortRange:   DefaultToPortRangeCalicoTypha,
                }

                securityGroupRuleCalicoWireguard := OscSecurityGroupRule{
                        Name:          DefaultSecurityGroupRuleCalicoWireguard,
                        Flow:          DefaultFlowCalicoWireguard,
                        IpProtocol:    DefaultIpProtocolCalicoWireguard,
                        IpRange:       DefaultRuleIpRangeCalicoWireguard,
                        FromPortRange: DefaultFromPortRangeCalicoWireguard,
                        ToPortRange:   DefaultToPortRangeCalicoWireguard,
                }

                securityGroupRuleCalicoWireguardIpv6 := OscSecurityGroupRule{
                        Name:          DefaultSecurityGroupRuleCalicoWireguardIpv6,
                        Flow:          DefaultFlowCalicoWireguardIpv6,
                        IpProtocol:    DefaultIpProtocolCalicoWireguardIpv6,
                        IpRange:       DefaultRuleIpRangeCalicoWireguardIpv6,
                        FromPortRange: DefaultFromPortRangeCalicoWireguardIpv6,
                        ToPortRange:   DefaultToPortRangeCalicoWireguardIpv6,
                }

                securityGroupRuleFlannel := OscSecurityGroupRule{
                        Name:          DefaultSecurityGroupRuleFlannel,
                        Flow:          DefaultFlowFlannel,
                        IpProtocol:    DefaultIpProtocolFlannel,
                        IpRange:       DefaultRuleIpRangeFlannel,
                        FromPortRange: DefaultFromPortRangeFlannel,
                        ToPortRange:   DefaultToPortRangeFlannel,
                }

                securityGroupRuleFlannelUdp := OscSecurityGroupRule{
                        Name:          DefaultSecurityGroupRuleFlannelUdp,
                        Flow:          DefaultFlowFlannelUdp,
                        IpProtocol:    DefaultIpProtocolFlannelUdp,
                        IpRange:       DefaultRuleIpRangeFlannelUdp,
                        FromPortRange: DefaultFromPortRangeFlannelUdp,
                        ToPortRange:   DefaultToPortRangeFlannelUdp,
                }

                securityGroupRuleFlannelVxlan := OscSecurityGroupRule{
                        Name:          DefaultSecurityGroupRuleFlannelVxlan,
                        Flow:          DefaultFlowFlannelVxlan,
                        IpProtocol:    DefaultIpProtocolFlannelVxlan,
                        IpRange:       DefaultRuleIpRangeFlannelVxlan,
                        FromPortRange: DefaultFromPortRangeFlannelVxlan,
                        ToPortRange:   DefaultToPortRangeFlannelVxlan,
                }
                network.SecurityGroups = append(network.SecurityGroups, &amp;securityGroupLb)
                securityGroupNode := OscSecurityGroup{
                        Name:               securityGroupNodeName,
                        Description:        DefaultDescriptionNode,
                        Tag:                "OscK8sMainSG",
                        SecurityGroupRules: []OscSecurityGroupRule{securityGroupRuleCalicoVxlan, securityGroupRuleCalicoTypha, securityGroupRuleCalicoWireguard, securityGroupRuleCalicoWireguardIpv6, securityGroupRuleFlannel, securityGroupRuleFlannelUdp, securityGroupRuleFlannelVxlan},
                }
                network.SecurityGroups = append(network.SecurityGroups, &amp;securityGroupNode)</span>
        }
}

// SetPublicIpDefaultDefaultValue set the Public Ip default values from publicip configuration
func (network *OscNetwork) SetPublicIpDefaultValue() <span class="cov0" title="0">{
        if len(network.PublicIps) == 0 </span><span class="cov0" title="0">{
                var publicIpNatName string = DefaultPublicIpNatName
                if network.ClusterName != "" </span><span class="cov0" title="0">{
                        publicIpNatName = strings.Replace(DefaultPublicIpNatName, DefaultClusterName, network.ClusterName, -1)
                }</span>
                <span class="cov0" title="0">publicIp := OscPublicIp{
                        Name: publicIpNatName,
                }
                network.PublicIps = append(network.PublicIps, &amp;publicIp)</span>
        }
}

// SetSubnetDefaultValue set the Subnet default values from subnet configuration
func (network *OscNetwork) SetSubnetDefaultValue() <span class="cov0" title="0">{
        if len(network.Subnets) == 0 </span><span class="cov0" title="0">{
                var subnetKcpName string = DefaultSubnetKcpName
                var subnetKwName string = DefaultSubnetKwName
                var subnetPublicName string = DefaultSubnetPublicName

                if network.ClusterName != "" </span><span class="cov0" title="0">{
                        subnetKcpName = strings.Replace(subnetKcpName, DefaultClusterName, network.ClusterName, -1)
                        subnetKwName = strings.Replace(subnetKwName, DefaultClusterName, network.ClusterName, -1)
                        subnetPublicName = strings.Replace(subnetPublicName, DefaultClusterName, network.ClusterName, -1)
                }</span>
                <span class="cov0" title="0">subnetKcp := OscSubnet{
                        Name:          subnetKcpName,
                        IpSubnetRange: DefaultIpSubnetKcpRange,
                }
                subnetKw := OscSubnet{
                        Name:          subnetKwName,
                        IpSubnetRange: DefaultIpSubnetKwRange,
                }
                subnetPublic := OscSubnet{
                        Name:          subnetPublicName,
                        IpSubnetRange: DefaultIpSubnetPublicRange,
                }
                network.Subnets = []*OscSubnet{
                        &amp;subnetKcp,
                        &amp;subnetKw,
                        &amp;subnetPublic,
                }</span>
        }
}

// SetSubnetSubregionNameValue set the Subnet Subregion Name values from OscNetwork configuration
func (network *OscNetwork) SetSubnetSubregionNameDefaultValue() <span class="cov0" title="0">{
        var defaultSubregionName string = DefaultSubregionName
        if network.SubregionName != "" </span><span class="cov0" title="0">{
                defaultSubregionName = network.SubregionName
        }</span>
        <span class="cov0" title="0">for _, subnet := range network.Subnets </span><span class="cov0" title="0">{
                if subnet.SubregionName == "" </span><span class="cov0" title="0">{
                        subnet.SubregionName = defaultSubregionName
                }</span>
        }
}

// SetDefaultValue set the LoadBalancer Service default values
func (lb *OscLoadBalancer) SetDefaultValue() <span class="cov0" title="0">{
        var subnetPublicName string = DefaultSubnetPublicName
        var securityGroupLbName string = DefaultSecurityGroupPublicName
        if lb.ClusterName != "" </span><span class="cov0" title="0">{
                subnetPublicName = strings.Replace(DefaultSubnetPublicName, DefaultClusterName, lb.ClusterName, -1)
                securityGroupLbName = strings.Replace(DefaultSecurityGroupPublicName, DefaultClusterName, lb.ClusterName, -1)
        }</span>
        <span class="cov0" title="0">if lb.LoadBalancerName == "" </span><span class="cov0" title="0">{
                lb.LoadBalancerName = DefaultLoadBalancerName
        }</span>
        <span class="cov0" title="0">if lb.LoadBalancerType == "" </span><span class="cov0" title="0">{
                lb.LoadBalancerType = DefaultLoadBalancerType
        }</span>
        <span class="cov0" title="0">if lb.SubnetName == "" </span><span class="cov0" title="0">{
                lb.SubnetName = subnetPublicName
        }</span>
        <span class="cov0" title="0">if lb.SecurityGroupName == "" </span><span class="cov0" title="0">{
                lb.SecurityGroupName = securityGroupLbName
        }</span>

        <span class="cov0" title="0">if lb.Listener.BackendPort == 0 </span><span class="cov0" title="0">{
                lb.Listener.BackendPort = DefaultBackendPort
        }</span>
        <span class="cov0" title="0">if lb.Listener.BackendProtocol == "" </span><span class="cov0" title="0">{
                lb.Listener.BackendProtocol = DefaultBackendProtocol
        }</span>
        <span class="cov0" title="0">if lb.Listener.LoadBalancerPort == 0 </span><span class="cov0" title="0">{
                lb.Listener.LoadBalancerPort = DefaultLoadBalancerPort
        }</span>
        <span class="cov0" title="0">if lb.Listener.LoadBalancerProtocol == "" </span><span class="cov0" title="0">{
                lb.Listener.LoadBalancerProtocol = DefaultLoadBalancerProtocol
        }</span>
        <span class="cov0" title="0">if lb.HealthCheck.CheckInterval == 0 </span><span class="cov0" title="0">{
                lb.HealthCheck.CheckInterval = DefaultCheckInterval
        }</span>
        <span class="cov0" title="0">if lb.HealthCheck.HealthyThreshold == 0 </span><span class="cov0" title="0">{
                lb.HealthCheck.HealthyThreshold = DefaultHealthyThreshold
        }</span>
        <span class="cov0" title="0">if lb.HealthCheck.UnhealthyThreshold == 0 </span><span class="cov0" title="0">{
                lb.HealthCheck.UnhealthyThreshold = DefaultUnhealthyThreshold
        }</span>
        <span class="cov0" title="0">if lb.HealthCheck.Timeout == 0 </span><span class="cov0" title="0">{
                lb.HealthCheck.Timeout = DefaultTimeout
        }</span>
        <span class="cov0" title="0">if lb.HealthCheck.Protocol == "" </span><span class="cov0" title="0">{
                lb.HealthCheck.Protocol = DefaultProtocol
        }</span>
        <span class="cov0" title="0">if lb.HealthCheck.Port == 0 </span><span class="cov0" title="0">{
                lb.HealthCheck.Port = DefaultPort
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1beta1

import (
        "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/runtime"
        apiv1beta1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/errors"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscBastion) DeepCopyInto(out *OscBastion) <span class="cov0" title="0">{
        *out = *in
        out.RootDisk = in.RootDisk
        if in.PrivateIps != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.PrivateIps, &amp;out.PrivateIps
                *out = make([]OscPrivateIpElement, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.SecurityGroupNames != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SecurityGroupNames, &amp;out.SecurityGroupNames
                *out = make([]OscSecurityGroupElement, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscBastion.
func (in *OscBastion) DeepCopy() *OscBastion <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscBastion)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscCluster) DeepCopyInto(out *OscCluster) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscCluster.
func (in *OscCluster) DeepCopy() *OscCluster <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscCluster)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OscCluster) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscClusterList) DeepCopyInto(out *OscClusterList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]OscCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscClusterList.
func (in *OscClusterList) DeepCopy() *OscClusterList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscClusterList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OscClusterList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscClusterSpec) DeepCopyInto(out *OscClusterSpec) <span class="cov0" title="0">{
        *out = *in
        in.Network.DeepCopyInto(&amp;out.Network)
        out.ControlPlaneEndpoint = in.ControlPlaneEndpoint
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscClusterSpec.
func (in *OscClusterSpec) DeepCopy() *OscClusterSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscClusterSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscClusterStatus) DeepCopyInto(out *OscClusterStatus) <span class="cov0" title="0">{
        *out = *in
        in.Network.DeepCopyInto(&amp;out.Network)
        if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.VmState != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.VmState, &amp;out.VmState
                *out = new(VmState)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscClusterStatus.
func (in *OscClusterStatus) DeepCopy() *OscClusterStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscClusterStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscClusterTemplate) DeepCopyInto(out *OscClusterTemplate) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscClusterTemplate.
func (in *OscClusterTemplate) DeepCopy() *OscClusterTemplate <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscClusterTemplate)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OscClusterTemplate) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscClusterTemplateList) DeepCopyInto(out *OscClusterTemplateList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]OscClusterTemplate, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscClusterTemplateList.
func (in *OscClusterTemplateList) DeepCopy() *OscClusterTemplateList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscClusterTemplateList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OscClusterTemplateList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscClusterTemplateResource) DeepCopyInto(out *OscClusterTemplateResource) <span class="cov0" title="0">{
        *out = *in
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscClusterTemplateResource.
func (in *OscClusterTemplateResource) DeepCopy() *OscClusterTemplateResource <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscClusterTemplateResource)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscClusterTemplateSpec) DeepCopyInto(out *OscClusterTemplateSpec) <span class="cov0" title="0">{
        *out = *in
        in.Template.DeepCopyInto(&amp;out.Template)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscClusterTemplateSpec.
func (in *OscClusterTemplateSpec) DeepCopy() *OscClusterTemplateSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscClusterTemplateSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscImage) DeepCopyInto(out *OscImage) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscImage.
func (in *OscImage) DeepCopy() *OscImage <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscImage)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscInternetService) DeepCopyInto(out *OscInternetService) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscInternetService.
func (in *OscInternetService) DeepCopy() *OscInternetService <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscInternetService)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscKeypair) DeepCopyInto(out *OscKeypair) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscKeypair.
func (in *OscKeypair) DeepCopy() *OscKeypair <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscKeypair)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscLoadBalancer) DeepCopyInto(out *OscLoadBalancer) <span class="cov0" title="0">{
        *out = *in
        out.Listener = in.Listener
        out.HealthCheck = in.HealthCheck
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscLoadBalancer.
func (in *OscLoadBalancer) DeepCopy() *OscLoadBalancer <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscLoadBalancer)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscLoadBalancerHealthCheck) DeepCopyInto(out *OscLoadBalancerHealthCheck) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscLoadBalancerHealthCheck.
func (in *OscLoadBalancerHealthCheck) DeepCopy() *OscLoadBalancerHealthCheck <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscLoadBalancerHealthCheck)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscLoadBalancerListener) DeepCopyInto(out *OscLoadBalancerListener) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscLoadBalancerListener.
func (in *OscLoadBalancerListener) DeepCopy() *OscLoadBalancerListener <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscLoadBalancerListener)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscMachine) DeepCopyInto(out *OscMachine) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscMachine.
func (in *OscMachine) DeepCopy() *OscMachine <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscMachine)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OscMachine) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscMachineList) DeepCopyInto(out *OscMachineList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]OscMachine, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscMachineList.
func (in *OscMachineList) DeepCopy() *OscMachineList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscMachineList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OscMachineList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscMachineSpec) DeepCopyInto(out *OscMachineSpec) <span class="cov0" title="0">{
        *out = *in
        if in.ProviderID != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProviderID, &amp;out.ProviderID
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">in.Node.DeepCopyInto(&amp;out.Node)</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscMachineSpec.
func (in *OscMachineSpec) DeepCopy() *OscMachineSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscMachineSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscMachineStatus) DeepCopyInto(out *OscMachineStatus) <span class="cov0" title="0">{
        *out = *in
        if in.Addresses != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Addresses, &amp;out.Addresses
                *out = make([]v1.NodeAddress, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.FailureReason != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureReason, &amp;out.FailureReason
                *out = new(errors.MachineStatusError)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.VmState != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.VmState, &amp;out.VmState
                *out = new(VmState)
                **out = **in
        }</span>
        <span class="cov0" title="0">in.Node.DeepCopyInto(&amp;out.Node)
        if in.FailureMessage != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureMessage, &amp;out.FailureMessage
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscMachineStatus.
func (in *OscMachineStatus) DeepCopy() *OscMachineStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscMachineStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscMachineTemplate) DeepCopyInto(out *OscMachineTemplate) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscMachineTemplate.
func (in *OscMachineTemplate) DeepCopy() *OscMachineTemplate <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscMachineTemplate)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OscMachineTemplate) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscMachineTemplateList) DeepCopyInto(out *OscMachineTemplateList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]OscMachineTemplate, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscMachineTemplateList.
func (in *OscMachineTemplateList) DeepCopy() *OscMachineTemplateList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscMachineTemplateList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OscMachineTemplateList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscMachineTemplateResource) DeepCopyInto(out *OscMachineTemplateResource) <span class="cov0" title="0">{
        *out = *in
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscMachineTemplateResource.
func (in *OscMachineTemplateResource) DeepCopy() *OscMachineTemplateResource <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscMachineTemplateResource)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscMachineTemplateSpec) DeepCopyInto(out *OscMachineTemplateSpec) <span class="cov0" title="0">{
        *out = *in
        in.Template.DeepCopyInto(&amp;out.Template)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscMachineTemplateSpec.
func (in *OscMachineTemplateSpec) DeepCopy() *OscMachineTemplateSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscMachineTemplateSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscMachineTemplateStatus) DeepCopyInto(out *OscMachineTemplateStatus) <span class="cov0" title="0">{
        *out = *in
        if in.Capacity != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Capacity, &amp;out.Capacity
                *out = make(v1.ResourceList, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val.DeepCopy()
                }</span>
        }
        <span class="cov0" title="0">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscMachineTemplateStatus.
func (in *OscMachineTemplateStatus) DeepCopy() *OscMachineTemplateStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscMachineTemplateStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscNatService) DeepCopyInto(out *OscNatService) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscNatService.
func (in *OscNatService) DeepCopy() *OscNatService <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscNatService)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscNet) DeepCopyInto(out *OscNet) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscNet.
func (in *OscNet) DeepCopy() *OscNet <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscNet)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscNetwork) DeepCopyInto(out *OscNetwork) <span class="cov0" title="0">{
        *out = *in
        out.LoadBalancer = in.LoadBalancer
        out.Net = in.Net
        if in.Subnets != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Subnets, &amp;out.Subnets
                *out = make([]*OscSubnet, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if (*in)[i] != nil </span><span class="cov0" title="0">{
                                in, out := &amp;(*in)[i], &amp;(*out)[i]
                                *out = new(OscSubnet)
                                **out = **in
                        }</span>
                }
        }
        <span class="cov0" title="0">out.InternetService = in.InternetService
        out.NatService = in.NatService
        if in.RouteTables != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.RouteTables, &amp;out.RouteTables
                *out = make([]*OscRouteTable, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if (*in)[i] != nil </span><span class="cov0" title="0">{
                                in, out := &amp;(*in)[i], &amp;(*out)[i]
                                *out = new(OscRouteTable)
                                (*in).DeepCopyInto(*out)
                        }</span>
                }
        }
        <span class="cov0" title="0">if in.SecurityGroups != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SecurityGroups, &amp;out.SecurityGroups
                *out = make([]*OscSecurityGroup, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if (*in)[i] != nil </span><span class="cov0" title="0">{
                                in, out := &amp;(*in)[i], &amp;(*out)[i]
                                *out = new(OscSecurityGroup)
                                (*in).DeepCopyInto(*out)
                        }</span>
                }
        }
        <span class="cov0" title="0">if in.PublicIps != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.PublicIps, &amp;out.PublicIps
                *out = make([]*OscPublicIp, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if (*in)[i] != nil </span><span class="cov0" title="0">{
                                in, out := &amp;(*in)[i], &amp;(*out)[i]
                                *out = new(OscPublicIp)
                                **out = **in
                        }</span>
                }
        }
        <span class="cov0" title="0">out.Image = in.Image
        in.Bastion.DeepCopyInto(&amp;out.Bastion)</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscNetwork.
func (in *OscNetwork) DeepCopy() *OscNetwork <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscNetwork)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscNetworkResource) DeepCopyInto(out *OscNetworkResource) <span class="cov0" title="0">{
        *out = *in
        in.LoadbalancerRef.DeepCopyInto(&amp;out.LoadbalancerRef)
        in.NetRef.DeepCopyInto(&amp;out.NetRef)
        in.SubnetRef.DeepCopyInto(&amp;out.SubnetRef)
        in.InternetServiceRef.DeepCopyInto(&amp;out.InternetServiceRef)
        in.RouteTablesRef.DeepCopyInto(&amp;out.RouteTablesRef)
        if in.LinkRouteTableRef != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LinkRouteTableRef, &amp;out.LinkRouteTableRef
                *out = make(map[string][]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        var outVal []string
                        if val == nil </span><span class="cov0" title="0">{
                                (*out)[key] = nil
                        }</span> else<span class="cov0" title="0"> {
                                in, out := &amp;val, &amp;outVal
                                *out = make([]string, len(*in))
                                copy(*out, *in)
                        }</span>
                        <span class="cov0" title="0">(*out)[key] = outVal</span>
                }
        }
        <span class="cov0" title="0">in.RouteRef.DeepCopyInto(&amp;out.RouteRef)
        in.SecurityGroupsRef.DeepCopyInto(&amp;out.SecurityGroupsRef)
        in.SecurityGroupRuleRef.DeepCopyInto(&amp;out.SecurityGroupRuleRef)
        in.PublicIpRef.DeepCopyInto(&amp;out.PublicIpRef)
        in.NatServiceRef.DeepCopyInto(&amp;out.NatServiceRef)
        in.BastionRef.DeepCopyInto(&amp;out.BastionRef)
        in.LinkPublicIpRef.DeepCopyInto(&amp;out.LinkPublicIpRef)</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscNetworkResource.
func (in *OscNetworkResource) DeepCopy() *OscNetworkResource <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscNetworkResource)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscNode) DeepCopyInto(out *OscNode) <span class="cov0" title="0">{
        *out = *in
        in.Vm.DeepCopyInto(&amp;out.Vm)
        out.Image = in.Image
        if in.Volumes != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Volumes, &amp;out.Volumes
                *out = make([]*OscVolume, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if (*in)[i] != nil </span><span class="cov0" title="0">{
                                in, out := &amp;(*in)[i], &amp;(*out)[i]
                                *out = new(OscVolume)
                                **out = **in
                        }</span>
                }
        }
        <span class="cov0" title="0">out.KeyPair = in.KeyPair</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscNode.
func (in *OscNode) DeepCopy() *OscNode <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscNode)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscNodeResource) DeepCopyInto(out *OscNodeResource) <span class="cov0" title="0">{
        *out = *in
        in.VolumeRef.DeepCopyInto(&amp;out.VolumeRef)
        in.ImageRef.DeepCopyInto(&amp;out.ImageRef)
        in.KeypairRef.DeepCopyInto(&amp;out.KeypairRef)
        in.VmRef.DeepCopyInto(&amp;out.VmRef)
        in.LinkPublicIpRef.DeepCopyInto(&amp;out.LinkPublicIpRef)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscNodeResource.
func (in *OscNodeResource) DeepCopy() *OscNodeResource <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscNodeResource)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscPrivateIpElement) DeepCopyInto(out *OscPrivateIpElement) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscPrivateIpElement.
func (in *OscPrivateIpElement) DeepCopy() *OscPrivateIpElement <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscPrivateIpElement)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscPublicIp) DeepCopyInto(out *OscPublicIp) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscPublicIp.
func (in *OscPublicIp) DeepCopy() *OscPublicIp <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscPublicIp)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscResourceReference) DeepCopyInto(out *OscResourceReference) <span class="cov0" title="0">{
        *out = *in
        if in.ResourceMap != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ResourceMap, &amp;out.ResourceMap
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscResourceReference.
func (in *OscResourceReference) DeepCopy() *OscResourceReference <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscResourceReference)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscRootDisk) DeepCopyInto(out *OscRootDisk) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscRootDisk.
func (in *OscRootDisk) DeepCopy() *OscRootDisk <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscRootDisk)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscRoute) DeepCopyInto(out *OscRoute) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscRoute.
func (in *OscRoute) DeepCopy() *OscRoute <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscRoute)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscRouteTable) DeepCopyInto(out *OscRouteTable) <span class="cov0" title="0">{
        *out = *in
        if in.Subnets != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Subnets, &amp;out.Subnets
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.Routes != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Routes, &amp;out.Routes
                *out = make([]OscRoute, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscRouteTable.
func (in *OscRouteTable) DeepCopy() *OscRouteTable <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscRouteTable)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscSecurityGroup) DeepCopyInto(out *OscSecurityGroup) <span class="cov0" title="0">{
        *out = *in
        if in.SecurityGroupRules != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SecurityGroupRules, &amp;out.SecurityGroupRules
                *out = make([]OscSecurityGroupRule, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscSecurityGroup.
func (in *OscSecurityGroup) DeepCopy() *OscSecurityGroup <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscSecurityGroup)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscSecurityGroupElement) DeepCopyInto(out *OscSecurityGroupElement) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscSecurityGroupElement.
func (in *OscSecurityGroupElement) DeepCopy() *OscSecurityGroupElement <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscSecurityGroupElement)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscSecurityGroupRule) DeepCopyInto(out *OscSecurityGroupRule) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscSecurityGroupRule.
func (in *OscSecurityGroupRule) DeepCopy() *OscSecurityGroupRule <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscSecurityGroupRule)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscSubnet) DeepCopyInto(out *OscSubnet) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscSubnet.
func (in *OscSubnet) DeepCopy() *OscSubnet <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscSubnet)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscVm) DeepCopyInto(out *OscVm) <span class="cov0" title="0">{
        *out = *in
        out.RootDisk = in.RootDisk
        if in.PrivateIps != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.PrivateIps, &amp;out.PrivateIps
                *out = make([]OscPrivateIpElement, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.SecurityGroupNames != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SecurityGroupNames, &amp;out.SecurityGroupNames
                *out = make([]OscSecurityGroupElement, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscVm.
func (in *OscVm) DeepCopy() *OscVm <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscVm)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OscVolume) DeepCopyInto(out *OscVolume) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OscVolume.
func (in *OscVolume) DeepCopy() *OscVolume <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OscVolume)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
